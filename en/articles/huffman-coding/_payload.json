[{"data":1,"prerenderedAt":1271},["ShallowReactive",2],{"/en/articles/huffman-coding":3},{"id":4,"title":5,"body":6,"date":1247,"description":1248,"extension":19,"head":1249,"image":1257,"meta":1258,"navigation":38,"ogImage":1259,"path":1261,"readingTime":1247,"robots":1247,"schemaOrg":1262,"seo":1263,"sitemap":1264,"stem":1268,"tags":1269,"__hash__":1270},"articles_en/en/articles/huffman-coding.md","Memahami Algoritma Huffman Coding",{"type":7,"value":8,"toc":1236},"minimal",[9,14,780,785,1087,1091,1096,1107,1111,1127,1131,1155,1159,1182,1186,1200,1204,1219,1222,1232],[10,11,13],"h1",{"id":12},"huffman-coding","HUFFMAN CODING",[15,16,21],"pre",{"className":17,"code":18,"language":19,"meta":20,"style":20},"language-md shiki shiki-themes github-dark github-dark github-light","# Apa itu Huffman Coding?\n\n**Huffman Coding** adalah algoritma kompresi data yang menggunakan pendekatan **greedy** untuk membuat **kode biner dengan panjang variabel**. Karakter yang lebih sering muncul diberi kode yang lebih pendek, dan karakter yang lebih jarang diberi kode yang lebih panjang.\n\n---\n\n## üîß Aplikasi Huffman Coding\n- üì¶ Kompresi file (ZIP, JPEG)\n- üì° Komunikasi data (pengurangan bandwidth)\n- üíæ Penyimpanan data (penghematan ruang)\n- üîê Kriptografi (penyandian berbasis frekuensi)\n\n---\n\n## üîÑ Cara Kerja Huffman Coding\n\n### 1. **Hitung Frekuensi**\n- Hitung kemunculan setiap karakter.\n\n### 2. **Bangun Huffman Tree**\n- Buat node daun untuk tiap karakter.\n- Masukkan node ke dalam **min-heap** berdasarkan frekuensi.\n- Gabungkan dua node dengan frekuensi terkecil.\n- Ulangi hingga hanya tersisa satu node (akar pohon).\n\n### 3. **Hasilkan Kode**\n- Telusuri pohon dari akar ke tiap daun.\n- Tetapkan `0` ke cabang kiri dan `1` ke cabang kanan.\n- Karakter disandikan dengan jalur dari akar ke daunnya.\n\n---\n\n## üìå Contoh Masalah\n\n**Input:** `\"AABBCC\"`\n\n### Langkah-langkah:\n- Frekuensi: `A=2`, `B=2`, `C=2`\n- Min-heap awal: `[A:2, B:2, C:2]`\n- Gabung A dan B ‚Üí `AB:4`\n- Gabung AB dan C ‚Üí `ABC:6`\n- Hasil kode (contoh):\n  - A: `00`\n  - B: `01`\n  - C: `1`\n- Hasil encoding: `AABBCC` ‚Üí `000001011`\n\n**Efisiensi:**\n- ASCII: `6 √ó 8 = 48 bit`\n- Huffman: `9 bit` ‚Üí Hemat ruang signifikan!\n\n---\n\n## üß™ Implementasi Python\n\n```python\nimport heapq\nfrom collections import Counter\n\nclass Node:\n    def __init__(self, char, freq):\n        self.char = char\n        self.freq = freq\n        self.left = None\n        self.right = None\n    \n    def __lt__(self, other):\n        return self.freq \u003C other.freq\n\ndef build_huffman_tree(data):\n    freq = Counter(data)\n    heap = [Node(char, f) for char, f in freq.items()]\n    heapq.heapify(heap)\n    \n    while len(heap) > 1:\n        left = heapq.heappop(heap)\n        right = heapq.heappop(heap)\n        parent = Node(None, left.freq + right.freq)\n        parent.left = left\n        parent.right = right\n        heapq.heappush(heap, parent)\n    \n    return heap[0]\n\ndef generate_codes(root, code=\"\", codes={}):\n    if root:\n        if root.char is not None:\n            codes[root.char] = code or \"0\"\n        generate_codes(root.left, code + \"0\", codes)\n        generate_codes(root.right, code + \"1\", codes)\n    return codes\n\ndef huffman_coding(data):\n    if not data:\n        return \"\", {}\n    root = build_huffman_tree(data)\n    codes = generate_codes(root)\n    encoded = ''.join(codes[char] for char in data)\n    return encoded, codes\n\n# Contoh penggunaan\ndata = \"AABBCC\"\nencoded, codes = huffman_coding(data)\nprint(\"Kode Huffman:\", codes)\nprint(\"Data tersandi:\", encoded)\n","md","",[22,23,24,33,40,63,68,74,79,85,95,103,111,119,124,129,134,140,145,154,162,167,176,184,198,206,214,219,228,236,257,265,270,275,280,286,291,300,305,311,333,344,355,366,374,386,397,408,425,430,436,447,461,466,471,476,482,487,493,499,505,510,516,522,528,534,540,546,552,558,564,569,575,581,587,593,598,604,610,616,622,628,634,640,645,651,656,662,668,674,680,686,692,698,703,709,715,721,727,733,739,745,750,756,762,768,774],"code",{"__ignoreMap":20},[25,26,29],"span",{"class":27,"line":28},"line",1,[25,30,32],{"class":31},"sXvaJ","# Apa itu Huffman Coding?\n",[25,34,36],{"class":27,"line":35},2,[25,37,39],{"emptyLinePlaceholder":38},true,"\n",[25,41,43,47,51,54,57,60],{"class":27,"line":42},3,[25,44,46],{"class":45},"s9_AW","**Huffman Coding**",[25,48,50],{"class":49},"suVJd"," adalah algoritma kompresi data yang menggunakan pendekatan ",[25,52,53],{"class":45},"**greedy**",[25,55,56],{"class":49}," untuk membuat ",[25,58,59],{"class":45},"**kode biner dengan panjang variabel**",[25,61,62],{"class":49},". Karakter yang lebih sering muncul diberi kode yang lebih pendek, dan karakter yang lebih jarang diberi kode yang lebih panjang.\n",[25,64,66],{"class":27,"line":65},4,[25,67,39],{"emptyLinePlaceholder":38},[25,69,71],{"class":27,"line":70},5,[25,72,73],{"class":31},"---\n",[25,75,77],{"class":27,"line":76},6,[25,78,39],{"emptyLinePlaceholder":38},[25,80,82],{"class":27,"line":81},7,[25,83,84],{"class":31},"## üîß Aplikasi Huffman Coding\n",[25,86,88,92],{"class":27,"line":87},8,[25,89,91],{"class":90},"s1uPE","-",[25,93,94],{"class":49}," üì¶ Kompresi file (ZIP, JPEG)\n",[25,96,98,100],{"class":27,"line":97},9,[25,99,91],{"class":90},[25,101,102],{"class":49}," üì° Komunikasi data (pengurangan bandwidth)\n",[25,104,106,108],{"class":27,"line":105},10,[25,107,91],{"class":90},[25,109,110],{"class":49}," üíæ Penyimpanan data (penghematan ruang)\n",[25,112,114,116],{"class":27,"line":113},11,[25,115,91],{"class":90},[25,117,118],{"class":49}," üîê Kriptografi (penyandian berbasis frekuensi)\n",[25,120,122],{"class":27,"line":121},12,[25,123,39],{"emptyLinePlaceholder":38},[25,125,127],{"class":27,"line":126},13,[25,128,73],{"class":31},[25,130,132],{"class":27,"line":131},14,[25,133,39],{"emptyLinePlaceholder":38},[25,135,137],{"class":27,"line":136},15,[25,138,139],{"class":31},"## üîÑ Cara Kerja Huffman Coding\n",[25,141,143],{"class":27,"line":142},16,[25,144,39],{"emptyLinePlaceholder":38},[25,146,148,151],{"class":27,"line":147},17,[25,149,150],{"class":31},"### 1. ",[25,152,153],{"class":45},"**Hitung Frekuensi**\n",[25,155,157,159],{"class":27,"line":156},18,[25,158,91],{"class":90},[25,160,161],{"class":49}," Hitung kemunculan setiap karakter.\n",[25,163,165],{"class":27,"line":164},19,[25,166,39],{"emptyLinePlaceholder":38},[25,168,170,173],{"class":27,"line":169},20,[25,171,172],{"class":31},"### 2. ",[25,174,175],{"class":45},"**Bangun Huffman Tree**\n",[25,177,179,181],{"class":27,"line":178},21,[25,180,91],{"class":90},[25,182,183],{"class":49}," Buat node daun untuk tiap karakter.\n",[25,185,187,189,192,195],{"class":27,"line":186},22,[25,188,91],{"class":90},[25,190,191],{"class":49}," Masukkan node ke dalam ",[25,193,194],{"class":45},"**min-heap**",[25,196,197],{"class":49}," berdasarkan frekuensi.\n",[25,199,201,203],{"class":27,"line":200},23,[25,202,91],{"class":90},[25,204,205],{"class":49}," Gabungkan dua node dengan frekuensi terkecil.\n",[25,207,209,211],{"class":27,"line":208},24,[25,210,91],{"class":90},[25,212,213],{"class":49}," Ulangi hingga hanya tersisa satu node (akar pohon).\n",[25,215,217],{"class":27,"line":216},25,[25,218,39],{"emptyLinePlaceholder":38},[25,220,222,225],{"class":27,"line":221},26,[25,223,224],{"class":31},"### 3. ",[25,226,227],{"class":45},"**Hasilkan Kode**\n",[25,229,231,233],{"class":27,"line":230},27,[25,232,91],{"class":90},[25,234,235],{"class":49}," Telusuri pohon dari akar ke tiap daun.\n",[25,237,239,241,244,248,251,254],{"class":27,"line":238},28,[25,240,91],{"class":90},[25,242,243],{"class":49}," Tetapkan ",[25,245,247],{"class":246},"sAPL1","`0`",[25,249,250],{"class":49}," ke cabang kiri dan ",[25,252,253],{"class":246},"`1`",[25,255,256],{"class":49}," ke cabang kanan.\n",[25,258,260,262],{"class":27,"line":259},29,[25,261,91],{"class":90},[25,263,264],{"class":49}," Karakter disandikan dengan jalur dari akar ke daunnya.\n",[25,266,268],{"class":27,"line":267},30,[25,269,39],{"emptyLinePlaceholder":38},[25,271,273],{"class":27,"line":272},31,[25,274,73],{"class":31},[25,276,278],{"class":27,"line":277},32,[25,279,39],{"emptyLinePlaceholder":38},[25,281,283],{"class":27,"line":282},33,[25,284,285],{"class":31},"## üìå Contoh Masalah\n",[25,287,289],{"class":27,"line":288},34,[25,290,39],{"emptyLinePlaceholder":38},[25,292,294,297],{"class":27,"line":293},35,[25,295,296],{"class":45},"**Input:**",[25,298,299],{"class":246}," `\"AABBCC\"`\n",[25,301,303],{"class":27,"line":302},36,[25,304,39],{"emptyLinePlaceholder":38},[25,306,308],{"class":27,"line":307},37,[25,309,310],{"class":31},"### Langkah-langkah:\n",[25,312,314,316,319,322,325,328,330],{"class":27,"line":313},38,[25,315,91],{"class":90},[25,317,318],{"class":49}," Frekuensi: ",[25,320,321],{"class":246},"`A=2`",[25,323,324],{"class":49},", ",[25,326,327],{"class":246},"`B=2`",[25,329,324],{"class":49},[25,331,332],{"class":246},"`C=2`\n",[25,334,336,338,341],{"class":27,"line":335},39,[25,337,91],{"class":90},[25,339,340],{"class":49}," Min-heap awal: ",[25,342,343],{"class":246},"`[A:2, B:2, C:2]`\n",[25,345,347,349,352],{"class":27,"line":346},40,[25,348,91],{"class":90},[25,350,351],{"class":49}," Gabung A dan B ‚Üí ",[25,353,354],{"class":246},"`AB:4`\n",[25,356,358,360,363],{"class":27,"line":357},41,[25,359,91],{"class":90},[25,361,362],{"class":49}," Gabung AB dan C ‚Üí ",[25,364,365],{"class":246},"`ABC:6`\n",[25,367,369,371],{"class":27,"line":368},42,[25,370,91],{"class":90},[25,372,373],{"class":49}," Hasil kode (contoh):\n",[25,375,377,380,383],{"class":27,"line":376},43,[25,378,379],{"class":90},"  -",[25,381,382],{"class":49}," A: ",[25,384,385],{"class":246},"`00`\n",[25,387,389,391,394],{"class":27,"line":388},44,[25,390,379],{"class":90},[25,392,393],{"class":49}," B: ",[25,395,396],{"class":246},"`01`\n",[25,398,400,402,405],{"class":27,"line":399},45,[25,401,379],{"class":90},[25,403,404],{"class":49}," C: ",[25,406,407],{"class":246},"`1`\n",[25,409,411,413,416,419,422],{"class":27,"line":410},46,[25,412,91],{"class":90},[25,414,415],{"class":49}," Hasil encoding: ",[25,417,418],{"class":246},"`AABBCC`",[25,420,421],{"class":49}," ‚Üí ",[25,423,424],{"class":246},"`000001011`\n",[25,426,428],{"class":27,"line":427},47,[25,429,39],{"emptyLinePlaceholder":38},[25,431,433],{"class":27,"line":432},48,[25,434,435],{"class":45},"**Efisiensi:**\n",[25,437,439,441,444],{"class":27,"line":438},49,[25,440,91],{"class":90},[25,442,443],{"class":49}," ASCII: ",[25,445,446],{"class":246},"`6 √ó 8 = 48 bit`\n",[25,448,450,452,455,458],{"class":27,"line":449},50,[25,451,91],{"class":90},[25,453,454],{"class":49}," Huffman: ",[25,456,457],{"class":246},"`9 bit`",[25,459,460],{"class":49}," ‚Üí Hemat ruang signifikan!\n",[25,462,464],{"class":27,"line":463},51,[25,465,39],{"emptyLinePlaceholder":38},[25,467,469],{"class":27,"line":468},52,[25,470,73],{"class":31},[25,472,474],{"class":27,"line":473},53,[25,475,39],{"emptyLinePlaceholder":38},[25,477,479],{"class":27,"line":478},54,[25,480,481],{"class":31},"## üß™ Implementasi Python\n",[25,483,485],{"class":27,"line":484},55,[25,486,39],{"emptyLinePlaceholder":38},[25,488,490],{"class":27,"line":489},56,[25,491,492],{"class":49},"```python\n",[25,494,496],{"class":27,"line":495},57,[25,497,498],{"class":49},"import heapq\n",[25,500,502],{"class":27,"line":501},58,[25,503,504],{"class":49},"from collections import Counter\n",[25,506,508],{"class":27,"line":507},59,[25,509,39],{"emptyLinePlaceholder":38},[25,511,513],{"class":27,"line":512},60,[25,514,515],{"class":49},"class Node:\n",[25,517,519],{"class":27,"line":518},61,[25,520,521],{"class":49},"    def __init__(self, char, freq):\n",[25,523,525],{"class":27,"line":524},62,[25,526,527],{"class":49},"        self.char = char\n",[25,529,531],{"class":27,"line":530},63,[25,532,533],{"class":49},"        self.freq = freq\n",[25,535,537],{"class":27,"line":536},64,[25,538,539],{"class":49},"        self.left = None\n",[25,541,543],{"class":27,"line":542},65,[25,544,545],{"class":49},"        self.right = None\n",[25,547,549],{"class":27,"line":548},66,[25,550,551],{"class":49},"    \n",[25,553,555],{"class":27,"line":554},67,[25,556,557],{"class":49},"    def __lt__(self, other):\n",[25,559,561],{"class":27,"line":560},68,[25,562,563],{"class":49},"        return self.freq \u003C other.freq\n",[25,565,567],{"class":27,"line":566},69,[25,568,39],{"emptyLinePlaceholder":38},[25,570,572],{"class":27,"line":571},70,[25,573,574],{"class":49},"def build_huffman_tree(data):\n",[25,576,578],{"class":27,"line":577},71,[25,579,580],{"class":49},"    freq = Counter(data)\n",[25,582,584],{"class":27,"line":583},72,[25,585,586],{"class":49},"    heap = [Node(char, f) for char, f in freq.items()]\n",[25,588,590],{"class":27,"line":589},73,[25,591,592],{"class":49},"    heapq.heapify(heap)\n",[25,594,596],{"class":27,"line":595},74,[25,597,551],{"class":49},[25,599,601],{"class":27,"line":600},75,[25,602,603],{"class":49},"    while len(heap) > 1:\n",[25,605,607],{"class":27,"line":606},76,[25,608,609],{"class":49},"        left = heapq.heappop(heap)\n",[25,611,613],{"class":27,"line":612},77,[25,614,615],{"class":49},"        right = heapq.heappop(heap)\n",[25,617,619],{"class":27,"line":618},78,[25,620,621],{"class":49},"        parent = Node(None, left.freq + right.freq)\n",[25,623,625],{"class":27,"line":624},79,[25,626,627],{"class":49},"        parent.left = left\n",[25,629,631],{"class":27,"line":630},80,[25,632,633],{"class":49},"        parent.right = right\n",[25,635,637],{"class":27,"line":636},81,[25,638,639],{"class":49},"        heapq.heappush(heap, parent)\n",[25,641,643],{"class":27,"line":642},82,[25,644,551],{"class":49},[25,646,648],{"class":27,"line":647},83,[25,649,650],{"class":49},"    return heap[0]\n",[25,652,654],{"class":27,"line":653},84,[25,655,39],{"emptyLinePlaceholder":38},[25,657,659],{"class":27,"line":658},85,[25,660,661],{"class":49},"def generate_codes(root, code=\"\", codes={}):\n",[25,663,665],{"class":27,"line":664},86,[25,666,667],{"class":49},"    if root:\n",[25,669,671],{"class":27,"line":670},87,[25,672,673],{"class":49},"        if root.char is not None:\n",[25,675,677],{"class":27,"line":676},88,[25,678,679],{"class":49},"            codes[root.char] = code or \"0\"\n",[25,681,683],{"class":27,"line":682},89,[25,684,685],{"class":49},"        generate_codes(root.left, code + \"0\", codes)\n",[25,687,689],{"class":27,"line":688},90,[25,690,691],{"class":49},"        generate_codes(root.right, code + \"1\", codes)\n",[25,693,695],{"class":27,"line":694},91,[25,696,697],{"class":49},"    return codes\n",[25,699,701],{"class":27,"line":700},92,[25,702,39],{"emptyLinePlaceholder":38},[25,704,706],{"class":27,"line":705},93,[25,707,708],{"class":49},"def huffman_coding(data):\n",[25,710,712],{"class":27,"line":711},94,[25,713,714],{"class":49},"    if not data:\n",[25,716,718],{"class":27,"line":717},95,[25,719,720],{"class":49},"        return \"\", {}\n",[25,722,724],{"class":27,"line":723},96,[25,725,726],{"class":49},"    root = build_huffman_tree(data)\n",[25,728,730],{"class":27,"line":729},97,[25,731,732],{"class":49},"    codes = generate_codes(root)\n",[25,734,736],{"class":27,"line":735},98,[25,737,738],{"class":49},"    encoded = ''.join(codes[char] for char in data)\n",[25,740,742],{"class":27,"line":741},99,[25,743,744],{"class":49},"    return encoded, codes\n",[25,746,748],{"class":27,"line":747},100,[25,749,39],{"emptyLinePlaceholder":38},[25,751,753],{"class":27,"line":752},101,[25,754,755],{"class":49},"# Contoh penggunaan\n",[25,757,759],{"class":27,"line":758},102,[25,760,761],{"class":49},"data = \"AABBCC\"\n",[25,763,765],{"class":27,"line":764},103,[25,766,767],{"class":49},"encoded, codes = huffman_coding(data)\n",[25,769,771],{"class":27,"line":770},104,[25,772,773],{"class":49},"print(\"Kode Huffman:\", codes)\n",[25,775,777],{"class":27,"line":776},105,[25,778,779],{"class":49},"print(\"Data tersandi:\", encoded)\n",[781,782,784],"h2",{"id":783},"implementasi-javascript","üíª Implementasi JavaScript",[15,786,788],{"className":17,"code":787,"language":19,"meta":20,"style":20},"class Node {\n    constructor(char, freq) {\n        this.char = char;\n        this.freq = freq;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nfunction huffmanCoding(data) {\n    if (!data) return { encoded: \"\", codes: {} };\n\n    // Frekuensi karakter\n    const freq = {};\n    for (let char of data) {\n        freq[char] = (freq[char] || 0) + 1;\n    }\n\n    // Buat min-heap\n    const heap = Object.entries(freq).map(([char, freq]) => new Node(char, freq));\n    heap.sort((a, b) => a.freq - b.freq);\n\n    // Bangun pohon\n    while (heap.length > 1) {\n        const left = heap.shift();\n        const right = heap.shift();\n        const parent = new Node(null, left.freq + right.freq);\n        parent.left = left;\n        parent.right = right;\n        heap.push(parent);\n        heap.sort((a, b) => a.freq - b.freq);\n    }\n\n    // Generate kode\n    const codes = {};\n    function generateCodes(node, code = \"\") {\n        if (!node) return;\n        if (node.char !== null) {\n            codes[node.char] = code || \"0\";\n        }\n        generateCodes(node.left, code + \"0\");\n        generateCodes(node.right, code + \"1\");\n    }\n\n    generateCodes(heap[0]);\n\n    // Encode data\n    const encoded = data.split(\"\").map(char => codes[char]).join(\"\");\n    return { encoded, codes };\n}\n\n// Contoh penggunaan\nconst data = \"AABBCC\";\nconst { encoded, codes } = huffmanCoding(data);\nconsole.log(\"Kode Huffman:\", codes);\nconsole.log(\"Data tersandi:\", encoded);\n",[22,789,790,795,800,805,810,815,820,825,830,834,839,844,848,853,858,863,880,884,888,893,898,903,907,912,917,922,927,932,937,942,947,952,956,960,965,970,975,980,985,996,1001,1006,1011,1015,1019,1030,1034,1039,1049,1054,1058,1062,1067,1072,1077,1082],{"__ignoreMap":20},[25,791,792],{"class":27,"line":28},[25,793,794],{"class":49},"class Node {\n",[25,796,797],{"class":27,"line":35},[25,798,799],{"class":49},"    constructor(char, freq) {\n",[25,801,802],{"class":27,"line":42},[25,803,804],{"class":49},"        this.char = char;\n",[25,806,807],{"class":27,"line":65},[25,808,809],{"class":49},"        this.freq = freq;\n",[25,811,812],{"class":27,"line":70},[25,813,814],{"class":49},"        this.left = null;\n",[25,816,817],{"class":27,"line":76},[25,818,819],{"class":49},"        this.right = null;\n",[25,821,822],{"class":27,"line":81},[25,823,824],{"class":49},"    }\n",[25,826,827],{"class":27,"line":87},[25,828,829],{"class":49},"}\n",[25,831,832],{"class":27,"line":97},[25,833,39],{"emptyLinePlaceholder":38},[25,835,836],{"class":27,"line":105},[25,837,838],{"class":49},"function huffmanCoding(data) {\n",[25,840,841],{"class":27,"line":113},[25,842,843],{"class":49},"    if (!data) return { encoded: \"\", codes: {} };\n",[25,845,846],{"class":27,"line":121},[25,847,39],{"emptyLinePlaceholder":38},[25,849,850],{"class":27,"line":126},[25,851,852],{"class":49},"    // Frekuensi karakter\n",[25,854,855],{"class":27,"line":131},[25,856,857],{"class":49},"    const freq = {};\n",[25,859,860],{"class":27,"line":136},[25,861,862],{"class":49},"    for (let char of data) {\n",[25,864,865,868,872,875,877],{"class":27,"line":142},[25,866,867],{"class":49},"        freq[",[25,869,871],{"class":870},"s8Wv-","char",[25,873,874],{"class":49},"] = (freq[",[25,876,871],{"class":870},[25,878,879],{"class":49},"] || 0) + 1;\n",[25,881,882],{"class":27,"line":147},[25,883,824],{"class":49},[25,885,886],{"class":27,"line":156},[25,887,39],{"emptyLinePlaceholder":38},[25,889,890],{"class":27,"line":164},[25,891,892],{"class":49},"    // Buat min-heap\n",[25,894,895],{"class":27,"line":169},[25,896,897],{"class":49},"    const heap = Object.entries(freq).map(([char, freq]) => new Node(char, freq));\n",[25,899,900],{"class":27,"line":178},[25,901,902],{"class":49},"    heap.sort((a, b) => a.freq - b.freq);\n",[25,904,905],{"class":27,"line":186},[25,906,39],{"emptyLinePlaceholder":38},[25,908,909],{"class":27,"line":200},[25,910,911],{"class":49},"    // Bangun pohon\n",[25,913,914],{"class":27,"line":208},[25,915,916],{"class":49},"    while (heap.length > 1) {\n",[25,918,919],{"class":27,"line":216},[25,920,921],{"class":49},"        const left = heap.shift();\n",[25,923,924],{"class":27,"line":221},[25,925,926],{"class":49},"        const right = heap.shift();\n",[25,928,929],{"class":27,"line":230},[25,930,931],{"class":49},"        const parent = new Node(null, left.freq + right.freq);\n",[25,933,934],{"class":27,"line":238},[25,935,936],{"class":49},"        parent.left = left;\n",[25,938,939],{"class":27,"line":259},[25,940,941],{"class":49},"        parent.right = right;\n",[25,943,944],{"class":27,"line":267},[25,945,946],{"class":49},"        heap.push(parent);\n",[25,948,949],{"class":27,"line":272},[25,950,951],{"class":49},"        heap.sort((a, b) => a.freq - b.freq);\n",[25,953,954],{"class":27,"line":277},[25,955,824],{"class":49},[25,957,958],{"class":27,"line":282},[25,959,39],{"emptyLinePlaceholder":38},[25,961,962],{"class":27,"line":288},[25,963,964],{"class":49},"    // Generate kode\n",[25,966,967],{"class":27,"line":293},[25,968,969],{"class":49},"    const codes = {};\n",[25,971,972],{"class":27,"line":302},[25,973,974],{"class":49},"    function generateCodes(node, code = \"\") {\n",[25,976,977],{"class":27,"line":307},[25,978,979],{"class":49},"        if (!node) return;\n",[25,981,982],{"class":27,"line":313},[25,983,984],{"class":49},"        if (node.char !== null) {\n",[25,986,987,990,993],{"class":27,"line":335},[25,988,989],{"class":49},"            codes[",[25,991,992],{"class":870},"node.char",[25,994,995],{"class":49},"] = code || \"0\";\n",[25,997,998],{"class":27,"line":346},[25,999,1000],{"class":49},"        }\n",[25,1002,1003],{"class":27,"line":357},[25,1004,1005],{"class":49},"        generateCodes(node.left, code + \"0\");\n",[25,1007,1008],{"class":27,"line":368},[25,1009,1010],{"class":49},"        generateCodes(node.right, code + \"1\");\n",[25,1012,1013],{"class":27,"line":376},[25,1014,824],{"class":49},[25,1016,1017],{"class":27,"line":388},[25,1018,39],{"emptyLinePlaceholder":38},[25,1020,1021,1024,1027],{"class":27,"line":399},[25,1022,1023],{"class":49},"    generateCodes(heap[",[25,1025,1026],{"class":870},"0",[25,1028,1029],{"class":49},"]);\n",[25,1031,1032],{"class":27,"line":410},[25,1033,39],{"emptyLinePlaceholder":38},[25,1035,1036],{"class":27,"line":427},[25,1037,1038],{"class":49},"    // Encode data\n",[25,1040,1041,1044,1046],{"class":27,"line":432},[25,1042,1043],{"class":49},"    const encoded = data.split(\"\").map(char => codes[",[25,1045,871],{"class":870},[25,1047,1048],{"class":49},"]).join(\"\");\n",[25,1050,1051],{"class":27,"line":438},[25,1052,1053],{"class":49},"    return { encoded, codes };\n",[25,1055,1056],{"class":27,"line":449},[25,1057,829],{"class":49},[25,1059,1060],{"class":27,"line":463},[25,1061,39],{"emptyLinePlaceholder":38},[25,1063,1064],{"class":27,"line":468},[25,1065,1066],{"class":49},"// Contoh penggunaan\n",[25,1068,1069],{"class":27,"line":473},[25,1070,1071],{"class":49},"const data = \"AABBCC\";\n",[25,1073,1074],{"class":27,"line":478},[25,1075,1076],{"class":49},"const { encoded, codes } = huffmanCoding(data);\n",[25,1078,1079],{"class":27,"line":484},[25,1080,1081],{"class":49},"console.log(\"Kode Huffman:\", codes);\n",[25,1083,1084],{"class":27,"line":489},[25,1085,1086],{"class":49},"console.log(\"Data tersandi:\", encoded);\n",[781,1088,1090],{"id":1089},"Ô∏è-kompleksitas-optimasi","‚öôÔ∏è Kompleksitas & Optimasi",[1092,1093,1095],"h3",{"id":1094},"kompleksitas-waktu","‚è± Kompleksitas Waktu:",[1097,1098,1099],"ul",{},[1100,1101,1102,1106],"li",{},[1103,1104,1105],"strong",{},"O(n log n)"," untuk n karakter unik (karena operasi heap)",[1092,1108,1110],{"id":1109},"kompleksitas-ruang","üß† Kompleksitas Ruang:",[1097,1112,1113],{},[1100,1114,1115,1118,1119],{},[1103,1116,1117],{},"O(n)"," untuk menyimpan:\n",[1097,1120,1121,1124],{},[1100,1122,1123],{},"Pohon Huffman",[1100,1125,1126],{},"Tabel kode",[1092,1128,1130],{"id":1129},"optimasi","üöÄ Optimasi:",[1097,1132,1133,1140,1143,1149],{},[1100,1134,1135,1136,1139],{},"Gunakan ",[1103,1137,1138],{},"heap efisien"," (binary heap)",[1100,1141,1142],{},"Cache frekuensi untuk input berulang",[1100,1144,1145,1148],{},[1103,1146,1147],{},"Bit-level encoding"," untuk kompresi maksimal",[1100,1150,1135,1151,1154],{},[1103,1152,1153],{},"bitmask/buffer"," untuk implementasi skala besar",[781,1156,1158],{"id":1157},"kelebihan-huffman-coding","‚úÖ Kelebihan Huffman Coding",[1097,1160,1161,1168,1175],{},[1100,1162,1163,1164,1167],{},"üí° ",[1103,1165,1166],{},"Optimal"," untuk frekuensi karakter tak merata",[1100,1169,1170,1171,1174],{},"üîÑ ",[1103,1172,1173],{},"Prefiks kode"," ‚Üí tidak ambigu tanpa pemisah",[1100,1176,1177,1178,1181],{},"üîß ",[1103,1179,1180],{},"Dapat disesuaikan"," untuk berbagai format dan kasus",[781,1183,1185],{"id":1184},"kekurangan","‚ùå Kekurangan",[1097,1187,1188,1194,1197],{},[1100,1189,1190,1191],{},"üì¶ Perlu menyimpan ",[1103,1192,1193],{},"pohon kode",[1100,1195,1196],{},"üìä Kurang efisien untuk data kecil/seragam",[1100,1198,1199],{},"üìö Implementasi lebih rumit dibanding RLE atau metode sederhana lainnya",[781,1201,1203],{"id":1202},"kesimpulan","üéØ Kesimpulan",[1205,1206,1207,1210,1211,1214,1215,1218],"p",{},[1103,1208,1209],{},"Huffman Coding"," adalah algoritma inti dalam kompresi data. Dengan membangun ",[1103,1212,1213],{},"pohon Huffman"," dan menghasilkan ",[1103,1216,1217],{},"kode biner optimal",", ia memberikan cara efisien untuk mengurangi ukuran data tanpa kehilangan informasi.",[1205,1220,1221],{},"Meskipun memiliki keterbatasan, keunggulan dalam efisiensi dan fleksibilitas menjadikannya pilihan utama dalam banyak sistem kompresi modern.",[1223,1224,1225],"blockquote",{},[1205,1226,1227,1228],{},"üß† ",[1229,1230,1231],"em",{},"Belajar Huffman Coding bukan hanya belajar kompresi ‚Äî tapi juga belajar bagaimana greedy strategy digunakan untuk mencapai efisiensi optimal.",[1233,1234,1235],"style",{},"html pre.shiki code .sXvaJ, html code.shiki .sXvaJ{--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;--shiki-default:#79B8FF;--shiki-default-font-weight:bold;--shiki-light:#005CC5;--shiki-light-font-weight:bold}html pre.shiki code .s9_AW, html code.shiki .s9_AW{--shiki-dark:#E1E4E8;--shiki-dark-font-weight:bold;--shiki-default:#E1E4E8;--shiki-default-font-weight:bold;--shiki-light:#24292E;--shiki-light-font-weight:bold}html pre.shiki code .suVJd, html code.shiki .suVJd{--shiki-dark:#E1E4E8;--shiki-default:#E1E4E8;--shiki-light:#24292E}html pre.shiki code .s1uPE, html code.shiki .s1uPE{--shiki-dark:#FFAB70;--shiki-default:#FFAB70;--shiki-light:#E36209}html pre.shiki code .sAPL1, html code.shiki .sAPL1{--shiki-dark:#79B8FF;--shiki-default:#79B8FF;--shiki-light:#005CC5}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html pre.shiki code .s8Wv-, html code.shiki .s8Wv-{--shiki-dark:#DBEDFF;--shiki-dark-text-decoration:underline;--shiki-default:#DBEDFF;--shiki-default-text-decoration:underline;--shiki-light:#032F62;--shiki-light-text-decoration:underline}",{"title":20,"searchDepth":35,"depth":35,"links":1237},[1238,1239,1244,1245,1246],{"id":783,"depth":35,"text":784},{"id":1089,"depth":35,"text":1090,"children":1240},[1241,1242,1243],{"id":1094,"depth":42,"text":1095},{"id":1109,"depth":42,"text":1110},{"id":1129,"depth":42,"text":1130},{"id":1157,"depth":35,"text":1158},{"id":1184,"depth":35,"text":1185},{"id":1202,"depth":35,"text":1203},null,"Pelajari bagaimana Huffman Coding digunakan untuk kompresi data dengan efisien.",{"script":1250},[1251],{"type":1252,"key":1253,"data-nuxt-schema-org":38,"nodes":1254},"application/ld+json","schema-org-graph",[1255],{"_resolver":1256},"webPage","/articles/8.jpeg",{},{"props":1260},{},"/en/articles/huffman-coding",{"_resolver":1256},{"title":5,"description":1248},{"loc":1261,"videos":1265,"images":1266,"lastmod":1267},[],[],"2025-06-13T00:00:00.000Z","en/articles/huffman-coding",[],"FGXNNmqAXb8KAULLfG18IOHxAE8I3_6mQO-WoEaGJlE",1750352810714]