[{"data":1,"prerenderedAt":1097},["ShallowReactive",2],{"/en/articles/huffman-coding":3},{"id":4,"title":5,"body":6,"date":1072,"description":1073,"extension":1074,"head":1075,"image":1083,"meta":1084,"navigation":37,"ogImage":1085,"path":1087,"readingTime":1072,"robots":1072,"schemaOrg":1088,"seo":1089,"sitemap":1090,"stem":1094,"tags":1095,"__hash__":1096},"articles_en/en/articles/huffman-coding.md","Memahami Algoritma Huffman Coding",{"type":7,"value":8,"toc":1061},"minimal",[9,14,632,637,912,916,921,932,936,952,956,980,984,1007,1011,1025,1029,1044,1047,1057],[10,11,13],"h1",{"id":12},"huffman-coding","HUFFMAN CODING",[15,16,21],"pre",{"className":17,"code":18,"language":19,"meta":20,"style":20},"language-markdown shiki shiki-themes github-dark github-dark github-light","# Apa itu Huffman Coding?\n\n**Huffman Coding** adalah algoritma kompresi data yang menggunakan pendekatan **greedy** untuk membuat **kode biner dengan panjang variabel**. Karakter yang lebih sering muncul diberi kode yang lebih pendek, dan karakter yang lebih jarang diberi kode yang lebih panjang.\n\n---\n\n## ğŸ”§ Aplikasi Huffman Coding\n- ğŸ“¦ Kompresi file (ZIP, JPEG)\n- ğŸ“¡ Komunikasi data (pengurangan bandwidth)\n- ğŸ’¾ Penyimpanan data (penghematan ruang)\n- ğŸ” Kriptografi (penyandian berbasis frekuensi)\n\n---\n\n## ğŸ”„ Cara Kerja Huffman Coding\n\n### 1. **Hitung Frekuensi**\n- Hitung kemunculan setiap karakter.\n\n### 2. **Bangun Huffman Tree**\n- Buat node daun untuk tiap karakter.\n- Masukkan node ke dalam **min-heap** berdasarkan frekuensi.\n- Gabungkan dua node dengan frekuensi terkecil.\n- Ulangi hingga hanya tersisa satu node (akar pohon).\n\n### 3. **Hasilkan Kode**\n- Telusuri pohon dari akar ke tiap daun.\n- Tetapkan `0` ke cabang kiri dan `1` ke cabang kanan.\n- Karakter disandikan dengan jalur dari akar ke daunnya.\n\n---\n\n## ğŸ“Œ Contoh Masalah\n\n**Input:** `\"AABBCC\"`\n\n### Langkah-langkah:\n- Frekuensi: `A=2`, `B=2`, `C=2`\n- Min-heap awal: `[A:2, B:2, C:2]`\n- Gabung A dan B â†’ `AB:4`\n- Gabung AB dan C â†’ `ABC:6`\n- Hasil kode (contoh):\n  - A: `00`\n  - B: `01`\n  - C: `1`\n- Hasil encoding: `AABBCC` â†’ `000001011`\n\n**Efisiensi:**\n- ASCII: `6 Ã— 8 = 48 bit`\n- Huffman: `9 bit` â†’ Hemat ruang signifikan!\n\n---\n\n## ğŸ§ª Implementasi Python\n\n```python\nimport heapq\nfrom collections import Counter\n\nclass Node:\n    def __init__(self, char, freq):\n        self.char = char\n        self.freq = freq\n        self.left = None\n        self.right = None\n    \n    def __lt__(self, other):\n        return self.freq \u003C other.freq\n\ndef build_huffman_tree(data):\n    freq = Counter(data)\n    heap = [Node(char, f) for char, f in freq.items()]\n    heapq.heapify(heap)\n    \n    while len(heap) > 1:\n        left = heapq.heappop(heap)\n        right = heapq.heappop(heap)\n        parent = Node(None, left.freq + right.freq)\n        parent.left = left\n        parent.right = right\n        heapq.heappush(heap, parent)\n    \n    return heap[0]\n\ndef generate_codes(root, code=\"\", codes={}):\n    if root:\n        if root.char is not None:\n            codes[root.char] = code or \"0\"\n        generate_codes(root.left, code + \"0\", codes)\n        generate_codes(root.right, code + \"1\", codes)\n    return codes\n\ndef huffman_coding(data):\n    if not data:\n        return \"\", {}\n    root = build_huffman_tree(data)\n    codes = generate_codes(root)\n    encoded = ''.join(codes[char] for char in data)\n    return encoded, codes\n\n# Contoh penggunaan\ndata = \"AABBCC\"\nencoded, codes = huffman_coding(data)\nprint(\"Kode Huffman:\", codes)\nprint(\"Data tersandi:\", encoded)\n","markdown","",[22,23,24,32,39,45,50,56,61,67,73,79,85,91,96,101,106,112,117,123,129,134,140,146,152,158,164,169,175,181,187,193,198,203,208,214,219,225,230,236,242,248,254,260,266,272,278,284,290,295,301,307,313,318,323,328,334,339,345,351,357,362,368,374,380,386,392,398,404,410,416,421,427,433,439,445,450,456,462,468,474,480,486,492,497,503,508,514,520,526,532,538,544,550,555,561,567,573,579,585,591,597,602,608,614,620,626],"code",{"__ignoreMap":20},[25,26,29],"span",{"class":27,"line":28},"line",1,[25,30,31],{},"# Apa itu Huffman Coding?\n",[25,33,35],{"class":27,"line":34},2,[25,36,38],{"emptyLinePlaceholder":37},true,"\n",[25,40,42],{"class":27,"line":41},3,[25,43,44],{},"**Huffman Coding** adalah algoritma kompresi data yang menggunakan pendekatan **greedy** untuk membuat **kode biner dengan panjang variabel**. Karakter yang lebih sering muncul diberi kode yang lebih pendek, dan karakter yang lebih jarang diberi kode yang lebih panjang.\n",[25,46,48],{"class":27,"line":47},4,[25,49,38],{"emptyLinePlaceholder":37},[25,51,53],{"class":27,"line":52},5,[25,54,55],{},"---\n",[25,57,59],{"class":27,"line":58},6,[25,60,38],{"emptyLinePlaceholder":37},[25,62,64],{"class":27,"line":63},7,[25,65,66],{},"## ğŸ”§ Aplikasi Huffman Coding\n",[25,68,70],{"class":27,"line":69},8,[25,71,72],{},"- ğŸ“¦ Kompresi file (ZIP, JPEG)\n",[25,74,76],{"class":27,"line":75},9,[25,77,78],{},"- ğŸ“¡ Komunikasi data (pengurangan bandwidth)\n",[25,80,82],{"class":27,"line":81},10,[25,83,84],{},"- ğŸ’¾ Penyimpanan data (penghematan ruang)\n",[25,86,88],{"class":27,"line":87},11,[25,89,90],{},"- ğŸ” Kriptografi (penyandian berbasis frekuensi)\n",[25,92,94],{"class":27,"line":93},12,[25,95,38],{"emptyLinePlaceholder":37},[25,97,99],{"class":27,"line":98},13,[25,100,55],{},[25,102,104],{"class":27,"line":103},14,[25,105,38],{"emptyLinePlaceholder":37},[25,107,109],{"class":27,"line":108},15,[25,110,111],{},"## ğŸ”„ Cara Kerja Huffman Coding\n",[25,113,115],{"class":27,"line":114},16,[25,116,38],{"emptyLinePlaceholder":37},[25,118,120],{"class":27,"line":119},17,[25,121,122],{},"### 1. **Hitung Frekuensi**\n",[25,124,126],{"class":27,"line":125},18,[25,127,128],{},"- Hitung kemunculan setiap karakter.\n",[25,130,132],{"class":27,"line":131},19,[25,133,38],{"emptyLinePlaceholder":37},[25,135,137],{"class":27,"line":136},20,[25,138,139],{},"### 2. **Bangun Huffman Tree**\n",[25,141,143],{"class":27,"line":142},21,[25,144,145],{},"- Buat node daun untuk tiap karakter.\n",[25,147,149],{"class":27,"line":148},22,[25,150,151],{},"- Masukkan node ke dalam **min-heap** berdasarkan frekuensi.\n",[25,153,155],{"class":27,"line":154},23,[25,156,157],{},"- Gabungkan dua node dengan frekuensi terkecil.\n",[25,159,161],{"class":27,"line":160},24,[25,162,163],{},"- Ulangi hingga hanya tersisa satu node (akar pohon).\n",[25,165,167],{"class":27,"line":166},25,[25,168,38],{"emptyLinePlaceholder":37},[25,170,172],{"class":27,"line":171},26,[25,173,174],{},"### 3. **Hasilkan Kode**\n",[25,176,178],{"class":27,"line":177},27,[25,179,180],{},"- Telusuri pohon dari akar ke tiap daun.\n",[25,182,184],{"class":27,"line":183},28,[25,185,186],{},"- Tetapkan `0` ke cabang kiri dan `1` ke cabang kanan.\n",[25,188,190],{"class":27,"line":189},29,[25,191,192],{},"- Karakter disandikan dengan jalur dari akar ke daunnya.\n",[25,194,196],{"class":27,"line":195},30,[25,197,38],{"emptyLinePlaceholder":37},[25,199,201],{"class":27,"line":200},31,[25,202,55],{},[25,204,206],{"class":27,"line":205},32,[25,207,38],{"emptyLinePlaceholder":37},[25,209,211],{"class":27,"line":210},33,[25,212,213],{},"## ğŸ“Œ Contoh Masalah\n",[25,215,217],{"class":27,"line":216},34,[25,218,38],{"emptyLinePlaceholder":37},[25,220,222],{"class":27,"line":221},35,[25,223,224],{},"**Input:** `\"AABBCC\"`\n",[25,226,228],{"class":27,"line":227},36,[25,229,38],{"emptyLinePlaceholder":37},[25,231,233],{"class":27,"line":232},37,[25,234,235],{},"### Langkah-langkah:\n",[25,237,239],{"class":27,"line":238},38,[25,240,241],{},"- Frekuensi: `A=2`, `B=2`, `C=2`\n",[25,243,245],{"class":27,"line":244},39,[25,246,247],{},"- Min-heap awal: `[A:2, B:2, C:2]`\n",[25,249,251],{"class":27,"line":250},40,[25,252,253],{},"- Gabung A dan B â†’ `AB:4`\n",[25,255,257],{"class":27,"line":256},41,[25,258,259],{},"- Gabung AB dan C â†’ `ABC:6`\n",[25,261,263],{"class":27,"line":262},42,[25,264,265],{},"- Hasil kode (contoh):\n",[25,267,269],{"class":27,"line":268},43,[25,270,271],{},"  - A: `00`\n",[25,273,275],{"class":27,"line":274},44,[25,276,277],{},"  - B: `01`\n",[25,279,281],{"class":27,"line":280},45,[25,282,283],{},"  - C: `1`\n",[25,285,287],{"class":27,"line":286},46,[25,288,289],{},"- Hasil encoding: `AABBCC` â†’ `000001011`\n",[25,291,293],{"class":27,"line":292},47,[25,294,38],{"emptyLinePlaceholder":37},[25,296,298],{"class":27,"line":297},48,[25,299,300],{},"**Efisiensi:**\n",[25,302,304],{"class":27,"line":303},49,[25,305,306],{},"- ASCII: `6 Ã— 8 = 48 bit`\n",[25,308,310],{"class":27,"line":309},50,[25,311,312],{},"- Huffman: `9 bit` â†’ Hemat ruang signifikan!\n",[25,314,316],{"class":27,"line":315},51,[25,317,38],{"emptyLinePlaceholder":37},[25,319,321],{"class":27,"line":320},52,[25,322,55],{},[25,324,326],{"class":27,"line":325},53,[25,327,38],{"emptyLinePlaceholder":37},[25,329,331],{"class":27,"line":330},54,[25,332,333],{},"## ğŸ§ª Implementasi Python\n",[25,335,337],{"class":27,"line":336},55,[25,338,38],{"emptyLinePlaceholder":37},[25,340,342],{"class":27,"line":341},56,[25,343,344],{},"```python\n",[25,346,348],{"class":27,"line":347},57,[25,349,350],{},"import heapq\n",[25,352,354],{"class":27,"line":353},58,[25,355,356],{},"from collections import Counter\n",[25,358,360],{"class":27,"line":359},59,[25,361,38],{"emptyLinePlaceholder":37},[25,363,365],{"class":27,"line":364},60,[25,366,367],{},"class Node:\n",[25,369,371],{"class":27,"line":370},61,[25,372,373],{},"    def __init__(self, char, freq):\n",[25,375,377],{"class":27,"line":376},62,[25,378,379],{},"        self.char = char\n",[25,381,383],{"class":27,"line":382},63,[25,384,385],{},"        self.freq = freq\n",[25,387,389],{"class":27,"line":388},64,[25,390,391],{},"        self.left = None\n",[25,393,395],{"class":27,"line":394},65,[25,396,397],{},"        self.right = None\n",[25,399,401],{"class":27,"line":400},66,[25,402,403],{},"    \n",[25,405,407],{"class":27,"line":406},67,[25,408,409],{},"    def __lt__(self, other):\n",[25,411,413],{"class":27,"line":412},68,[25,414,415],{},"        return self.freq \u003C other.freq\n",[25,417,419],{"class":27,"line":418},69,[25,420,38],{"emptyLinePlaceholder":37},[25,422,424],{"class":27,"line":423},70,[25,425,426],{},"def build_huffman_tree(data):\n",[25,428,430],{"class":27,"line":429},71,[25,431,432],{},"    freq = Counter(data)\n",[25,434,436],{"class":27,"line":435},72,[25,437,438],{},"    heap = [Node(char, f) for char, f in freq.items()]\n",[25,440,442],{"class":27,"line":441},73,[25,443,444],{},"    heapq.heapify(heap)\n",[25,446,448],{"class":27,"line":447},74,[25,449,403],{},[25,451,453],{"class":27,"line":452},75,[25,454,455],{},"    while len(heap) > 1:\n",[25,457,459],{"class":27,"line":458},76,[25,460,461],{},"        left = heapq.heappop(heap)\n",[25,463,465],{"class":27,"line":464},77,[25,466,467],{},"        right = heapq.heappop(heap)\n",[25,469,471],{"class":27,"line":470},78,[25,472,473],{},"        parent = Node(None, left.freq + right.freq)\n",[25,475,477],{"class":27,"line":476},79,[25,478,479],{},"        parent.left = left\n",[25,481,483],{"class":27,"line":482},80,[25,484,485],{},"        parent.right = right\n",[25,487,489],{"class":27,"line":488},81,[25,490,491],{},"        heapq.heappush(heap, parent)\n",[25,493,495],{"class":27,"line":494},82,[25,496,403],{},[25,498,500],{"class":27,"line":499},83,[25,501,502],{},"    return heap[0]\n",[25,504,506],{"class":27,"line":505},84,[25,507,38],{"emptyLinePlaceholder":37},[25,509,511],{"class":27,"line":510},85,[25,512,513],{},"def generate_codes(root, code=\"\", codes={}):\n",[25,515,517],{"class":27,"line":516},86,[25,518,519],{},"    if root:\n",[25,521,523],{"class":27,"line":522},87,[25,524,525],{},"        if root.char is not None:\n",[25,527,529],{"class":27,"line":528},88,[25,530,531],{},"            codes[root.char] = code or \"0\"\n",[25,533,535],{"class":27,"line":534},89,[25,536,537],{},"        generate_codes(root.left, code + \"0\", codes)\n",[25,539,541],{"class":27,"line":540},90,[25,542,543],{},"        generate_codes(root.right, code + \"1\", codes)\n",[25,545,547],{"class":27,"line":546},91,[25,548,549],{},"    return codes\n",[25,551,553],{"class":27,"line":552},92,[25,554,38],{"emptyLinePlaceholder":37},[25,556,558],{"class":27,"line":557},93,[25,559,560],{},"def huffman_coding(data):\n",[25,562,564],{"class":27,"line":563},94,[25,565,566],{},"    if not data:\n",[25,568,570],{"class":27,"line":569},95,[25,571,572],{},"        return \"\", {}\n",[25,574,576],{"class":27,"line":575},96,[25,577,578],{},"    root = build_huffman_tree(data)\n",[25,580,582],{"class":27,"line":581},97,[25,583,584],{},"    codes = generate_codes(root)\n",[25,586,588],{"class":27,"line":587},98,[25,589,590],{},"    encoded = ''.join(codes[char] for char in data)\n",[25,592,594],{"class":27,"line":593},99,[25,595,596],{},"    return encoded, codes\n",[25,598,600],{"class":27,"line":599},100,[25,601,38],{"emptyLinePlaceholder":37},[25,603,605],{"class":27,"line":604},101,[25,606,607],{},"# Contoh penggunaan\n",[25,609,611],{"class":27,"line":610},102,[25,612,613],{},"data = \"AABBCC\"\n",[25,615,617],{"class":27,"line":616},103,[25,618,619],{},"encoded, codes = huffman_coding(data)\n",[25,621,623],{"class":27,"line":622},104,[25,624,625],{},"print(\"Kode Huffman:\", codes)\n",[25,627,629],{"class":27,"line":628},105,[25,630,631],{},"print(\"Data tersandi:\", encoded)\n",[633,634,636],"h2",{"id":635},"implementasi-javascript","ğŸ’» Implementasi JavaScript",[15,638,642],{"className":639,"code":640,"language":641,"meta":20,"style":20},"language-javascript shiki shiki-themes github-dark github-dark github-light","class Node {\n    constructor(char, freq) {\n        this.char = char;\n        this.freq = freq;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nfunction huffmanCoding(data) {\n    if (!data) return { encoded: \"\", codes: {} };\n\n    // Frekuensi karakter\n    const freq = {};\n    for (let char of data) {\n        freq[char] = (freq[char] || 0) + 1;\n    }\n\n    // Buat min-heap\n    const heap = Object.entries(freq).map(([char, freq]) => new Node(char, freq));\n    heap.sort((a, b) => a.freq - b.freq);\n\n    // Bangun pohon\n    while (heap.length > 1) {\n        const left = heap.shift();\n        const right = heap.shift();\n        const parent = new Node(null, left.freq + right.freq);\n        parent.left = left;\n        parent.right = right;\n        heap.push(parent);\n        heap.sort((a, b) => a.freq - b.freq);\n    }\n\n    // Generate kode\n    const codes = {};\n    function generateCodes(node, code = \"\") {\n        if (!node) return;\n        if (node.char !== null) {\n            codes[node.char] = code || \"0\";\n        }\n        generateCodes(node.left, code + \"0\");\n        generateCodes(node.right, code + \"1\");\n    }\n\n    generateCodes(heap[0]);\n\n    // Encode data\n    const encoded = data.split(\"\").map(char => codes[char]).join(\"\");\n    return { encoded, codes };\n}\n\n// Contoh penggunaan\nconst data = \"AABBCC\";\nconst { encoded, codes } = huffmanCoding(data);\nconsole.log(\"Kode Huffman:\", codes);\nconsole.log(\"Data tersandi:\", encoded);\n","javascript",[22,643,644,649,654,659,664,669,674,679,684,688,693,698,702,707,712,717,722,726,730,735,740,745,749,754,759,764,769,774,779,784,789,794,798,802,807,812,817,822,827,832,837,842,847,851,855,860,864,869,874,879,883,887,892,897,902,907],{"__ignoreMap":20},[25,645,646],{"class":27,"line":28},[25,647,648],{},"class Node {\n",[25,650,651],{"class":27,"line":34},[25,652,653],{},"    constructor(char, freq) {\n",[25,655,656],{"class":27,"line":41},[25,657,658],{},"        this.char = char;\n",[25,660,661],{"class":27,"line":47},[25,662,663],{},"        this.freq = freq;\n",[25,665,666],{"class":27,"line":52},[25,667,668],{},"        this.left = null;\n",[25,670,671],{"class":27,"line":58},[25,672,673],{},"        this.right = null;\n",[25,675,676],{"class":27,"line":63},[25,677,678],{},"    }\n",[25,680,681],{"class":27,"line":69},[25,682,683],{},"}\n",[25,685,686],{"class":27,"line":75},[25,687,38],{"emptyLinePlaceholder":37},[25,689,690],{"class":27,"line":81},[25,691,692],{},"function huffmanCoding(data) {\n",[25,694,695],{"class":27,"line":87},[25,696,697],{},"    if (!data) return { encoded: \"\", codes: {} };\n",[25,699,700],{"class":27,"line":93},[25,701,38],{"emptyLinePlaceholder":37},[25,703,704],{"class":27,"line":98},[25,705,706],{},"    // Frekuensi karakter\n",[25,708,709],{"class":27,"line":103},[25,710,711],{},"    const freq = {};\n",[25,713,714],{"class":27,"line":108},[25,715,716],{},"    for (let char of data) {\n",[25,718,719],{"class":27,"line":114},[25,720,721],{},"        freq[char] = (freq[char] || 0) + 1;\n",[25,723,724],{"class":27,"line":119},[25,725,678],{},[25,727,728],{"class":27,"line":125},[25,729,38],{"emptyLinePlaceholder":37},[25,731,732],{"class":27,"line":131},[25,733,734],{},"    // Buat min-heap\n",[25,736,737],{"class":27,"line":136},[25,738,739],{},"    const heap = Object.entries(freq).map(([char, freq]) => new Node(char, freq));\n",[25,741,742],{"class":27,"line":142},[25,743,744],{},"    heap.sort((a, b) => a.freq - b.freq);\n",[25,746,747],{"class":27,"line":148},[25,748,38],{"emptyLinePlaceholder":37},[25,750,751],{"class":27,"line":154},[25,752,753],{},"    // Bangun pohon\n",[25,755,756],{"class":27,"line":160},[25,757,758],{},"    while (heap.length > 1) {\n",[25,760,761],{"class":27,"line":166},[25,762,763],{},"        const left = heap.shift();\n",[25,765,766],{"class":27,"line":171},[25,767,768],{},"        const right = heap.shift();\n",[25,770,771],{"class":27,"line":177},[25,772,773],{},"        const parent = new Node(null, left.freq + right.freq);\n",[25,775,776],{"class":27,"line":183},[25,777,778],{},"        parent.left = left;\n",[25,780,781],{"class":27,"line":189},[25,782,783],{},"        parent.right = right;\n",[25,785,786],{"class":27,"line":195},[25,787,788],{},"        heap.push(parent);\n",[25,790,791],{"class":27,"line":200},[25,792,793],{},"        heap.sort((a, b) => a.freq - b.freq);\n",[25,795,796],{"class":27,"line":205},[25,797,678],{},[25,799,800],{"class":27,"line":210},[25,801,38],{"emptyLinePlaceholder":37},[25,803,804],{"class":27,"line":216},[25,805,806],{},"    // Generate kode\n",[25,808,809],{"class":27,"line":221},[25,810,811],{},"    const codes = {};\n",[25,813,814],{"class":27,"line":227},[25,815,816],{},"    function generateCodes(node, code = \"\") {\n",[25,818,819],{"class":27,"line":232},[25,820,821],{},"        if (!node) return;\n",[25,823,824],{"class":27,"line":238},[25,825,826],{},"        if (node.char !== null) {\n",[25,828,829],{"class":27,"line":244},[25,830,831],{},"            codes[node.char] = code || \"0\";\n",[25,833,834],{"class":27,"line":250},[25,835,836],{},"        }\n",[25,838,839],{"class":27,"line":256},[25,840,841],{},"        generateCodes(node.left, code + \"0\");\n",[25,843,844],{"class":27,"line":262},[25,845,846],{},"        generateCodes(node.right, code + \"1\");\n",[25,848,849],{"class":27,"line":268},[25,850,678],{},[25,852,853],{"class":27,"line":274},[25,854,38],{"emptyLinePlaceholder":37},[25,856,857],{"class":27,"line":280},[25,858,859],{},"    generateCodes(heap[0]);\n",[25,861,862],{"class":27,"line":286},[25,863,38],{"emptyLinePlaceholder":37},[25,865,866],{"class":27,"line":292},[25,867,868],{},"    // Encode data\n",[25,870,871],{"class":27,"line":297},[25,872,873],{},"    const encoded = data.split(\"\").map(char => codes[char]).join(\"\");\n",[25,875,876],{"class":27,"line":303},[25,877,878],{},"    return { encoded, codes };\n",[25,880,881],{"class":27,"line":309},[25,882,683],{},[25,884,885],{"class":27,"line":315},[25,886,38],{"emptyLinePlaceholder":37},[25,888,889],{"class":27,"line":320},[25,890,891],{},"// Contoh penggunaan\n",[25,893,894],{"class":27,"line":325},[25,895,896],{},"const data = \"AABBCC\";\n",[25,898,899],{"class":27,"line":330},[25,900,901],{},"const { encoded, codes } = huffmanCoding(data);\n",[25,903,904],{"class":27,"line":336},[25,905,906],{},"console.log(\"Kode Huffman:\", codes);\n",[25,908,909],{"class":27,"line":341},[25,910,911],{},"console.log(\"Data tersandi:\", encoded);\n",[633,913,915],{"id":914},"ï¸-kompleksitas-optimasi","âš™ï¸ Kompleksitas & Optimasi",[917,918,920],"h3",{"id":919},"kompleksitas-waktu","â± Kompleksitas Waktu:",[922,923,924],"ul",{},[925,926,927,931],"li",{},[928,929,930],"strong",{},"O(n log n)"," untuk n karakter unik (karena operasi heap)",[917,933,935],{"id":934},"kompleksitas-ruang","ğŸ§  Kompleksitas Ruang:",[922,937,938],{},[925,939,940,943,944],{},[928,941,942],{},"O(n)"," untuk menyimpan:\n",[922,945,946,949],{},[925,947,948],{},"Pohon Huffman",[925,950,951],{},"Tabel kode",[917,953,955],{"id":954},"optimasi","ğŸš€ Optimasi:",[922,957,958,965,968,974],{},[925,959,960,961,964],{},"Gunakan ",[928,962,963],{},"heap efisien"," (binary heap)",[925,966,967],{},"Cache frekuensi untuk input berulang",[925,969,970,973],{},[928,971,972],{},"Bit-level encoding"," untuk kompresi maksimal",[925,975,960,976,979],{},[928,977,978],{},"bitmask/buffer"," untuk implementasi skala besar",[633,981,983],{"id":982},"kelebihan-huffman-coding","âœ… Kelebihan Huffman Coding",[922,985,986,993,1000],{},[925,987,988,989,992],{},"ğŸ’¡ ",[928,990,991],{},"Optimal"," untuk frekuensi karakter tak merata",[925,994,995,996,999],{},"ğŸ”„ ",[928,997,998],{},"Prefiks kode"," â†’ tidak ambigu tanpa pemisah",[925,1001,1002,1003,1006],{},"ğŸ”§ ",[928,1004,1005],{},"Dapat disesuaikan"," untuk berbagai format dan kasus",[633,1008,1010],{"id":1009},"kekurangan","âŒ Kekurangan",[922,1012,1013,1019,1022],{},[925,1014,1015,1016],{},"ğŸ“¦ Perlu menyimpan ",[928,1017,1018],{},"pohon kode",[925,1020,1021],{},"ğŸ“Š Kurang efisien untuk data kecil/seragam",[925,1023,1024],{},"ğŸ“š Implementasi lebih rumit dibanding RLE atau metode sederhana lainnya",[633,1026,1028],{"id":1027},"kesimpulan","ğŸ¯ Kesimpulan",[1030,1031,1032,1035,1036,1039,1040,1043],"p",{},[928,1033,1034],{},"Huffman Coding"," adalah algoritma inti dalam kompresi data. Dengan membangun ",[928,1037,1038],{},"pohon Huffman"," dan menghasilkan ",[928,1041,1042],{},"kode biner optimal",", ia memberikan cara efisien untuk mengurangi ukuran data tanpa kehilangan informasi.",[1030,1045,1046],{},"Meskipun memiliki keterbatasan, keunggulan dalam efisiensi dan fleksibilitas menjadikannya pilihan utama dalam banyak sistem kompresi modern.",[1048,1049,1050],"blockquote",{},[1030,1051,1052,1053],{},"ğŸ§  ",[1054,1055,1056],"em",{},"Belajar Huffman Coding bukan hanya belajar kompresi â€” tapi juga belajar bagaimana greedy strategy digunakan untuk mencapai efisiensi optimal.",[1058,1059,1060],"style",{},"html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}",{"title":20,"searchDepth":34,"depth":34,"links":1062},[1063,1064,1069,1070,1071],{"id":635,"depth":34,"text":636},{"id":914,"depth":34,"text":915,"children":1065},[1066,1067,1068],{"id":919,"depth":41,"text":920},{"id":934,"depth":41,"text":935},{"id":954,"depth":41,"text":955},{"id":982,"depth":34,"text":983},{"id":1009,"depth":34,"text":1010},{"id":1027,"depth":34,"text":1028},null,"Pelajari bagaimana Huffman Coding digunakan untuk kompresi data dengan efisien.","md",{"script":1076},[1077],{"type":1078,"key":1079,"data-nuxt-schema-org":37,"nodes":1080},"application/ld+json","schema-org-graph",[1081],{"_resolver":1082},"webPage","/articles/8.jpeg",{},{"props":1086},{},"/en/articles/huffman-coding",{"_resolver":1082},{"title":5,"description":1073},{"loc":1087,"videos":1091,"images":1092,"lastmod":1093},[],[],"2025-06-13T00:00:00.000Z","en/articles/huffman-coding",[],"THiUaFJ_PipOSz-_NFowF-tfMH64UA_LrAyRDq7RTcc",1750332525228]