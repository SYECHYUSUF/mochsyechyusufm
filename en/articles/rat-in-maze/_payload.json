[{"data":1,"prerenderedAt":889},["ShallowReactive",2],{"/en/articles/rat-in-maze":3},{"id":4,"title":5,"body":6,"date":865,"description":866,"extension":19,"head":867,"image":875,"meta":876,"navigation":38,"ogImage":877,"path":879,"readingTime":865,"robots":865,"schemaOrg":880,"seo":881,"sitemap":882,"stem":886,"tags":887,"__hash__":888},"articles_en/en/articles/rat-in-maze.md","Memahami Algoritma Rat in Maze",{"type":7,"value":8,"toc":858},"minimal",[9,14,169,173,773,778,783,809,813,828,832,848,854],[10,11,13],"h1",{"id":12},"rat-in-maze","RAT IN MAZE",[15,16,21],"pre",{"className":17,"code":18,"language":19,"meta":20,"style":20},"language-md shiki shiki-themes github-dark github-dark github-light","# Apa itu Algoritma Rat in a Maze?\n\n**Rat in a Maze** adalah salah satu masalah klasik dalam pemrograman dan algoritma pencarian jalur. Tujuan dari algoritma ini adalah untuk menemukan **semua jalur** yang memungkinkan dari **titik awal (biasanya kiri atas)** ke **tujuan akhir (biasanya kanan bawah)** dalam sebuah labirin dua dimensi yang diwakili oleh **matriks**.\n\nSetiap sel dalam matriks bisa:\n- `1` ‚Üí jalan (bisa dilewati)\n- `0` ‚Üí dinding (tidak bisa dilewati)\n\n> üê≠ **Tikus** memulai dari `(0, 0)` dan ingin mencapai `(N-1, N-1)` hanya dengan bergerak ke **atas (U), bawah (D), kiri (L), atau kanan (R)** dan tidak boleh melewati sel yang sudah dilewati.\n\n---\n\n## Contoh Matriks (Maze)\n\n","md","",[22,23,24,33,40,75,80,86,100,111,116,147,152,158,163],"code",{"__ignoreMap":20},[25,26,29],"span",{"class":27,"line":28},"line",1,[25,30,32],{"class":31},"sXvaJ","# Apa itu Algoritma Rat in a Maze?\n",[25,34,36],{"class":27,"line":35},2,[25,37,39],{"emptyLinePlaceholder":38},true,"\n",[25,41,43,47,51,54,57,60,63,66,69,72],{"class":27,"line":42},3,[25,44,46],{"class":45},"s9_AW","**Rat in a Maze**",[25,48,50],{"class":49},"suVJd"," adalah salah satu masalah klasik dalam pemrograman dan algoritma pencarian jalur. Tujuan dari algoritma ini adalah untuk menemukan ",[25,52,53],{"class":45},"**semua jalur**",[25,55,56],{"class":49}," yang memungkinkan dari ",[25,58,59],{"class":45},"**titik awal (biasanya kiri atas)**",[25,61,62],{"class":49}," ke ",[25,64,65],{"class":45},"**tujuan akhir (biasanya kanan bawah)**",[25,67,68],{"class":49}," dalam sebuah labirin dua dimensi yang diwakili oleh ",[25,70,71],{"class":45},"**matriks**",[25,73,74],{"class":49},".\n",[25,76,78],{"class":27,"line":77},4,[25,79,39],{"emptyLinePlaceholder":38},[25,81,83],{"class":27,"line":82},5,[25,84,85],{"class":49},"Setiap sel dalam matriks bisa:\n",[25,87,89,93,97],{"class":27,"line":88},6,[25,90,92],{"class":91},"s1uPE","-",[25,94,96],{"class":95},"sAPL1"," `1`",[25,98,99],{"class":49}," ‚Üí jalan (bisa dilewati)\n",[25,101,103,105,108],{"class":27,"line":102},7,[25,104,92],{"class":91},[25,106,107],{"class":95}," `0`",[25,109,110],{"class":49}," ‚Üí dinding (tidak bisa dilewati)\n",[25,112,114],{"class":27,"line":113},8,[25,115,39],{"emptyLinePlaceholder":38},[25,117,119,123,126,129,132,135,138,141,144],{"class":27,"line":118},9,[25,120,122],{"class":121},"scWFE","> üê≠ ",[25,124,125],{"class":45},"**Tikus**",[25,127,128],{"class":121}," memulai dari ",[25,130,131],{"class":95},"`(0, 0)`",[25,133,134],{"class":121}," dan ingin mencapai ",[25,136,137],{"class":95},"`(N-1, N-1)`",[25,139,140],{"class":121}," hanya dengan bergerak ke ",[25,142,143],{"class":45},"**atas (U), bawah (D), kiri (L), atau kanan (R)**",[25,145,146],{"class":121}," dan tidak boleh melewati sel yang sudah dilewati.\n",[25,148,150],{"class":27,"line":149},10,[25,151,39],{"emptyLinePlaceholder":38},[25,153,155],{"class":27,"line":154},11,[25,156,157],{"class":31},"---\n",[25,159,161],{"class":27,"line":160},12,[25,162,39],{"emptyLinePlaceholder":38},[25,164,166],{"class":27,"line":165},13,[25,167,168],{"class":31},"## Contoh Matriks (Maze)\n",[170,171,172],"p",{},"maze = [ [1, 0, 0, 0], [1, 1, 0, 1], [0, 1, 0, 0], [1, 1, 1, 1] ]",[15,174,176],{"className":17,"code":175,"language":19,"meta":20,"style":20},"\n**Tujuan**: Temukan semua jalur dari `(0, 0)` ke `(3, 3)`. Dalam contoh ini, salah satu solusi bisa berupa jalur `DDRDRR`.\n\n---\n\n## Strategi Penyelesaian\n\n- Gunakan algoritma **Backtracking** untuk menjelajahi semua kemungkinan jalur.\n- Hanya lanjutkan ke sel jika:\n  - Berada dalam batas matriks.\n  - Nilainya `1` (jalan).\n  - Belum dikunjungi.\n- Simpan **jalur saat ini** sebagai string (misalnya \"DDR\").\n\n---\n\n## Langkah-langkah Algoritma\n\n1. Buat matriks `visited[][]` untuk menandai sel yang telah dikunjungi.\n2. Buat fungsi `solveMaze(x, y, path)`:\n   - Jika mencapai tujuan `(N-1, N-1)`, simpan `path`.\n   - Lanjutkan ke arah: Down (D), Left (L), Right (R), Up (U).\n   - Setelah mencoba satu arah, *backtrack* (reset visited).\n\n---\n\n## Implementasi (C++)\n\n```cpp\n#include \u003Ciostream>\n#include \u003Cvector>\n#include \u003Cstring>\n#include \u003Calgorithm>\n\nvoid solve(int x, int y, std::vector\u003Cstd::vector\u003Cint>>& maze, int n,\n           std::vector\u003Cstd::vector\u003Cbool>>& visited, std::string path,\n           std::vector\u003Cstd::string>& result) {\n    // Jika tujuan tercapai\n    if (x == n - 1 && y == n - 1) {\n        result.push_back(path);\n        return;\n    }\n\n    // Arah: D, L, R, U\n    int dx[] = {1, 0, 0, -1};\n    int dy[] = {0, -1, 1, 0};\n    char dir[] = {'D', 'L', 'R', 'U'};\n\n    for (int i = 0; i \u003C 4; ++i) {\n        int newX = x + dx[i], newY = y + dy[i];\n\n        if (newX >= 0 && newY >= 0 && newX \u003C n && newY \u003C n &&\n            maze[newX][newY] == 1 && !visited[newX][newY]) {\n            visited[newX][newY] = true;\n            solve(newX, newY, maze, n, visited, path + dir[i], result);\n            visited[newX][newY] = false; // Backtrack\n        }\n    }\n}\n\nstd::vector\u003Cstd::string> findPaths(std::vector\u003Cstd::vector\u003Cint>>& maze, int n) {\n    std::vector\u003Cstd::string> result;\n    std::vector\u003Cstd::vector\u003Cbool>> visited(n, std::vector\u003Cbool>(n, false));\n\n    if (maze[0][0] == 1) {\n        visited[0][0] = true;\n        solve(0, 0, maze, n, visited, \"\", result);\n    }\n\n    std::sort(result.begin(), result.end()); // opsional: urutkan hasil\n    return result;\n}\n\nint main() {\n    std::vector\u003Cstd::vector\u003Cint>> maze = {\n        {1, 0, 0, 0},\n        {1, 1, 0, 1},\n        {0, 1, 0, 0},\n        {1, 1, 1, 1}\n    };\n\n    int n = maze.size();\n    std::vector\u003Cstd::string> paths = findPaths(maze, n);\n\n    std::cout \u003C\u003C \"Semua jalur yang mungkin:\\n\";\n    for (const std::string& path : paths) {\n        std::cout \u003C\u003C path \u003C\u003C \"\\n\";\n    }\n\n    return 0;\n}\n",[22,177,178,182,205,209,213,217,222,226,239,246,254,267,274,287,292,297,302,308,313,328,343,362,370,385,390,395,400,406,411,417,423,429,435,441,446,452,458,464,470,476,482,488,494,499,505,511,517,523,528,534,540,545,551,557,563,569,575,581,586,592,597,603,609,615,620,626,632,638,643,648,654,660,665,670,676,682,688,694,700,706,712,717,723,729,734,740,746,752,757,762,768],{"__ignoreMap":20},[25,179,180],{"class":27,"line":28},[25,181,39],{"emptyLinePlaceholder":38},[25,183,184,187,190,192,194,197,200,203],{"class":27,"line":35},[25,185,186],{"class":45},"**Tujuan**",[25,188,189],{"class":49},": Temukan semua jalur dari ",[25,191,131],{"class":95},[25,193,62],{"class":49},[25,195,196],{"class":95},"`(3, 3)`",[25,198,199],{"class":49},". Dalam contoh ini, salah satu solusi bisa berupa jalur ",[25,201,202],{"class":95},"`DDRDRR`",[25,204,74],{"class":49},[25,206,207],{"class":27,"line":42},[25,208,39],{"emptyLinePlaceholder":38},[25,210,211],{"class":27,"line":77},[25,212,157],{"class":31},[25,214,215],{"class":27,"line":82},[25,216,39],{"emptyLinePlaceholder":38},[25,218,219],{"class":27,"line":88},[25,220,221],{"class":31},"## Strategi Penyelesaian\n",[25,223,224],{"class":27,"line":102},[25,225,39],{"emptyLinePlaceholder":38},[25,227,228,230,233,236],{"class":27,"line":113},[25,229,92],{"class":91},[25,231,232],{"class":49}," Gunakan algoritma ",[25,234,235],{"class":45},"**Backtracking**",[25,237,238],{"class":49}," untuk menjelajahi semua kemungkinan jalur.\n",[25,240,241,243],{"class":27,"line":118},[25,242,92],{"class":91},[25,244,245],{"class":49}," Hanya lanjutkan ke sel jika:\n",[25,247,248,251],{"class":27,"line":149},[25,249,250],{"class":91},"  -",[25,252,253],{"class":49}," Berada dalam batas matriks.\n",[25,255,256,258,261,264],{"class":27,"line":154},[25,257,250],{"class":91},[25,259,260],{"class":49}," Nilainya ",[25,262,263],{"class":95},"`1`",[25,265,266],{"class":49}," (jalan).\n",[25,268,269,271],{"class":27,"line":160},[25,270,250],{"class":91},[25,272,273],{"class":49}," Belum dikunjungi.\n",[25,275,276,278,281,284],{"class":27,"line":165},[25,277,92],{"class":91},[25,279,280],{"class":49}," Simpan ",[25,282,283],{"class":45},"**jalur saat ini**",[25,285,286],{"class":49}," sebagai string (misalnya \"DDR\").\n",[25,288,290],{"class":27,"line":289},14,[25,291,39],{"emptyLinePlaceholder":38},[25,293,295],{"class":27,"line":294},15,[25,296,157],{"class":31},[25,298,300],{"class":27,"line":299},16,[25,301,39],{"emptyLinePlaceholder":38},[25,303,305],{"class":27,"line":304},17,[25,306,307],{"class":31},"## Langkah-langkah Algoritma\n",[25,309,311],{"class":27,"line":310},18,[25,312,39],{"emptyLinePlaceholder":38},[25,314,316,319,322,325],{"class":27,"line":315},19,[25,317,318],{"class":91},"1.",[25,320,321],{"class":49}," Buat matriks ",[25,323,324],{"class":95},"`visited[][]`",[25,326,327],{"class":49}," untuk menandai sel yang telah dikunjungi.\n",[25,329,331,334,337,340],{"class":27,"line":330},20,[25,332,333],{"class":91},"2.",[25,335,336],{"class":49}," Buat fungsi ",[25,338,339],{"class":95},"`solveMaze(x, y, path)`",[25,341,342],{"class":49},":\n",[25,344,346,349,352,354,357,360],{"class":27,"line":345},21,[25,347,348],{"class":91},"   -",[25,350,351],{"class":49}," Jika mencapai tujuan ",[25,353,137],{"class":95},[25,355,356],{"class":49},", simpan ",[25,358,359],{"class":95},"`path`",[25,361,74],{"class":49},[25,363,365,367],{"class":27,"line":364},22,[25,366,348],{"class":91},[25,368,369],{"class":49}," Lanjutkan ke arah: Down (D), Left (L), Right (R), Up (U).\n",[25,371,373,375,378,382],{"class":27,"line":372},23,[25,374,348],{"class":91},[25,376,377],{"class":49}," Setelah mencoba satu arah, ",[25,379,381],{"class":380},"sszsK","*backtrack*",[25,383,384],{"class":49}," (reset visited).\n",[25,386,388],{"class":27,"line":387},24,[25,389,39],{"emptyLinePlaceholder":38},[25,391,393],{"class":27,"line":392},25,[25,394,157],{"class":31},[25,396,398],{"class":27,"line":397},26,[25,399,39],{"emptyLinePlaceholder":38},[25,401,403],{"class":27,"line":402},27,[25,404,405],{"class":31},"## Implementasi (C++)\n",[25,407,409],{"class":27,"line":408},28,[25,410,39],{"emptyLinePlaceholder":38},[25,412,414],{"class":27,"line":413},29,[25,415,416],{"class":49},"```cpp\n",[25,418,420],{"class":27,"line":419},30,[25,421,422],{"class":49},"#include \u003Ciostream>\n",[25,424,426],{"class":27,"line":425},31,[25,427,428],{"class":49},"#include \u003Cvector>\n",[25,430,432],{"class":27,"line":431},32,[25,433,434],{"class":49},"#include \u003Cstring>\n",[25,436,438],{"class":27,"line":437},33,[25,439,440],{"class":49},"#include \u003Calgorithm>\n",[25,442,444],{"class":27,"line":443},34,[25,445,39],{"emptyLinePlaceholder":38},[25,447,449],{"class":27,"line":448},35,[25,450,451],{"class":49},"void solve(int x, int y, std::vector\u003Cstd::vector\u003Cint>>& maze, int n,\n",[25,453,455],{"class":27,"line":454},36,[25,456,457],{"class":49},"           std::vector\u003Cstd::vector\u003Cbool>>& visited, std::string path,\n",[25,459,461],{"class":27,"line":460},37,[25,462,463],{"class":49},"           std::vector\u003Cstd::string>& result) {\n",[25,465,467],{"class":27,"line":466},38,[25,468,469],{"class":49},"    // Jika tujuan tercapai\n",[25,471,473],{"class":27,"line":472},39,[25,474,475],{"class":49},"    if (x == n - 1 && y == n - 1) {\n",[25,477,479],{"class":27,"line":478},40,[25,480,481],{"class":49},"        result.push_back(path);\n",[25,483,485],{"class":27,"line":484},41,[25,486,487],{"class":49},"        return;\n",[25,489,491],{"class":27,"line":490},42,[25,492,493],{"class":49},"    }\n",[25,495,497],{"class":27,"line":496},43,[25,498,39],{"emptyLinePlaceholder":38},[25,500,502],{"class":27,"line":501},44,[25,503,504],{"class":49},"    // Arah: D, L, R, U\n",[25,506,508],{"class":27,"line":507},45,[25,509,510],{"class":49},"    int dx[] = {1, 0, 0, -1};\n",[25,512,514],{"class":27,"line":513},46,[25,515,516],{"class":49},"    int dy[] = {0, -1, 1, 0};\n",[25,518,520],{"class":27,"line":519},47,[25,521,522],{"class":49},"    char dir[] = {'D', 'L', 'R', 'U'};\n",[25,524,526],{"class":27,"line":525},48,[25,527,39],{"emptyLinePlaceholder":38},[25,529,531],{"class":27,"line":530},49,[25,532,533],{"class":49},"    for (int i = 0; i \u003C 4; ++i) {\n",[25,535,537],{"class":27,"line":536},50,[25,538,539],{"class":49},"        int newX = x + dx[i], newY = y + dy[i];\n",[25,541,543],{"class":27,"line":542},51,[25,544,39],{"emptyLinePlaceholder":38},[25,546,548],{"class":27,"line":547},52,[25,549,550],{"class":49},"        if (newX >= 0 && newY >= 0 && newX \u003C n && newY \u003C n &&\n",[25,552,554],{"class":27,"line":553},53,[25,555,556],{"class":49},"            maze[newX][newY] == 1 && !visited[newX][newY]) {\n",[25,558,560],{"class":27,"line":559},54,[25,561,562],{"class":49},"            visited[newX][newY] = true;\n",[25,564,566],{"class":27,"line":565},55,[25,567,568],{"class":49},"            solve(newX, newY, maze, n, visited, path + dir[i], result);\n",[25,570,572],{"class":27,"line":571},56,[25,573,574],{"class":49},"            visited[newX][newY] = false; // Backtrack\n",[25,576,578],{"class":27,"line":577},57,[25,579,580],{"class":49},"        }\n",[25,582,584],{"class":27,"line":583},58,[25,585,493],{"class":49},[25,587,589],{"class":27,"line":588},59,[25,590,591],{"class":49},"}\n",[25,593,595],{"class":27,"line":594},60,[25,596,39],{"emptyLinePlaceholder":38},[25,598,600],{"class":27,"line":599},61,[25,601,602],{"class":49},"std::vector\u003Cstd::string> findPaths(std::vector\u003Cstd::vector\u003Cint>>& maze, int n) {\n",[25,604,606],{"class":27,"line":605},62,[25,607,608],{"class":49},"    std::vector\u003Cstd::string> result;\n",[25,610,612],{"class":27,"line":611},63,[25,613,614],{"class":49},"    std::vector\u003Cstd::vector\u003Cbool>> visited(n, std::vector\u003Cbool>(n, false));\n",[25,616,618],{"class":27,"line":617},64,[25,619,39],{"emptyLinePlaceholder":38},[25,621,623],{"class":27,"line":622},65,[25,624,625],{"class":49},"    if (maze[0][0] == 1) {\n",[25,627,629],{"class":27,"line":628},66,[25,630,631],{"class":49},"        visited[0][0] = true;\n",[25,633,635],{"class":27,"line":634},67,[25,636,637],{"class":49},"        solve(0, 0, maze, n, visited, \"\", result);\n",[25,639,641],{"class":27,"line":640},68,[25,642,493],{"class":49},[25,644,646],{"class":27,"line":645},69,[25,647,39],{"emptyLinePlaceholder":38},[25,649,651],{"class":27,"line":650},70,[25,652,653],{"class":49},"    std::sort(result.begin(), result.end()); // opsional: urutkan hasil\n",[25,655,657],{"class":27,"line":656},71,[25,658,659],{"class":49},"    return result;\n",[25,661,663],{"class":27,"line":662},72,[25,664,591],{"class":49},[25,666,668],{"class":27,"line":667},73,[25,669,39],{"emptyLinePlaceholder":38},[25,671,673],{"class":27,"line":672},74,[25,674,675],{"class":49},"int main() {\n",[25,677,679],{"class":27,"line":678},75,[25,680,681],{"class":49},"    std::vector\u003Cstd::vector\u003Cint>> maze = {\n",[25,683,685],{"class":27,"line":684},76,[25,686,687],{"class":49},"        {1, 0, 0, 0},\n",[25,689,691],{"class":27,"line":690},77,[25,692,693],{"class":49},"        {1, 1, 0, 1},\n",[25,695,697],{"class":27,"line":696},78,[25,698,699],{"class":49},"        {0, 1, 0, 0},\n",[25,701,703],{"class":27,"line":702},79,[25,704,705],{"class":49},"        {1, 1, 1, 1}\n",[25,707,709],{"class":27,"line":708},80,[25,710,711],{"class":49},"    };\n",[25,713,715],{"class":27,"line":714},81,[25,716,39],{"emptyLinePlaceholder":38},[25,718,720],{"class":27,"line":719},82,[25,721,722],{"class":49},"    int n = maze.size();\n",[25,724,726],{"class":27,"line":725},83,[25,727,728],{"class":49},"    std::vector\u003Cstd::string> paths = findPaths(maze, n);\n",[25,730,732],{"class":27,"line":731},84,[25,733,39],{"emptyLinePlaceholder":38},[25,735,737],{"class":27,"line":736},85,[25,738,739],{"class":49},"    std::cout \u003C\u003C \"Semua jalur yang mungkin:\\n\";\n",[25,741,743],{"class":27,"line":742},86,[25,744,745],{"class":49},"    for (const std::string& path : paths) {\n",[25,747,749],{"class":27,"line":748},87,[25,750,751],{"class":49},"        std::cout \u003C\u003C path \u003C\u003C \"\\n\";\n",[25,753,755],{"class":27,"line":754},88,[25,756,493],{"class":49},[25,758,760],{"class":27,"line":759},89,[25,761,39],{"emptyLinePlaceholder":38},[25,763,765],{"class":27,"line":764},90,[25,766,767],{"class":49},"    return 0;\n",[25,769,771],{"class":27,"line":770},91,[25,772,591],{"class":49},[774,775,777],"h2",{"id":776},"kelebihan-dan-kekurangan","Kelebihan dan Kekurangan",[779,780,782],"h3",{"id":781},"kelebihan","‚úÖ Kelebihan:",[784,785,786,795,798],"ul",{},[787,788,789,790,794],"li",{},"Menemukan ",[791,792,793],"strong",{},"semua solusi"," yang mungkin dari start ke goal.",[787,796,797],{},"Cocok untuk belajar backtracking dan logika rekursi.",[787,799,800,801,804,805,808],{},"Bisa dimodifikasi untuk menemukan ",[791,802,803],{},"jalur terpendek"," (dengan BFS) atau ",[791,806,807],{},"jumlah total jalur",".",[779,810,812],{"id":811},"kekurangan","‚ùå Kekurangan:",[784,814,815,822,825],{},[787,816,817,818,821],{},"Tidak efisien untuk maze besar: ",[791,819,820],{},"O(4^N¬≤)"," kemungkinan.",[787,823,824],{},"Tidak otomatis memilih jalur terpendek.",[787,826,827],{},"Bisa memakan banyak memori (rekursi dalam).",[774,829,831],{"id":830},"kesimpulan","Kesimpulan",[170,833,834,835,838,839,842,843,847],{},"Algoritma ",[791,836,837],{},"Rat in a Maze"," adalah latihan penting dalam pemrograman rekursif dan backtracking. Ia memperkenalkan cara berpikir ",[791,840,841],{},"eksplorasi semua kemungkinan"," dengan penelusuran sistematis dan ",[844,845,846],"em",{},"backtrack"," untuk kembali ke titik sebelumnya saat buntu.",[849,850,851],"blockquote",{},[170,852,853],{},"üß† Sangat cocok untuk mengembangkan pemahaman tentang DFS, backtracking, dan pengambilan keputusan bertahap dalam pemrograman.",[855,856,857],"style",{},"html pre.shiki code .sXvaJ, html code.shiki .sXvaJ{--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;--shiki-default:#79B8FF;--shiki-default-font-weight:bold;--shiki-light:#005CC5;--shiki-light-font-weight:bold}html pre.shiki code .s9_AW, html code.shiki .s9_AW{--shiki-dark:#E1E4E8;--shiki-dark-font-weight:bold;--shiki-default:#E1E4E8;--shiki-default-font-weight:bold;--shiki-light:#24292E;--shiki-light-font-weight:bold}html pre.shiki code .suVJd, html code.shiki .suVJd{--shiki-dark:#E1E4E8;--shiki-default:#E1E4E8;--shiki-light:#24292E}html pre.shiki code .s1uPE, html code.shiki .s1uPE{--shiki-dark:#FFAB70;--shiki-default:#FFAB70;--shiki-light:#E36209}html pre.shiki code .sAPL1, html code.shiki .sAPL1{--shiki-dark:#79B8FF;--shiki-default:#79B8FF;--shiki-light:#005CC5}html pre.shiki code .scWFE, html code.shiki .scWFE{--shiki-dark:#85E89D;--shiki-default:#85E89D;--shiki-light:#22863A}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html pre.shiki code .sszsK, html code.shiki .sszsK{--shiki-dark:#E1E4E8;--shiki-dark-font-style:italic;--shiki-default:#E1E4E8;--shiki-default-font-style:italic;--shiki-light:#24292E;--shiki-light-font-style:italic}",{"title":20,"searchDepth":35,"depth":35,"links":859},[860,864],{"id":776,"depth":35,"text":777,"children":861},[862,863],{"id":781,"depth":42,"text":782},{"id":811,"depth":42,"text":812},{"id":830,"depth":35,"text":831},null,"Pelajari bagaimana menemukan jalur keluar untuk tikus dalam labirin menggunakan backtracking.",{"script":868},[869],{"type":870,"key":871,"data-nuxt-schema-org":38,"nodes":872},"application/ld+json","schema-org-graph",[873],{"_resolver":874},"webPage","/articles/5.jpeg",{},{"props":878},{},"/en/articles/rat-in-maze",{"_resolver":874},{"title":5,"description":866},{"loc":879,"videos":883,"images":884,"lastmod":885},[],[],"2025-06-13T00:00:00.000Z","en/articles/rat-in-maze",[],"VUcpAHdEsqugs2Ac2TCDw2Kv0FPvFN9R47uFQgcymRg",1750353685944]