[{"data":1,"prerenderedAt":944},["ShallowReactive",2],{"/en/articles/rat-in-maze":3},{"id":4,"title":5,"body":6,"date":919,"description":920,"extension":921,"head":922,"image":930,"meta":931,"navigation":37,"ogImage":932,"path":934,"readingTime":919,"robots":919,"schemaOrg":935,"seo":936,"sitemap":937,"stem":941,"tags":942,"__hash__":943},"articles_en/en/articles/rat-in-maze.md","Memahami Algoritma Rat in Maze",{"type":7,"value":8,"toc":912},"minimal",[9,14,101,105,828,833,838,864,868,883,887,902,908],[10,11,13],"h1",{"id":12},"rat-in-maze","RAT IN MAZE",[15,16,21],"pre",{"className":17,"code":18,"language":19,"meta":20,"style":20},"language-markdown shiki shiki-themes github-dark github-dark github-light","# Apa itu Algoritma Rat in a Maze?\n\n**Rat in a Maze** adalah salah satu masalah klasik dalam pemrograman dan algoritma pencarian jalur. Tujuan dari algoritma ini adalah untuk menemukan **semua jalur** yang memungkinkan dari **titik awal (biasanya kiri atas)** ke **tujuan akhir (biasanya kanan bawah)** dalam sebuah labirin dua dimensi yang diwakili oleh **matriks**.\n\nSetiap sel dalam matriks bisa:\n- `1` → jalan (bisa dilewati)\n- `0` → dinding (tidak bisa dilewati)\n\n> 🐭 **Tikus** memulai dari `(0, 0)` dan ingin mencapai `(N-1, N-1)` hanya dengan bergerak ke **atas (U), bawah (D), kiri (L), atau kanan (R)** dan tidak boleh melewati sel yang sudah dilewati.\n\n---\n\n## Contoh Matriks (Maze)\n\n","markdown","",[22,23,24,32,39,45,50,56,62,68,73,79,84,90,95],"code",{"__ignoreMap":20},[25,26,29],"span",{"class":27,"line":28},"line",1,[25,30,31],{},"# Apa itu Algoritma Rat in a Maze?\n",[25,33,35],{"class":27,"line":34},2,[25,36,38],{"emptyLinePlaceholder":37},true,"\n",[25,40,42],{"class":27,"line":41},3,[25,43,44],{},"**Rat in a Maze** adalah salah satu masalah klasik dalam pemrograman dan algoritma pencarian jalur. Tujuan dari algoritma ini adalah untuk menemukan **semua jalur** yang memungkinkan dari **titik awal (biasanya kiri atas)** ke **tujuan akhir (biasanya kanan bawah)** dalam sebuah labirin dua dimensi yang diwakili oleh **matriks**.\n",[25,46,48],{"class":27,"line":47},4,[25,49,38],{"emptyLinePlaceholder":37},[25,51,53],{"class":27,"line":52},5,[25,54,55],{},"Setiap sel dalam matriks bisa:\n",[25,57,59],{"class":27,"line":58},6,[25,60,61],{},"- `1` → jalan (bisa dilewati)\n",[25,63,65],{"class":27,"line":64},7,[25,66,67],{},"- `0` → dinding (tidak bisa dilewati)\n",[25,69,71],{"class":27,"line":70},8,[25,72,38],{"emptyLinePlaceholder":37},[25,74,76],{"class":27,"line":75},9,[25,77,78],{},"> 🐭 **Tikus** memulai dari `(0, 0)` dan ingin mencapai `(N-1, N-1)` hanya dengan bergerak ke **atas (U), bawah (D), kiri (L), atau kanan (R)** dan tidak boleh melewati sel yang sudah dilewati.\n",[25,80,82],{"class":27,"line":81},10,[25,83,38],{"emptyLinePlaceholder":37},[25,85,87],{"class":27,"line":86},11,[25,88,89],{},"---\n",[25,91,93],{"class":27,"line":92},12,[25,94,38],{"emptyLinePlaceholder":37},[25,96,98],{"class":27,"line":97},13,[25,99,100],{},"## Contoh Matriks (Maze)\n",[102,103,104],"p",{},"maze = [ [1, 0, 0, 0], [1, 1, 0, 1], [0, 1, 0, 0], [1, 1, 1, 1] ]",[15,106,110],{"className":107,"code":108,"language":109,"meta":20,"style":20},"language-js shiki shiki-themes github-dark github-dark github-light","\n**Tujuan**: Temukan semua jalur dari `(0, 0)` ke `(3, 3)`. Dalam contoh ini, salah satu solusi bisa berupa jalur `DDRDRR`.\n\n---\n\n## Strategi Penyelesaian\n\n- Gunakan algoritma **Backtracking** untuk menjelajahi semua kemungkinan jalur.\n- Hanya lanjutkan ke sel jika:\n  - Berada dalam batas matriks.\n  - Nilainya `1` (jalan).\n  - Belum dikunjungi.\n- Simpan **jalur saat ini** sebagai string (misalnya \"DDR\").\n\n---\n\n## Langkah-langkah Algoritma\n\n1. Buat matriks `visited[][]` untuk menandai sel yang telah dikunjungi.\n2. Buat fungsi `solveMaze(x, y, path)`:\n   - Jika mencapai tujuan `(N-1, N-1)`, simpan `path`.\n   - Lanjutkan ke arah: Down (D), Left (L), Right (R), Up (U).\n   - Setelah mencoba satu arah, *backtrack* (reset visited).\n\n---\n\n## Implementasi (C++)\n\n```cpp\n#include \u003Ciostream>\n#include \u003Cvector>\n#include \u003Cstring>\n#include \u003Calgorithm>\n\nvoid solve(int x, int y, std::vector\u003Cstd::vector\u003Cint>>& maze, int n,\n           std::vector\u003Cstd::vector\u003Cbool>>& visited, std::string path,\n           std::vector\u003Cstd::string>& result) {\n    // Jika tujuan tercapai\n    if (x == n - 1 && y == n - 1) {\n        result.push_back(path);\n        return;\n    }\n\n    // Arah: D, L, R, U\n    int dx[] = {1, 0, 0, -1};\n    int dy[] = {0, -1, 1, 0};\n    char dir[] = {'D', 'L', 'R', 'U'};\n\n    for (int i = 0; i \u003C 4; ++i) {\n        int newX = x + dx[i], newY = y + dy[i];\n\n        if (newX >= 0 && newY >= 0 && newX \u003C n && newY \u003C n &&\n            maze[newX][newY] == 1 && !visited[newX][newY]) {\n            visited[newX][newY] = true;\n            solve(newX, newY, maze, n, visited, path + dir[i], result);\n            visited[newX][newY] = false; // Backtrack\n        }\n    }\n}\n\nstd::vector\u003Cstd::string> findPaths(std::vector\u003Cstd::vector\u003Cint>>& maze, int n) {\n    std::vector\u003Cstd::string> result;\n    std::vector\u003Cstd::vector\u003Cbool>> visited(n, std::vector\u003Cbool>(n, false));\n\n    if (maze[0][0] == 1) {\n        visited[0][0] = true;\n        solve(0, 0, maze, n, visited, \"\", result);\n    }\n\n    std::sort(result.begin(), result.end()); // opsional: urutkan hasil\n    return result;\n}\n\nint main() {\n    std::vector\u003Cstd::vector\u003Cint>> maze = {\n        {1, 0, 0, 0},\n        {1, 1, 0, 1},\n        {0, 1, 0, 0},\n        {1, 1, 1, 1}\n    };\n\n    int n = maze.size();\n    std::vector\u003Cstd::string> paths = findPaths(maze, n);\n\n    std::cout \u003C\u003C \"Semua jalur yang mungkin:\\n\";\n    for (const std::string& path : paths) {\n        std::cout \u003C\u003C path \u003C\u003C \"\\n\";\n    }\n\n    return 0;\n}\n","js",[22,111,112,116,150,154,158,162,167,171,189,203,211,224,231,260,265,270,275,286,291,307,321,341,397,416,421,426,431,451,456,462,468,474,480,486,491,497,503,509,515,521,527,533,539,544,550,556,562,568,573,579,585,590,596,602,608,614,620,626,631,637,642,648,654,660,665,671,677,683,688,693,699,705,710,715,721,727,733,739,745,751,757,762,768,774,779,791,797,807,812,817,823],{"__ignoreMap":20},[25,113,114],{"class":27,"line":28},[25,115,38],{"emptyLinePlaceholder":37},[25,117,118,122,126,128,131,135,138,141,144,147],{"class":27,"line":34},[25,119,121],{"class":120},"sEiGg","**",[25,123,125],{"class":124},"suVJd","Tujuan",[25,127,121],{"class":120},[25,129,130],{"class":124},": Temukan semua jalur dari ",[25,132,134],{"class":133},"sYTnl","`(0, 0)`",[25,136,137],{"class":124}," ke ",[25,139,140],{"class":133},"`(3, 3)`",[25,142,143],{"class":124},". Dalam contoh ini, salah satu solusi bisa berupa jalur ",[25,145,146],{"class":133},"`DDRDRR`",[25,148,149],{"class":124},".\n",[25,151,152],{"class":27,"line":41},[25,153,38],{"emptyLinePlaceholder":37},[25,155,156],{"class":27,"line":47},[25,157,89],{"class":120},[25,159,160],{"class":27,"line":52},[25,161,38],{"emptyLinePlaceholder":37},[25,163,164],{"class":27,"line":58},[25,165,166],{"class":124},"## Strategi Penyelesaian\n",[25,168,169],{"class":27,"line":64},[25,170,38],{"emptyLinePlaceholder":37},[25,172,173,176,179,181,184,186],{"class":27,"line":70},[25,174,175],{"class":120},"-",[25,177,178],{"class":124}," Gunakan algoritma ",[25,180,121],{"class":120},[25,182,183],{"class":124},"Backtracking",[25,185,121],{"class":120},[25,187,188],{"class":124}," untuk menjelajahi semua kemungkinan jalur.\n",[25,190,191,193,196,200],{"class":27,"line":75},[25,192,175],{"class":120},[25,194,195],{"class":124}," Hanya lanjutkan ke sel ",[25,197,199],{"class":198},"s9E-l","jika",[25,201,202],{"class":124},":\n",[25,204,205,208],{"class":27,"line":81},[25,206,207],{"class":120},"  -",[25,209,210],{"class":124}," Berada dalam batas matriks.\n",[25,212,213,215,218,221],{"class":27,"line":86},[25,214,207],{"class":120},[25,216,217],{"class":124}," Nilainya ",[25,219,220],{"class":133},"`1`",[25,222,223],{"class":124}," (jalan).\n",[25,225,226,228],{"class":27,"line":92},[25,227,207],{"class":120},[25,229,230],{"class":124}," Belum dikunjungi.\n",[25,232,233,235,238,240,243,245,248,251,254,257],{"class":27,"line":97},[25,234,175],{"class":120},[25,236,237],{"class":124}," Simpan ",[25,239,121],{"class":120},[25,241,242],{"class":124},"jalur saat ini",[25,244,121],{"class":120},[25,246,247],{"class":124}," sebagai ",[25,249,250],{"class":198},"string",[25,252,253],{"class":124}," (misalnya ",[25,255,256],{"class":133},"\"DDR\"",[25,258,259],{"class":124},").\n",[25,261,263],{"class":27,"line":262},14,[25,264,38],{"emptyLinePlaceholder":37},[25,266,268],{"class":27,"line":267},15,[25,269,89],{"class":120},[25,271,273],{"class":27,"line":272},16,[25,274,38],{"emptyLinePlaceholder":37},[25,276,278,281,283],{"class":27,"line":277},17,[25,279,280],{"class":124},"## Langkah",[25,282,175],{"class":120},[25,284,285],{"class":124},"langkah Algoritma\n",[25,287,289],{"class":27,"line":288},18,[25,290,38],{"emptyLinePlaceholder":37},[25,292,294,298,301,304],{"class":27,"line":293},19,[25,295,297],{"class":296},"sAPL1","1.",[25,299,300],{"class":124}," Buat matriks ",[25,302,303],{"class":133},"`visited[][]`",[25,305,306],{"class":124}," untuk menandai sel yang telah dikunjungi.\n",[25,308,310,313,316,319],{"class":27,"line":309},20,[25,311,312],{"class":296},"2.",[25,314,315],{"class":124}," Buat fungsi ",[25,317,318],{"class":133},"`solveMaze(x, y, path)`",[25,320,202],{"class":124},[25,322,324,327,330,333,336,339],{"class":27,"line":323},21,[25,325,326],{"class":120},"   -",[25,328,329],{"class":124}," Jika mencapai tujuan ",[25,331,332],{"class":133},"`(N-1, N-1)`",[25,334,335],{"class":124},", simpan ",[25,337,338],{"class":133},"`path`",[25,340,149],{"class":124},[25,342,344,346,349,352,355,358,361,364,367,370,372,375,377,380,382,385,387,390,392,395],{"class":27,"line":343},22,[25,345,326],{"class":120},[25,347,348],{"class":124}," Lanjutkan ke ",[25,350,351],{"class":198},"arah",[25,353,354],{"class":124},": ",[25,356,357],{"class":198},"Down",[25,359,360],{"class":124}," (",[25,362,363],{"class":296},"D",[25,365,366],{"class":124},"), ",[25,368,369],{"class":198},"Left",[25,371,360],{"class":124},[25,373,374],{"class":296},"L",[25,376,366],{"class":124},[25,378,379],{"class":198},"Right",[25,381,360],{"class":124},[25,383,384],{"class":296},"R",[25,386,366],{"class":124},[25,388,389],{"class":198},"Up",[25,391,360],{"class":124},[25,393,394],{"class":296},"U",[25,396,259],{"class":124},[25,398,400,402,405,408,411,413],{"class":27,"line":399},23,[25,401,326],{"class":120},[25,403,404],{"class":124}," Setelah mencoba satu arah, ",[25,406,407],{"class":120},"*",[25,409,410],{"class":124},"backtrack",[25,412,407],{"class":120},[25,414,415],{"class":124}," (reset visited).\n",[25,417,419],{"class":27,"line":418},24,[25,420,38],{"emptyLinePlaceholder":37},[25,422,424],{"class":27,"line":423},25,[25,425,89],{"class":120},[25,427,429],{"class":27,"line":428},26,[25,430,38],{"emptyLinePlaceholder":37},[25,432,434,437,440,442,445,448],{"class":27,"line":433},27,[25,435,436],{"class":124},"## ",[25,438,439],{"class":198},"Implementasi",[25,441,360],{"class":124},[25,443,444],{"class":296},"C",[25,446,447],{"class":120},"++",[25,449,450],{"class":124},")\n",[25,452,454],{"class":27,"line":453},28,[25,455,38],{"emptyLinePlaceholder":37},[25,457,459],{"class":27,"line":458},29,[25,460,461],{"class":133},"```cpp\n",[25,463,465],{"class":27,"line":464},30,[25,466,467],{"class":133},"#include \u003Ciostream>\n",[25,469,471],{"class":27,"line":470},31,[25,472,473],{"class":133},"#include \u003Cvector>\n",[25,475,477],{"class":27,"line":476},32,[25,478,479],{"class":133},"#include \u003Cstring>\n",[25,481,483],{"class":27,"line":482},33,[25,484,485],{"class":133},"#include \u003Calgorithm>\n",[25,487,489],{"class":27,"line":488},34,[25,490,38],{"emptyLinePlaceholder":37},[25,492,494],{"class":27,"line":493},35,[25,495,496],{"class":133},"void solve(int x, int y, std::vector\u003Cstd::vector\u003Cint>>& maze, int n,\n",[25,498,500],{"class":27,"line":499},36,[25,501,502],{"class":133},"           std::vector\u003Cstd::vector\u003Cbool>>& visited, std::string path,\n",[25,504,506],{"class":27,"line":505},37,[25,507,508],{"class":133},"           std::vector\u003Cstd::string>& result) {\n",[25,510,512],{"class":27,"line":511},38,[25,513,514],{"class":133},"    // Jika tujuan tercapai\n",[25,516,518],{"class":27,"line":517},39,[25,519,520],{"class":133},"    if (x == n - 1 && y == n - 1) {\n",[25,522,524],{"class":27,"line":523},40,[25,525,526],{"class":133},"        result.push_back(path);\n",[25,528,530],{"class":27,"line":529},41,[25,531,532],{"class":133},"        return;\n",[25,534,536],{"class":27,"line":535},42,[25,537,538],{"class":133},"    }\n",[25,540,542],{"class":27,"line":541},43,[25,543,38],{"emptyLinePlaceholder":37},[25,545,547],{"class":27,"line":546},44,[25,548,549],{"class":133},"    // Arah: D, L, R, U\n",[25,551,553],{"class":27,"line":552},45,[25,554,555],{"class":133},"    int dx[] = {1, 0, 0, -1};\n",[25,557,559],{"class":27,"line":558},46,[25,560,561],{"class":133},"    int dy[] = {0, -1, 1, 0};\n",[25,563,565],{"class":27,"line":564},47,[25,566,567],{"class":133},"    char dir[] = {'D', 'L', 'R', 'U'};\n",[25,569,571],{"class":27,"line":570},48,[25,572,38],{"emptyLinePlaceholder":37},[25,574,576],{"class":27,"line":575},49,[25,577,578],{"class":133},"    for (int i = 0; i \u003C 4; ++i) {\n",[25,580,582],{"class":27,"line":581},50,[25,583,584],{"class":133},"        int newX = x + dx[i], newY = y + dy[i];\n",[25,586,588],{"class":27,"line":587},51,[25,589,38],{"emptyLinePlaceholder":37},[25,591,593],{"class":27,"line":592},52,[25,594,595],{"class":133},"        if (newX >= 0 && newY >= 0 && newX \u003C n && newY \u003C n &&\n",[25,597,599],{"class":27,"line":598},53,[25,600,601],{"class":133},"            maze[newX][newY] == 1 && !visited[newX][newY]) {\n",[25,603,605],{"class":27,"line":604},54,[25,606,607],{"class":133},"            visited[newX][newY] = true;\n",[25,609,611],{"class":27,"line":610},55,[25,612,613],{"class":133},"            solve(newX, newY, maze, n, visited, path + dir[i], result);\n",[25,615,617],{"class":27,"line":616},56,[25,618,619],{"class":133},"            visited[newX][newY] = false; // Backtrack\n",[25,621,623],{"class":27,"line":622},57,[25,624,625],{"class":133},"        }\n",[25,627,629],{"class":27,"line":628},58,[25,630,538],{"class":133},[25,632,634],{"class":27,"line":633},59,[25,635,636],{"class":133},"}\n",[25,638,640],{"class":27,"line":639},60,[25,641,38],{"emptyLinePlaceholder":37},[25,643,645],{"class":27,"line":644},61,[25,646,647],{"class":133},"std::vector\u003Cstd::string> findPaths(std::vector\u003Cstd::vector\u003Cint>>& maze, int n) {\n",[25,649,651],{"class":27,"line":650},62,[25,652,653],{"class":133},"    std::vector\u003Cstd::string> result;\n",[25,655,657],{"class":27,"line":656},63,[25,658,659],{"class":133},"    std::vector\u003Cstd::vector\u003Cbool>> visited(n, std::vector\u003Cbool>(n, false));\n",[25,661,663],{"class":27,"line":662},64,[25,664,38],{"emptyLinePlaceholder":37},[25,666,668],{"class":27,"line":667},65,[25,669,670],{"class":133},"    if (maze[0][0] == 1) {\n",[25,672,674],{"class":27,"line":673},66,[25,675,676],{"class":133},"        visited[0][0] = true;\n",[25,678,680],{"class":27,"line":679},67,[25,681,682],{"class":133},"        solve(0, 0, maze, n, visited, \"\", result);\n",[25,684,686],{"class":27,"line":685},68,[25,687,538],{"class":133},[25,689,691],{"class":27,"line":690},69,[25,692,38],{"emptyLinePlaceholder":37},[25,694,696],{"class":27,"line":695},70,[25,697,698],{"class":133},"    std::sort(result.begin(), result.end()); // opsional: urutkan hasil\n",[25,700,702],{"class":27,"line":701},71,[25,703,704],{"class":133},"    return result;\n",[25,706,708],{"class":27,"line":707},72,[25,709,636],{"class":133},[25,711,713],{"class":27,"line":712},73,[25,714,38],{"emptyLinePlaceholder":37},[25,716,718],{"class":27,"line":717},74,[25,719,720],{"class":133},"int main() {\n",[25,722,724],{"class":27,"line":723},75,[25,725,726],{"class":133},"    std::vector\u003Cstd::vector\u003Cint>> maze = {\n",[25,728,730],{"class":27,"line":729},76,[25,731,732],{"class":133},"        {1, 0, 0, 0},\n",[25,734,736],{"class":27,"line":735},77,[25,737,738],{"class":133},"        {1, 1, 0, 1},\n",[25,740,742],{"class":27,"line":741},78,[25,743,744],{"class":133},"        {0, 1, 0, 0},\n",[25,746,748],{"class":27,"line":747},79,[25,749,750],{"class":133},"        {1, 1, 1, 1}\n",[25,752,754],{"class":27,"line":753},80,[25,755,756],{"class":133},"    };\n",[25,758,760],{"class":27,"line":759},81,[25,761,38],{"emptyLinePlaceholder":37},[25,763,765],{"class":27,"line":764},82,[25,766,767],{"class":133},"    int n = maze.size();\n",[25,769,771],{"class":27,"line":770},83,[25,772,773],{"class":133},"    std::vector\u003Cstd::string> paths = findPaths(maze, n);\n",[25,775,777],{"class":27,"line":776},84,[25,778,38],{"emptyLinePlaceholder":37},[25,780,782,785,788],{"class":27,"line":781},85,[25,783,784],{"class":133},"    std::cout \u003C\u003C \"Semua jalur yang mungkin:",[25,786,787],{"class":296},"\\n",[25,789,790],{"class":133},"\";\n",[25,792,794],{"class":27,"line":793},86,[25,795,796],{"class":133},"    for (const std::string& path : paths) {\n",[25,798,800,803,805],{"class":27,"line":799},87,[25,801,802],{"class":133},"        std::cout \u003C\u003C path \u003C\u003C \"",[25,804,787],{"class":296},[25,806,790],{"class":133},[25,808,810],{"class":27,"line":809},88,[25,811,538],{"class":133},[25,813,815],{"class":27,"line":814},89,[25,816,38],{"emptyLinePlaceholder":37},[25,818,820],{"class":27,"line":819},90,[25,821,822],{"class":133},"    return 0;\n",[25,824,826],{"class":27,"line":825},91,[25,827,636],{"class":133},[829,830,832],"h2",{"id":831},"kelebihan-dan-kekurangan","Kelebihan dan Kekurangan",[834,835,837],"h3",{"id":836},"kelebihan","✅ Kelebihan:",[839,840,841,850,853],"ul",{},[842,843,844,845,849],"li",{},"Menemukan ",[846,847,848],"strong",{},"semua solusi"," yang mungkin dari start ke goal.",[842,851,852],{},"Cocok untuk belajar backtracking dan logika rekursi.",[842,854,855,856,859,860,863],{},"Bisa dimodifikasi untuk menemukan ",[846,857,858],{},"jalur terpendek"," (dengan BFS) atau ",[846,861,862],{},"jumlah total jalur",".",[834,865,867],{"id":866},"kekurangan","❌ Kekurangan:",[839,869,870,877,880],{},[842,871,872,873,876],{},"Tidak efisien untuk maze besar: ",[846,874,875],{},"O(4^N²)"," kemungkinan.",[842,878,879],{},"Tidak otomatis memilih jalur terpendek.",[842,881,882],{},"Bisa memakan banyak memori (rekursi dalam).",[829,884,886],{"id":885},"kesimpulan","Kesimpulan",[102,888,889,890,893,894,897,898,901],{},"Algoritma ",[846,891,892],{},"Rat in a Maze"," adalah latihan penting dalam pemrograman rekursif dan backtracking. Ia memperkenalkan cara berpikir ",[846,895,896],{},"eksplorasi semua kemungkinan"," dengan penelusuran sistematis dan ",[899,900,410],"em",{}," untuk kembali ke titik sebelumnya saat buntu.",[903,904,905],"blockquote",{},[102,906,907],{},"🧠 Sangat cocok untuk mengembangkan pemahaman tentang DFS, backtracking, dan pengambilan keputusan bertahap dalam pemrograman.",[909,910,911],"style",{},"html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html pre.shiki code .sEiGg, html code.shiki .sEiGg{--shiki-dark:#F97583;--shiki-default:#F97583;--shiki-light:#D73A49}html pre.shiki code .suVJd, html code.shiki .suVJd{--shiki-dark:#E1E4E8;--shiki-default:#E1E4E8;--shiki-light:#24292E}html pre.shiki code .sYTnl, html code.shiki .sYTnl{--shiki-dark:#9ECBFF;--shiki-default:#9ECBFF;--shiki-light:#032F62}html pre.shiki code .s9E-l, html code.shiki .s9E-l{--shiki-dark:#B392F0;--shiki-default:#B392F0;--shiki-light:#6F42C1}html pre.shiki code .sAPL1, html code.shiki .sAPL1{--shiki-dark:#79B8FF;--shiki-default:#79B8FF;--shiki-light:#005CC5}",{"title":20,"searchDepth":34,"depth":34,"links":913},[914,918],{"id":831,"depth":34,"text":832,"children":915},[916,917],{"id":836,"depth":41,"text":837},{"id":866,"depth":41,"text":867},{"id":885,"depth":34,"text":886},null,"Pelajari bagaimana menemukan jalur keluar untuk tikus dalam labirin menggunakan backtracking.","md",{"script":923},[924],{"type":925,"key":926,"data-nuxt-schema-org":37,"nodes":927},"application/ld+json","schema-org-graph",[928],{"_resolver":929},"webPage","/articles/5.jpeg",{},{"props":933},{},"/en/articles/rat-in-maze",{"_resolver":929},{"title":5,"description":920},{"loc":934,"videos":938,"images":939,"lastmod":940},[],[],"2025-06-13T00:00:00.000Z","en/articles/rat-in-maze",[],"I3MTz4mFXW1XUP_Ddzqrr3Tzsuw7N5ZAsZXhzgroz7U",1750332525585]