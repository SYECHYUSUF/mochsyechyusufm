[{"data":1,"prerenderedAt":1073},["ShallowReactive",2],{"/en/articles/khans-algorithm":3},{"id":4,"title":5,"body":6,"date":1049,"description":1050,"extension":19,"head":1051,"image":1059,"meta":1060,"navigation":38,"ogImage":1061,"path":1063,"readingTime":1049,"robots":1049,"schemaOrg":1064,"seo":1065,"sitemap":1066,"stem":1070,"tags":1071,"__hash__":1072},"articles_en/en/articles/khans-algorithm.md","Memahami Algoritma Kahn",{"type":7,"value":8,"toc":1042},"minimal",[9,14,517,521,968,973,978,999,1003,1021,1025,1032,1038],[10,11,13],"h1",{"id":12},"khans-algorithm","KHANS' Algorithm",[15,16,21],"pre",{"className":17,"code":18,"language":19,"meta":20,"style":20},"language-md shiki shiki-themes github-dark github-dark github-light","# Apa itu Algoritma Kahn?\n\n**Algoritma Kahn** adalah salah satu dari dua algoritma utama yang digunakan untuk melakukan **pengurutan topologis** (*topological sort*) pada sebuah **Grafik Asiklik Terarah** (*Directed Acyclic Graph - DAG*). Pengurutan topologis adalah susunan linier dari node-node sedemikian rupa sehingga untuk setiap sisi terarah (u ‚Üí v), node `u` selalu muncul sebelum node `v`.\n\n> ‚ö†Ô∏è Pengurutan topologis hanya bisa dilakukan jika graf tersebut adalah DAG (tidak mengandung siklus).\n\n## Kegunaan Algoritma Kahn\n\nAlgoritma ini sangat berguna dalam berbagai skenario yang melibatkan **ketergantungan antar tugas**, seperti:\n\n- üìã **Perencanaan Tugas**: Menyusun urutan pekerjaan (misalnya, fondasi rumah harus selesai sebelum membangun dinding).\n- üì¶ **Manajemen Dependensi Paket**: Menentukan urutan instalasi paket perangkat lunak.\n- üéì **Penyelesaian Kursus**: Menentukan urutan mata kuliah berdasarkan prasyarat.\n- üõ†Ô∏è **Kompilasi Kode**: Menentukan urutan file sumber yang harus dikompilasi.\n\n---\n\n## Konsep Kunci: In-degree\n\n**In-degree** (derajat masuk) dari sebuah node adalah jumlah sisi yang **masuk** ke node tersebut.\n\n**Contoh**:\nJika ada sisi `A ‚Üí B` dan `C ‚Üí B`, maka **in-degree B = 2**.\n\nNode dengan **in-degree 0** tidak memiliki prasyarat, sehingga bisa menjadi **titik awal** dalam urutan topologis.\n\n---\n\n## Cara Kerja Algoritma Kahn\n\n1. **Inisialisasi**:\n   - Hitung in-degree untuk setiap node.\n   - Masukkan semua node dengan in-degree 0 ke dalam queue.\n\n2. **Proses Iteratif**:\n   - Selama queue tidak kosong:\n     - Ambil (dequeue) node dari queue, tambahkan ke hasil.\n     - Kurangi in-degree semua tetangga-nya.\n     - Jika in-degree tetangga menjadi 0, tambahkan ke queue.\n\n3. **Verifikasi (Opsional tapi Penting)**:\n   - Jika jumlah node di hasil ‚â† total node, maka graf memiliki **siklus**.\n\n---\n\n## Contoh Masalah: Urutan Mata Kuliah\n\n**Mata Kuliah dan Prasyarat**:\n\n- A: -\n- B: A\n- C: A\n- D: B, C\n- E: D\n\n**Grafik Terarah**:\n","md","",[22,23,24,33,40,88,93,100,105,111,116,128,133,149,163,177,191,196,202,207,213,218,233,238,247,270,275,293,298,303,308,314,319,330,339,347,352,363,371,380,388,396,401,412,425,430,435,440,446,451,459,464,472,480,488,496,504,509],"code",{"__ignoreMap":20},[25,26,29],"span",{"class":27,"line":28},"line",1,[25,30,32],{"class":31},"sXvaJ","# Apa itu Algoritma Kahn?\n",[25,34,36],{"class":27,"line":35},2,[25,37,39],{"emptyLinePlaceholder":38},true,"\n",[25,41,43,47,51,54,57,61,64,67,69,72,75,79,82,85],{"class":27,"line":42},3,[25,44,46],{"class":45},"s9_AW","**Algoritma Kahn**",[25,48,50],{"class":49},"suVJd"," adalah salah satu dari dua algoritma utama yang digunakan untuk melakukan ",[25,52,53],{"class":45},"**pengurutan topologis**",[25,55,56],{"class":49}," (",[25,58,60],{"class":59},"sszsK","*topological sort*",[25,62,63],{"class":49},") pada sebuah ",[25,65,66],{"class":45},"**Grafik Asiklik Terarah**",[25,68,56],{"class":49},[25,70,71],{"class":59},"*Directed Acyclic Graph - DAG*",[25,73,74],{"class":49},"). Pengurutan topologis adalah susunan linier dari node-node sedemikian rupa sehingga untuk setiap sisi terarah (u ‚Üí v), node ",[25,76,78],{"class":77},"sAPL1","`u`",[25,80,81],{"class":49}," selalu muncul sebelum node ",[25,83,84],{"class":77},"`v`",[25,86,87],{"class":49},".\n",[25,89,91],{"class":27,"line":90},4,[25,92,39],{"emptyLinePlaceholder":38},[25,94,96],{"class":27,"line":95},5,[25,97,99],{"class":98},"scWFE","> ‚ö†Ô∏è Pengurutan topologis hanya bisa dilakukan jika graf tersebut adalah DAG (tidak mengandung siklus).\n",[25,101,103],{"class":27,"line":102},6,[25,104,39],{"emptyLinePlaceholder":38},[25,106,108],{"class":27,"line":107},7,[25,109,110],{"class":31},"## Kegunaan Algoritma Kahn\n",[25,112,114],{"class":27,"line":113},8,[25,115,39],{"emptyLinePlaceholder":38},[25,117,119,122,125],{"class":27,"line":118},9,[25,120,121],{"class":49},"Algoritma ini sangat berguna dalam berbagai skenario yang melibatkan ",[25,123,124],{"class":45},"**ketergantungan antar tugas**",[25,126,127],{"class":49},", seperti:\n",[25,129,131],{"class":27,"line":130},10,[25,132,39],{"emptyLinePlaceholder":38},[25,134,136,140,143,146],{"class":27,"line":135},11,[25,137,139],{"class":138},"s1uPE","-",[25,141,142],{"class":49}," üìã ",[25,144,145],{"class":45},"**Perencanaan Tugas**",[25,147,148],{"class":49},": Menyusun urutan pekerjaan (misalnya, fondasi rumah harus selesai sebelum membangun dinding).\n",[25,150,152,154,157,160],{"class":27,"line":151},12,[25,153,139],{"class":138},[25,155,156],{"class":49}," üì¶ ",[25,158,159],{"class":45},"**Manajemen Dependensi Paket**",[25,161,162],{"class":49},": Menentukan urutan instalasi paket perangkat lunak.\n",[25,164,166,168,171,174],{"class":27,"line":165},13,[25,167,139],{"class":138},[25,169,170],{"class":49}," üéì ",[25,172,173],{"class":45},"**Penyelesaian Kursus**",[25,175,176],{"class":49},": Menentukan urutan mata kuliah berdasarkan prasyarat.\n",[25,178,180,182,185,188],{"class":27,"line":179},14,[25,181,139],{"class":138},[25,183,184],{"class":49}," üõ†Ô∏è ",[25,186,187],{"class":45},"**Kompilasi Kode**",[25,189,190],{"class":49},": Menentukan urutan file sumber yang harus dikompilasi.\n",[25,192,194],{"class":27,"line":193},15,[25,195,39],{"emptyLinePlaceholder":38},[25,197,199],{"class":27,"line":198},16,[25,200,201],{"class":31},"---\n",[25,203,205],{"class":27,"line":204},17,[25,206,39],{"emptyLinePlaceholder":38},[25,208,210],{"class":27,"line":209},18,[25,211,212],{"class":31},"## Konsep Kunci: In-degree\n",[25,214,216],{"class":27,"line":215},19,[25,217,39],{"emptyLinePlaceholder":38},[25,219,221,224,227,230],{"class":27,"line":220},20,[25,222,223],{"class":45},"**In-degree**",[25,225,226],{"class":49}," (derajat masuk) dari sebuah node adalah jumlah sisi yang ",[25,228,229],{"class":45},"**masuk**",[25,231,232],{"class":49}," ke node tersebut.\n",[25,234,236],{"class":27,"line":235},21,[25,237,39],{"emptyLinePlaceholder":38},[25,239,241,244],{"class":27,"line":240},22,[25,242,243],{"class":45},"**Contoh**",[25,245,246],{"class":49},":\n",[25,248,250,253,256,259,262,265,268],{"class":27,"line":249},23,[25,251,252],{"class":49},"Jika ada sisi ",[25,254,255],{"class":77},"`A ‚Üí B`",[25,257,258],{"class":49}," dan ",[25,260,261],{"class":77},"`C ‚Üí B`",[25,263,264],{"class":49},", maka ",[25,266,267],{"class":45},"**in-degree B = 2**",[25,269,87],{"class":49},[25,271,273],{"class":27,"line":272},24,[25,274,39],{"emptyLinePlaceholder":38},[25,276,278,281,284,287,290],{"class":27,"line":277},25,[25,279,280],{"class":49},"Node dengan ",[25,282,283],{"class":45},"**in-degree 0**",[25,285,286],{"class":49}," tidak memiliki prasyarat, sehingga bisa menjadi ",[25,288,289],{"class":45},"**titik awal**",[25,291,292],{"class":49}," dalam urutan topologis.\n",[25,294,296],{"class":27,"line":295},26,[25,297,39],{"emptyLinePlaceholder":38},[25,299,301],{"class":27,"line":300},27,[25,302,201],{"class":31},[25,304,306],{"class":27,"line":305},28,[25,307,39],{"emptyLinePlaceholder":38},[25,309,311],{"class":27,"line":310},29,[25,312,313],{"class":31},"## Cara Kerja Algoritma Kahn\n",[25,315,317],{"class":27,"line":316},30,[25,318,39],{"emptyLinePlaceholder":38},[25,320,322,325,328],{"class":27,"line":321},31,[25,323,324],{"class":138},"1.",[25,326,327],{"class":45}," **Inisialisasi**",[25,329,246],{"class":49},[25,331,333,336],{"class":27,"line":332},32,[25,334,335],{"class":138},"   -",[25,337,338],{"class":49}," Hitung in-degree untuk setiap node.\n",[25,340,342,344],{"class":27,"line":341},33,[25,343,335],{"class":138},[25,345,346],{"class":49}," Masukkan semua node dengan in-degree 0 ke dalam queue.\n",[25,348,350],{"class":27,"line":349},34,[25,351,39],{"emptyLinePlaceholder":38},[25,353,355,358,361],{"class":27,"line":354},35,[25,356,357],{"class":138},"2.",[25,359,360],{"class":45}," **Proses Iteratif**",[25,362,246],{"class":49},[25,364,366,368],{"class":27,"line":365},36,[25,367,335],{"class":138},[25,369,370],{"class":49}," Selama queue tidak kosong:\n",[25,372,374,377],{"class":27,"line":373},37,[25,375,376],{"class":138},"     -",[25,378,379],{"class":49}," Ambil (dequeue) node dari queue, tambahkan ke hasil.\n",[25,381,383,385],{"class":27,"line":382},38,[25,384,376],{"class":138},[25,386,387],{"class":49}," Kurangi in-degree semua tetangga-nya.\n",[25,389,391,393],{"class":27,"line":390},39,[25,392,376],{"class":138},[25,394,395],{"class":49}," Jika in-degree tetangga menjadi 0, tambahkan ke queue.\n",[25,397,399],{"class":27,"line":398},40,[25,400,39],{"emptyLinePlaceholder":38},[25,402,404,407,410],{"class":27,"line":403},41,[25,405,406],{"class":138},"3.",[25,408,409],{"class":45}," **Verifikasi (Opsional tapi Penting)**",[25,411,246],{"class":49},[25,413,415,417,420,423],{"class":27,"line":414},42,[25,416,335],{"class":138},[25,418,419],{"class":49}," Jika jumlah node di hasil ‚â† total node, maka graf memiliki ",[25,421,422],{"class":45},"**siklus**",[25,424,87],{"class":49},[25,426,428],{"class":27,"line":427},43,[25,429,39],{"emptyLinePlaceholder":38},[25,431,433],{"class":27,"line":432},44,[25,434,201],{"class":31},[25,436,438],{"class":27,"line":437},45,[25,439,39],{"emptyLinePlaceholder":38},[25,441,443],{"class":27,"line":442},46,[25,444,445],{"class":31},"## Contoh Masalah: Urutan Mata Kuliah\n",[25,447,449],{"class":27,"line":448},47,[25,450,39],{"emptyLinePlaceholder":38},[25,452,454,457],{"class":27,"line":453},48,[25,455,456],{"class":45},"**Mata Kuliah dan Prasyarat**",[25,458,246],{"class":49},[25,460,462],{"class":27,"line":461},49,[25,463,39],{"emptyLinePlaceholder":38},[25,465,467,469],{"class":27,"line":466},50,[25,468,139],{"class":138},[25,470,471],{"class":49}," A: -\n",[25,473,475,477],{"class":27,"line":474},51,[25,476,139],{"class":138},[25,478,479],{"class":49}," B: A\n",[25,481,483,485],{"class":27,"line":482},52,[25,484,139],{"class":138},[25,486,487],{"class":49}," C: A\n",[25,489,491,493],{"class":27,"line":490},53,[25,492,139],{"class":138},[25,494,495],{"class":49}," D: B, C\n",[25,497,499,501],{"class":27,"line":498},54,[25,500,139],{"class":138},[25,502,503],{"class":49}," E: D\n",[25,505,507],{"class":27,"line":506},55,[25,508,39],{"emptyLinePlaceholder":38},[25,510,512,515],{"class":27,"line":511},56,[25,513,514],{"class":45},"**Grafik Terarah**",[25,516,246],{"class":49},[518,519,520],"p",{},"A ‚Üí B ‚Üí D ‚Üí E ‚Üì ‚Üë ‚Üí C ‚îÄ‚îÄ‚îò",[15,522,526],{"className":523,"code":524,"language":525,"meta":20,"style":20},"language-js shiki shiki-themes github-dark github-dark github-light","\n**Urutan Eksekusi**:\n\n1. In-degree:\n   - A: 0, B: 1, C: 1, D: 2, E: 1\n2. Queue awal: `[A]`\n3. Urutan Topologis:\n   - A ‚Üí [B, C] ‚Üí D ‚Üí E\n4. Hasil akhir: `[A, B, C, D, E]` *(atau alternatif: `[A, C, B, D, E]`)*\n\n---\n\n## Implementasi Algoritma Kahn (C++)\n\n```cpp\n#include \u003Ciostream>\n#include \u003Cvector>\n#include \u003Cqueue>\n\nstd::vector\u003Cint> kahnTopologicalSort(int numNodes, const std::vector\u003Cstd::vector\u003Cint>>& adj, std::vector\u003Cint>& inDegree) {\n    std::queue\u003Cint> q;\n    std::vector\u003Cint> result;\n\n    for (int i = 0; i \u003C numNodes; ++i) {\n        if (inDegree[i] == 0) q.push(i);\n    }\n\n    int visitedNodes = 0;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        result.push_back(u);\n        visitedNodes++;\n\n        for (int v : adj[u]) {\n            if (--inDegree[v] == 0) q.push(v);\n        }\n    }\n\n    if (visitedNodes != numNodes) {\n        std::cout \u003C\u003C \"Grafik mengandung siklus!\\n\";\n        return {};\n    }\n\n    return result;\n}\n\nint main() {\n    int numNodes = 5;\n    std::vector\u003Cstd::vector\u003Cint>> adj(numNodes);\n    std::vector\u003Cint> inDegree(numNodes, 0);\n\n    adj[0] = {1, 2}; inDegree[1]++; inDegree[2]++;\n    adj[1] = {3}; inDegree[3]++;\n    adj[2] = {3}; inDegree[3]++;\n    adj[3] = {4}; inDegree[4]++;\n\n    auto order = kahnTopologicalSort(numNodes, adj, inDegree);\n    for (int n : order) std::cout \u003C\u003C n \u003C\u003C \" \";\n    std::cout \u003C\u003C \"\\n\";\n}\n","js",[22,527,528,532,545,549,564,617,633,645,671,702,706,710,714,732,736,741,746,751,756,760,765,770,775,779,784,789,794,798,803,808,813,818,823,827,832,837,842,846,850,855,866,871,875,879,884,889,893,898,903,908,913,917,922,927,932,937,941,947,953,963],{"__ignoreMap":20},[25,529,530],{"class":27,"line":28},[25,531,39],{"emptyLinePlaceholder":38},[25,533,534,538,541,543],{"class":27,"line":35},[25,535,537],{"class":536},"sEiGg","**",[25,539,540],{"class":49},"Urutan Eksekusi",[25,542,537],{"class":536},[25,544,246],{"class":49},[25,546,547],{"class":27,"line":42},[25,548,39],{"emptyLinePlaceholder":38},[25,550,551,553,556,558,562],{"class":27,"line":90},[25,552,324],{"class":77},[25,554,555],{"class":49}," In",[25,557,139],{"class":536},[25,559,561],{"class":560},"s9E-l","degree",[25,563,246],{"class":49},[25,565,566,568,571,574,577,580,583,585,588,590,593,595,597,599,602,604,607,609,612,614],{"class":27,"line":95},[25,567,335],{"class":536},[25,569,570],{"class":560}," A",[25,572,573],{"class":49},": ",[25,575,576],{"class":77},"0",[25,578,579],{"class":49},", ",[25,581,582],{"class":560},"B",[25,584,573],{"class":49},[25,586,587],{"class":77},"1",[25,589,579],{"class":49},[25,591,592],{"class":560},"C",[25,594,573],{"class":49},[25,596,587],{"class":77},[25,598,579],{"class":49},[25,600,601],{"class":560},"D",[25,603,573],{"class":49},[25,605,606],{"class":77},"2",[25,608,579],{"class":49},[25,610,611],{"class":560},"E",[25,613,573],{"class":49},[25,615,616],{"class":77},"1\n",[25,618,619,621,624,627,629],{"class":27,"line":102},[25,620,357],{"class":77},[25,622,623],{"class":49}," Queue ",[25,625,626],{"class":560},"awal",[25,628,573],{"class":49},[25,630,632],{"class":631},"sYTnl","`[A]`\n",[25,634,635,637,640,643],{"class":27,"line":107},[25,636,406],{"class":77},[25,638,639],{"class":49}," Urutan ",[25,641,642],{"class":560},"Topologis",[25,644,246],{"class":49},[25,646,647,649,651,654,656,658,660,663,665,668],{"class":27,"line":113},[25,648,335],{"class":536},[25,650,570],{"class":77},[25,652,653],{"class":49}," ‚Üí [",[25,655,582],{"class":77},[25,657,579],{"class":49},[25,659,592],{"class":77},[25,661,662],{"class":49},"] ‚Üí ",[25,664,601],{"class":77},[25,666,667],{"class":49}," ‚Üí ",[25,669,670],{"class":77},"E\n",[25,672,673,676,679,682,684,687,690,693,696,699],{"class":27,"line":118},[25,674,675],{"class":77},"4.",[25,677,678],{"class":49}," Hasil ",[25,680,681],{"class":560},"akhir",[25,683,573],{"class":49},[25,685,686],{"class":631},"`[A, B, C, D, E]`",[25,688,689],{"class":536}," *",[25,691,692],{"class":49},"(atau alternatif: ",[25,694,695],{"class":631},"`[A, C, B, D, E]`",[25,697,698],{"class":49},")",[25,700,701],{"class":536},"*\n",[25,703,704],{"class":27,"line":130},[25,705,39],{"emptyLinePlaceholder":38},[25,707,708],{"class":27,"line":135},[25,709,201],{"class":536},[25,711,712],{"class":27,"line":151},[25,713,39],{"emptyLinePlaceholder":38},[25,715,716,719,722,724,726,729],{"class":27,"line":165},[25,717,718],{"class":49},"## Implementasi Algoritma ",[25,720,721],{"class":560},"Kahn",[25,723,56],{"class":49},[25,725,592],{"class":77},[25,727,728],{"class":536},"++",[25,730,731],{"class":49},")\n",[25,733,734],{"class":27,"line":179},[25,735,39],{"emptyLinePlaceholder":38},[25,737,738],{"class":27,"line":193},[25,739,740],{"class":631},"```cpp\n",[25,742,743],{"class":27,"line":198},[25,744,745],{"class":631},"#include \u003Ciostream>\n",[25,747,748],{"class":27,"line":204},[25,749,750],{"class":631},"#include \u003Cvector>\n",[25,752,753],{"class":27,"line":209},[25,754,755],{"class":631},"#include \u003Cqueue>\n",[25,757,758],{"class":27,"line":215},[25,759,39],{"emptyLinePlaceholder":38},[25,761,762],{"class":27,"line":220},[25,763,764],{"class":631},"std::vector\u003Cint> kahnTopologicalSort(int numNodes, const std::vector\u003Cstd::vector\u003Cint>>& adj, std::vector\u003Cint>& inDegree) {\n",[25,766,767],{"class":27,"line":235},[25,768,769],{"class":631},"    std::queue\u003Cint> q;\n",[25,771,772],{"class":27,"line":240},[25,773,774],{"class":631},"    std::vector\u003Cint> result;\n",[25,776,777],{"class":27,"line":249},[25,778,39],{"emptyLinePlaceholder":38},[25,780,781],{"class":27,"line":272},[25,782,783],{"class":631},"    for (int i = 0; i \u003C numNodes; ++i) {\n",[25,785,786],{"class":27,"line":277},[25,787,788],{"class":631},"        if (inDegree[i] == 0) q.push(i);\n",[25,790,791],{"class":27,"line":295},[25,792,793],{"class":631},"    }\n",[25,795,796],{"class":27,"line":300},[25,797,39],{"emptyLinePlaceholder":38},[25,799,800],{"class":27,"line":305},[25,801,802],{"class":631},"    int visitedNodes = 0;\n",[25,804,805],{"class":27,"line":310},[25,806,807],{"class":631},"    while (!q.empty()) {\n",[25,809,810],{"class":27,"line":316},[25,811,812],{"class":631},"        int u = q.front(); q.pop();\n",[25,814,815],{"class":27,"line":321},[25,816,817],{"class":631},"        result.push_back(u);\n",[25,819,820],{"class":27,"line":332},[25,821,822],{"class":631},"        visitedNodes++;\n",[25,824,825],{"class":27,"line":341},[25,826,39],{"emptyLinePlaceholder":38},[25,828,829],{"class":27,"line":349},[25,830,831],{"class":631},"        for (int v : adj[u]) {\n",[25,833,834],{"class":27,"line":354},[25,835,836],{"class":631},"            if (--inDegree[v] == 0) q.push(v);\n",[25,838,839],{"class":27,"line":365},[25,840,841],{"class":631},"        }\n",[25,843,844],{"class":27,"line":373},[25,845,793],{"class":631},[25,847,848],{"class":27,"line":382},[25,849,39],{"emptyLinePlaceholder":38},[25,851,852],{"class":27,"line":390},[25,853,854],{"class":631},"    if (visitedNodes != numNodes) {\n",[25,856,857,860,863],{"class":27,"line":398},[25,858,859],{"class":631},"        std::cout \u003C\u003C \"Grafik mengandung siklus!",[25,861,862],{"class":77},"\\n",[25,864,865],{"class":631},"\";\n",[25,867,868],{"class":27,"line":403},[25,869,870],{"class":631},"        return {};\n",[25,872,873],{"class":27,"line":414},[25,874,793],{"class":631},[25,876,877],{"class":27,"line":427},[25,878,39],{"emptyLinePlaceholder":38},[25,880,881],{"class":27,"line":432},[25,882,883],{"class":631},"    return result;\n",[25,885,886],{"class":27,"line":437},[25,887,888],{"class":631},"}\n",[25,890,891],{"class":27,"line":442},[25,892,39],{"emptyLinePlaceholder":38},[25,894,895],{"class":27,"line":448},[25,896,897],{"class":631},"int main() {\n",[25,899,900],{"class":27,"line":453},[25,901,902],{"class":631},"    int numNodes = 5;\n",[25,904,905],{"class":27,"line":461},[25,906,907],{"class":631},"    std::vector\u003Cstd::vector\u003Cint>> adj(numNodes);\n",[25,909,910],{"class":27,"line":466},[25,911,912],{"class":631},"    std::vector\u003Cint> inDegree(numNodes, 0);\n",[25,914,915],{"class":27,"line":474},[25,916,39],{"emptyLinePlaceholder":38},[25,918,919],{"class":27,"line":482},[25,920,921],{"class":631},"    adj[0] = {1, 2}; inDegree[1]++; inDegree[2]++;\n",[25,923,924],{"class":27,"line":490},[25,925,926],{"class":631},"    adj[1] = {3}; inDegree[3]++;\n",[25,928,929],{"class":27,"line":498},[25,930,931],{"class":631},"    adj[2] = {3}; inDegree[3]++;\n",[25,933,934],{"class":27,"line":506},[25,935,936],{"class":631},"    adj[3] = {4}; inDegree[4]++;\n",[25,938,939],{"class":27,"line":511},[25,940,39],{"emptyLinePlaceholder":38},[25,942,944],{"class":27,"line":943},57,[25,945,946],{"class":631},"    auto order = kahnTopologicalSort(numNodes, adj, inDegree);\n",[25,948,950],{"class":27,"line":949},58,[25,951,952],{"class":631},"    for (int n : order) std::cout \u003C\u003C n \u003C\u003C \" \";\n",[25,954,956,959,961],{"class":27,"line":955},59,[25,957,958],{"class":631},"    std::cout \u003C\u003C \"",[25,960,862],{"class":77},[25,962,865],{"class":631},[25,964,966],{"class":27,"line":965},60,[25,967,888],{"class":631},[969,970,972],"h2",{"id":971},"kelebihan-dan-kekurangan","Kelebihan dan Kekurangan",[974,975,977],"h3",{"id":976},"kelebihan","‚úÖ Kelebihan:",[979,980,981,985,988,991],"ul",{},[982,983,984],"li",{},"Menjamin hasil urutan topologis (jika DAG).",[982,986,987],{},"Dapat mendeteksi siklus.",[982,989,990],{},"Intuitif & mudah dipahami.",[982,992,993,994,998],{},"Kompleksitas waktu ",[995,996,997],"strong",{},"O(V + E)",", efisien untuk graf besar.",[974,1000,1002],{"id":1001},"kekurangan","‚ùå Kekurangan:",[979,1004,1005,1012,1018],{},[982,1006,1007,1008,1011],{},"Hanya untuk ",[995,1009,1010],{},"grafik tanpa siklus",".",[982,1013,1014,1015,1011],{},"Tidak menemukan ",[995,1016,1017],{},"jalur terpendek",[982,1019,1020],{},"Bisa ada banyak urutan yang valid.",[969,1022,1024],{"id":1023},"kesimpulan","Kesimpulan",[518,1026,1027,1028,1031],{},"Algoritma Kahn adalah metode yang elegan dan efisien untuk menyusun urutan topologis pada DAG. Dengan memanfaatkan ",[995,1029,1030],{},"in-degree"," dan struktur antrian, ia cocok untuk berbagai kasus yang melibatkan dependensi dan penjadwalan.",[1033,1034,1035],"blockquote",{},[518,1036,1037],{},"Pemahaman konsep dasar seperti in-degree dan traversal node adalah kunci untuk menguasai algoritma ini secara menyeluruh.",[1039,1040,1041],"style",{},"html pre.shiki code .sXvaJ, html code.shiki .sXvaJ{--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;--shiki-default:#79B8FF;--shiki-default-font-weight:bold;--shiki-light:#005CC5;--shiki-light-font-weight:bold}html pre.shiki code .s9_AW, html code.shiki .s9_AW{--shiki-dark:#E1E4E8;--shiki-dark-font-weight:bold;--shiki-default:#E1E4E8;--shiki-default-font-weight:bold;--shiki-light:#24292E;--shiki-light-font-weight:bold}html pre.shiki code .suVJd, html code.shiki .suVJd{--shiki-dark:#E1E4E8;--shiki-default:#E1E4E8;--shiki-light:#24292E}html pre.shiki code .sszsK, html code.shiki .sszsK{--shiki-dark:#E1E4E8;--shiki-dark-font-style:italic;--shiki-default:#E1E4E8;--shiki-default-font-style:italic;--shiki-light:#24292E;--shiki-light-font-style:italic}html pre.shiki code .sAPL1, html code.shiki .sAPL1{--shiki-dark:#79B8FF;--shiki-default:#79B8FF;--shiki-light:#005CC5}html pre.shiki code .scWFE, html code.shiki .scWFE{--shiki-dark:#85E89D;--shiki-default:#85E89D;--shiki-light:#22863A}html pre.shiki code .s1uPE, html code.shiki .s1uPE{--shiki-dark:#FFAB70;--shiki-default:#FFAB70;--shiki-light:#E36209}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html pre.shiki code .sEiGg, html code.shiki .sEiGg{--shiki-dark:#F97583;--shiki-default:#F97583;--shiki-light:#D73A49}html pre.shiki code .s9E-l, html code.shiki .s9E-l{--shiki-dark:#B392F0;--shiki-default:#B392F0;--shiki-light:#6F42C1}html pre.shiki code .sYTnl, html code.shiki .sYTnl{--shiki-dark:#9ECBFF;--shiki-default:#9ECBFF;--shiki-light:#032F62}",{"title":20,"searchDepth":35,"depth":35,"links":1043},[1044,1048],{"id":971,"depth":35,"text":972,"children":1045},[1046,1047],{"id":976,"depth":42,"text":977},{"id":1001,"depth":42,"text":1002},{"id":1023,"depth":35,"text":1024},null,"Selami dunia pengurutan topologis dengan salah satu algoritma paling fundamental.",{"script":1052},[1053],{"type":1054,"key":1055,"data-nuxt-schema-org":38,"nodes":1056},"application/ld+json","schema-org-graph",[1057],{"_resolver":1058},"webPage","/articles/2.jpeg",{},{"props":1062},{},"/en/articles/khans-algorithm",{"_resolver":1058},{"title":5,"description":1050},{"loc":1063,"videos":1067,"images":1068,"lastmod":1069},[],[],"2025-06-13T00:00:00.000Z","en/articles/khans-algorithm",[],"bYH2V69MSed4d_M0RMeosROCrjYuTdlULwMOPRZ_7PU",1750341169906]