[{"data":1,"prerenderedAt":948},["ShallowReactive",2],{"/en/articles/khans-algorithm":3},{"id":4,"title":5,"body":6,"date":924,"description":925,"extension":19,"head":926,"image":934,"meta":935,"navigation":38,"ogImage":936,"path":938,"readingTime":924,"robots":924,"schemaOrg":939,"seo":940,"sitemap":941,"stem":945,"tags":946,"__hash__":947},"articles_en/en/articles/khans-algorithm.md","Memahami Algoritma Kahn",{"type":7,"value":8,"toc":917},"minimal",[9,14,517,521,843,848,853,874,878,896,900,907,913],[10,11,13],"h1",{"id":12},"khans-algorithm","KHANS' Algorithm",[15,16,21],"pre",{"className":17,"code":18,"language":19,"meta":20,"style":20},"language-md shiki shiki-themes github-dark github-dark github-light","# Apa itu Algoritma Kahn?\n\n**Algoritma Kahn** adalah salah satu dari dua algoritma utama yang digunakan untuk melakukan **pengurutan topologis** (*topological sort*) pada sebuah **Grafik Asiklik Terarah** (*Directed Acyclic Graph - DAG*). Pengurutan topologis adalah susunan linier dari node-node sedemikian rupa sehingga untuk setiap sisi terarah (u ‚Üí v), node `u` selalu muncul sebelum node `v`.\n\n> ‚ö†Ô∏è Pengurutan topologis hanya bisa dilakukan jika graf tersebut adalah DAG (tidak mengandung siklus).\n\n## Kegunaan Algoritma Kahn\n\nAlgoritma ini sangat berguna dalam berbagai skenario yang melibatkan **ketergantungan antar tugas**, seperti:\n\n- üìã **Perencanaan Tugas**: Menyusun urutan pekerjaan (misalnya, fondasi rumah harus selesai sebelum membangun dinding).\n- üì¶ **Manajemen Dependensi Paket**: Menentukan urutan instalasi paket perangkat lunak.\n- üéì **Penyelesaian Kursus**: Menentukan urutan mata kuliah berdasarkan prasyarat.\n- üõ†Ô∏è **Kompilasi Kode**: Menentukan urutan file sumber yang harus dikompilasi.\n\n---\n\n## Konsep Kunci: In-degree\n\n**In-degree** (derajat masuk) dari sebuah node adalah jumlah sisi yang **masuk** ke node tersebut.\n\n**Contoh**:\nJika ada sisi `A ‚Üí B` dan `C ‚Üí B`, maka **in-degree B = 2**.\n\nNode dengan **in-degree 0** tidak memiliki prasyarat, sehingga bisa menjadi **titik awal** dalam urutan topologis.\n\n---\n\n## Cara Kerja Algoritma Kahn\n\n1. **Inisialisasi**:\n   - Hitung in-degree untuk setiap node.\n   - Masukkan semua node dengan in-degree 0 ke dalam queue.\n\n2. **Proses Iteratif**:\n   - Selama queue tidak kosong:\n     - Ambil (dequeue) node dari queue, tambahkan ke hasil.\n     - Kurangi in-degree semua tetangga-nya.\n     - Jika in-degree tetangga menjadi 0, tambahkan ke queue.\n\n3. **Verifikasi (Opsional tapi Penting)**:\n   - Jika jumlah node di hasil ‚â† total node, maka graf memiliki **siklus**.\n\n---\n\n## Contoh Masalah: Urutan Mata Kuliah\n\n**Mata Kuliah dan Prasyarat**:\n\n- A: -\n- B: A\n- C: A\n- D: B, C\n- E: D\n\n**Grafik Terarah**:\n","md","",[22,23,24,33,40,88,93,100,105,111,116,128,133,149,163,177,191,196,202,207,213,218,233,238,247,270,275,293,298,303,308,314,319,330,339,347,352,363,371,380,388,396,401,412,425,430,435,440,446,451,459,464,472,480,488,496,504,509],"code",{"__ignoreMap":20},[25,26,29],"span",{"class":27,"line":28},"line",1,[25,30,32],{"class":31},"sXvaJ","# Apa itu Algoritma Kahn?\n",[25,34,36],{"class":27,"line":35},2,[25,37,39],{"emptyLinePlaceholder":38},true,"\n",[25,41,43,47,51,54,57,61,64,67,69,72,75,79,82,85],{"class":27,"line":42},3,[25,44,46],{"class":45},"s9_AW","**Algoritma Kahn**",[25,48,50],{"class":49},"suVJd"," adalah salah satu dari dua algoritma utama yang digunakan untuk melakukan ",[25,52,53],{"class":45},"**pengurutan topologis**",[25,55,56],{"class":49}," (",[25,58,60],{"class":59},"sszsK","*topological sort*",[25,62,63],{"class":49},") pada sebuah ",[25,65,66],{"class":45},"**Grafik Asiklik Terarah**",[25,68,56],{"class":49},[25,70,71],{"class":59},"*Directed Acyclic Graph - DAG*",[25,73,74],{"class":49},"). Pengurutan topologis adalah susunan linier dari node-node sedemikian rupa sehingga untuk setiap sisi terarah (u ‚Üí v), node ",[25,76,78],{"class":77},"sAPL1","`u`",[25,80,81],{"class":49}," selalu muncul sebelum node ",[25,83,84],{"class":77},"`v`",[25,86,87],{"class":49},".\n",[25,89,91],{"class":27,"line":90},4,[25,92,39],{"emptyLinePlaceholder":38},[25,94,96],{"class":27,"line":95},5,[25,97,99],{"class":98},"scWFE","> ‚ö†Ô∏è Pengurutan topologis hanya bisa dilakukan jika graf tersebut adalah DAG (tidak mengandung siklus).\n",[25,101,103],{"class":27,"line":102},6,[25,104,39],{"emptyLinePlaceholder":38},[25,106,108],{"class":27,"line":107},7,[25,109,110],{"class":31},"## Kegunaan Algoritma Kahn\n",[25,112,114],{"class":27,"line":113},8,[25,115,39],{"emptyLinePlaceholder":38},[25,117,119,122,125],{"class":27,"line":118},9,[25,120,121],{"class":49},"Algoritma ini sangat berguna dalam berbagai skenario yang melibatkan ",[25,123,124],{"class":45},"**ketergantungan antar tugas**",[25,126,127],{"class":49},", seperti:\n",[25,129,131],{"class":27,"line":130},10,[25,132,39],{"emptyLinePlaceholder":38},[25,134,136,140,143,146],{"class":27,"line":135},11,[25,137,139],{"class":138},"s1uPE","-",[25,141,142],{"class":49}," üìã ",[25,144,145],{"class":45},"**Perencanaan Tugas**",[25,147,148],{"class":49},": Menyusun urutan pekerjaan (misalnya, fondasi rumah harus selesai sebelum membangun dinding).\n",[25,150,152,154,157,160],{"class":27,"line":151},12,[25,153,139],{"class":138},[25,155,156],{"class":49}," üì¶ ",[25,158,159],{"class":45},"**Manajemen Dependensi Paket**",[25,161,162],{"class":49},": Menentukan urutan instalasi paket perangkat lunak.\n",[25,164,166,168,171,174],{"class":27,"line":165},13,[25,167,139],{"class":138},[25,169,170],{"class":49}," üéì ",[25,172,173],{"class":45},"**Penyelesaian Kursus**",[25,175,176],{"class":49},": Menentukan urutan mata kuliah berdasarkan prasyarat.\n",[25,178,180,182,185,188],{"class":27,"line":179},14,[25,181,139],{"class":138},[25,183,184],{"class":49}," üõ†Ô∏è ",[25,186,187],{"class":45},"**Kompilasi Kode**",[25,189,190],{"class":49},": Menentukan urutan file sumber yang harus dikompilasi.\n",[25,192,194],{"class":27,"line":193},15,[25,195,39],{"emptyLinePlaceholder":38},[25,197,199],{"class":27,"line":198},16,[25,200,201],{"class":31},"---\n",[25,203,205],{"class":27,"line":204},17,[25,206,39],{"emptyLinePlaceholder":38},[25,208,210],{"class":27,"line":209},18,[25,211,212],{"class":31},"## Konsep Kunci: In-degree\n",[25,214,216],{"class":27,"line":215},19,[25,217,39],{"emptyLinePlaceholder":38},[25,219,221,224,227,230],{"class":27,"line":220},20,[25,222,223],{"class":45},"**In-degree**",[25,225,226],{"class":49}," (derajat masuk) dari sebuah node adalah jumlah sisi yang ",[25,228,229],{"class":45},"**masuk**",[25,231,232],{"class":49}," ke node tersebut.\n",[25,234,236],{"class":27,"line":235},21,[25,237,39],{"emptyLinePlaceholder":38},[25,239,241,244],{"class":27,"line":240},22,[25,242,243],{"class":45},"**Contoh**",[25,245,246],{"class":49},":\n",[25,248,250,253,256,259,262,265,268],{"class":27,"line":249},23,[25,251,252],{"class":49},"Jika ada sisi ",[25,254,255],{"class":77},"`A ‚Üí B`",[25,257,258],{"class":49}," dan ",[25,260,261],{"class":77},"`C ‚Üí B`",[25,263,264],{"class":49},", maka ",[25,266,267],{"class":45},"**in-degree B = 2**",[25,269,87],{"class":49},[25,271,273],{"class":27,"line":272},24,[25,274,39],{"emptyLinePlaceholder":38},[25,276,278,281,284,287,290],{"class":27,"line":277},25,[25,279,280],{"class":49},"Node dengan ",[25,282,283],{"class":45},"**in-degree 0**",[25,285,286],{"class":49}," tidak memiliki prasyarat, sehingga bisa menjadi ",[25,288,289],{"class":45},"**titik awal**",[25,291,292],{"class":49}," dalam urutan topologis.\n",[25,294,296],{"class":27,"line":295},26,[25,297,39],{"emptyLinePlaceholder":38},[25,299,301],{"class":27,"line":300},27,[25,302,201],{"class":31},[25,304,306],{"class":27,"line":305},28,[25,307,39],{"emptyLinePlaceholder":38},[25,309,311],{"class":27,"line":310},29,[25,312,313],{"class":31},"## Cara Kerja Algoritma Kahn\n",[25,315,317],{"class":27,"line":316},30,[25,318,39],{"emptyLinePlaceholder":38},[25,320,322,325,328],{"class":27,"line":321},31,[25,323,324],{"class":138},"1.",[25,326,327],{"class":45}," **Inisialisasi**",[25,329,246],{"class":49},[25,331,333,336],{"class":27,"line":332},32,[25,334,335],{"class":138},"   -",[25,337,338],{"class":49}," Hitung in-degree untuk setiap node.\n",[25,340,342,344],{"class":27,"line":341},33,[25,343,335],{"class":138},[25,345,346],{"class":49}," Masukkan semua node dengan in-degree 0 ke dalam queue.\n",[25,348,350],{"class":27,"line":349},34,[25,351,39],{"emptyLinePlaceholder":38},[25,353,355,358,361],{"class":27,"line":354},35,[25,356,357],{"class":138},"2.",[25,359,360],{"class":45}," **Proses Iteratif**",[25,362,246],{"class":49},[25,364,366,368],{"class":27,"line":365},36,[25,367,335],{"class":138},[25,369,370],{"class":49}," Selama queue tidak kosong:\n",[25,372,374,377],{"class":27,"line":373},37,[25,375,376],{"class":138},"     -",[25,378,379],{"class":49}," Ambil (dequeue) node dari queue, tambahkan ke hasil.\n",[25,381,383,385],{"class":27,"line":382},38,[25,384,376],{"class":138},[25,386,387],{"class":49}," Kurangi in-degree semua tetangga-nya.\n",[25,389,391,393],{"class":27,"line":390},39,[25,392,376],{"class":138},[25,394,395],{"class":49}," Jika in-degree tetangga menjadi 0, tambahkan ke queue.\n",[25,397,399],{"class":27,"line":398},40,[25,400,39],{"emptyLinePlaceholder":38},[25,402,404,407,410],{"class":27,"line":403},41,[25,405,406],{"class":138},"3.",[25,408,409],{"class":45}," **Verifikasi (Opsional tapi Penting)**",[25,411,246],{"class":49},[25,413,415,417,420,423],{"class":27,"line":414},42,[25,416,335],{"class":138},[25,418,419],{"class":49}," Jika jumlah node di hasil ‚â† total node, maka graf memiliki ",[25,421,422],{"class":45},"**siklus**",[25,424,87],{"class":49},[25,426,428],{"class":27,"line":427},43,[25,429,39],{"emptyLinePlaceholder":38},[25,431,433],{"class":27,"line":432},44,[25,434,201],{"class":31},[25,436,438],{"class":27,"line":437},45,[25,439,39],{"emptyLinePlaceholder":38},[25,441,443],{"class":27,"line":442},46,[25,444,445],{"class":31},"## Contoh Masalah: Urutan Mata Kuliah\n",[25,447,449],{"class":27,"line":448},47,[25,450,39],{"emptyLinePlaceholder":38},[25,452,454,457],{"class":27,"line":453},48,[25,455,456],{"class":45},"**Mata Kuliah dan Prasyarat**",[25,458,246],{"class":49},[25,460,462],{"class":27,"line":461},49,[25,463,39],{"emptyLinePlaceholder":38},[25,465,467,469],{"class":27,"line":466},50,[25,468,139],{"class":138},[25,470,471],{"class":49}," A: -\n",[25,473,475,477],{"class":27,"line":474},51,[25,476,139],{"class":138},[25,478,479],{"class":49}," B: A\n",[25,481,483,485],{"class":27,"line":482},52,[25,484,139],{"class":138},[25,486,487],{"class":49}," C: A\n",[25,489,491,493],{"class":27,"line":490},53,[25,492,139],{"class":138},[25,494,495],{"class":49}," D: B, C\n",[25,497,499,501],{"class":27,"line":498},54,[25,500,139],{"class":138},[25,502,503],{"class":49}," E: D\n",[25,505,507],{"class":27,"line":506},55,[25,508,39],{"emptyLinePlaceholder":38},[25,510,512,515],{"class":27,"line":511},56,[25,513,514],{"class":45},"**Grafik Terarah**",[25,516,246],{"class":49},[518,519,520],"p",{},"A ‚Üí B ‚Üí D ‚Üí E ‚Üì ‚Üë ‚Üí C ‚îÄ‚îÄ‚îò",[15,522,524],{"className":17,"code":523,"language":19,"meta":20,"style":20},"\n**Urutan Eksekusi**:\n\n1. In-degree:\n   - A: 0, B: 1, C: 1, D: 2, E: 1\n2. Queue awal: `[A]`\n3. Urutan Topologis:\n   - A ‚Üí [B, C] ‚Üí D ‚Üí E\n4. Hasil akhir: `[A, B, C, D, E]` *(atau alternatif: `[A, C, B, D, E]`)*\n\n---\n\n## Implementasi Algoritma Kahn (C++)\n\n```cpp\n#include \u003Ciostream>\n#include \u003Cvector>\n#include \u003Cqueue>\n\nstd::vector\u003Cint> kahnTopologicalSort(int numNodes, const std::vector\u003Cstd::vector\u003Cint>>& adj, std::vector\u003Cint>& inDegree) {\n    std::queue\u003Cint> q;\n    std::vector\u003Cint> result;\n\n    for (int i = 0; i \u003C numNodes; ++i) {\n        if (inDegree[i] == 0) q.push(i);\n    }\n\n    int visitedNodes = 0;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        result.push_back(u);\n        visitedNodes++;\n\n        for (int v : adj[u]) {\n            if (--inDegree[v] == 0) q.push(v);\n        }\n    }\n\n    if (visitedNodes != numNodes) {\n        std::cout \u003C\u003C \"Grafik mengandung siklus!\\n\";\n        return {};\n    }\n\n    return result;\n}\n\nint main() {\n    int numNodes = 5;\n    std::vector\u003Cstd::vector\u003Cint>> adj(numNodes);\n    std::vector\u003Cint> inDegree(numNodes, 0);\n\n    adj[0] = {1, 2}; inDegree[1]++; inDegree[2]++;\n    adj[1] = {3}; inDegree[3]++;\n    adj[2] = {3}; inDegree[3]++;\n    adj[3] = {4}; inDegree[4]++;\n\n    auto order = kahnTopologicalSort(numNodes, adj, inDegree);\n    for (int n : order) std::cout \u003C\u003C n \u003C\u003C \" \";\n    std::cout \u003C\u003C \"\\n\";\n}\n",[22,525,526,530,537,541,548,555,565,572,579,600,604,608,612,617,621,626,631,636,641,645,650,655,660,664,669,674,679,683,688,693,698,703,708,712,717,722,727,731,735,740,745,750,754,758,763,768,772,777,782,787,792,796,801,806,811,816,820,826,832,838],{"__ignoreMap":20},[25,527,528],{"class":27,"line":28},[25,529,39],{"emptyLinePlaceholder":38},[25,531,532,535],{"class":27,"line":35},[25,533,534],{"class":45},"**Urutan Eksekusi**",[25,536,246],{"class":49},[25,538,539],{"class":27,"line":42},[25,540,39],{"emptyLinePlaceholder":38},[25,542,543,545],{"class":27,"line":90},[25,544,324],{"class":138},[25,546,547],{"class":49}," In-degree:\n",[25,549,550,552],{"class":27,"line":95},[25,551,335],{"class":138},[25,553,554],{"class":49}," A: 0, B: 1, C: 1, D: 2, E: 1\n",[25,556,557,559,562],{"class":27,"line":102},[25,558,357],{"class":138},[25,560,561],{"class":49}," Queue awal: ",[25,563,564],{"class":77},"`[A]`\n",[25,566,567,569],{"class":27,"line":107},[25,568,406],{"class":138},[25,570,571],{"class":49}," Urutan Topologis:\n",[25,573,574,576],{"class":27,"line":113},[25,575,335],{"class":138},[25,577,578],{"class":49}," A ‚Üí [B, C] ‚Üí D ‚Üí E\n",[25,580,581,584,587,590,593,597],{"class":27,"line":118},[25,582,583],{"class":138},"4.",[25,585,586],{"class":49}," Hasil akhir: ",[25,588,589],{"class":77},"`[A, B, C, D, E]`",[25,591,592],{"class":59}," *(atau alternatif: ",[25,594,596],{"class":595},"se7mT","`[A, C, B, D, E]`",[25,598,599],{"class":59},")*\n",[25,601,602],{"class":27,"line":130},[25,603,39],{"emptyLinePlaceholder":38},[25,605,606],{"class":27,"line":135},[25,607,201],{"class":31},[25,609,610],{"class":27,"line":151},[25,611,39],{"emptyLinePlaceholder":38},[25,613,614],{"class":27,"line":165},[25,615,616],{"class":31},"## Implementasi Algoritma Kahn (C++)\n",[25,618,619],{"class":27,"line":179},[25,620,39],{"emptyLinePlaceholder":38},[25,622,623],{"class":27,"line":193},[25,624,625],{"class":49},"```cpp\n",[25,627,628],{"class":27,"line":198},[25,629,630],{"class":49},"#include \u003Ciostream>\n",[25,632,633],{"class":27,"line":204},[25,634,635],{"class":49},"#include \u003Cvector>\n",[25,637,638],{"class":27,"line":209},[25,639,640],{"class":49},"#include \u003Cqueue>\n",[25,642,643],{"class":27,"line":215},[25,644,39],{"emptyLinePlaceholder":38},[25,646,647],{"class":27,"line":220},[25,648,649],{"class":49},"std::vector\u003Cint> kahnTopologicalSort(int numNodes, const std::vector\u003Cstd::vector\u003Cint>>& adj, std::vector\u003Cint>& inDegree) {\n",[25,651,652],{"class":27,"line":235},[25,653,654],{"class":49},"    std::queue\u003Cint> q;\n",[25,656,657],{"class":27,"line":240},[25,658,659],{"class":49},"    std::vector\u003Cint> result;\n",[25,661,662],{"class":27,"line":249},[25,663,39],{"emptyLinePlaceholder":38},[25,665,666],{"class":27,"line":272},[25,667,668],{"class":49},"    for (int i = 0; i \u003C numNodes; ++i) {\n",[25,670,671],{"class":27,"line":277},[25,672,673],{"class":49},"        if (inDegree[i] == 0) q.push(i);\n",[25,675,676],{"class":27,"line":295},[25,677,678],{"class":49},"    }\n",[25,680,681],{"class":27,"line":300},[25,682,39],{"emptyLinePlaceholder":38},[25,684,685],{"class":27,"line":305},[25,686,687],{"class":49},"    int visitedNodes = 0;\n",[25,689,690],{"class":27,"line":310},[25,691,692],{"class":49},"    while (!q.empty()) {\n",[25,694,695],{"class":27,"line":316},[25,696,697],{"class":49},"        int u = q.front(); q.pop();\n",[25,699,700],{"class":27,"line":321},[25,701,702],{"class":49},"        result.push_back(u);\n",[25,704,705],{"class":27,"line":332},[25,706,707],{"class":49},"        visitedNodes++;\n",[25,709,710],{"class":27,"line":341},[25,711,39],{"emptyLinePlaceholder":38},[25,713,714],{"class":27,"line":349},[25,715,716],{"class":49},"        for (int v : adj[u]) {\n",[25,718,719],{"class":27,"line":354},[25,720,721],{"class":49},"            if (--inDegree[v] == 0) q.push(v);\n",[25,723,724],{"class":27,"line":365},[25,725,726],{"class":49},"        }\n",[25,728,729],{"class":27,"line":373},[25,730,678],{"class":49},[25,732,733],{"class":27,"line":382},[25,734,39],{"emptyLinePlaceholder":38},[25,736,737],{"class":27,"line":390},[25,738,739],{"class":49},"    if (visitedNodes != numNodes) {\n",[25,741,742],{"class":27,"line":398},[25,743,744],{"class":49},"        std::cout \u003C\u003C \"Grafik mengandung siklus!\\n\";\n",[25,746,747],{"class":27,"line":403},[25,748,749],{"class":49},"        return {};\n",[25,751,752],{"class":27,"line":414},[25,753,678],{"class":49},[25,755,756],{"class":27,"line":427},[25,757,39],{"emptyLinePlaceholder":38},[25,759,760],{"class":27,"line":432},[25,761,762],{"class":49},"    return result;\n",[25,764,765],{"class":27,"line":437},[25,766,767],{"class":49},"}\n",[25,769,770],{"class":27,"line":442},[25,771,39],{"emptyLinePlaceholder":38},[25,773,774],{"class":27,"line":448},[25,775,776],{"class":49},"int main() {\n",[25,778,779],{"class":27,"line":453},[25,780,781],{"class":49},"    int numNodes = 5;\n",[25,783,784],{"class":27,"line":461},[25,785,786],{"class":49},"    std::vector\u003Cstd::vector\u003Cint>> adj(numNodes);\n",[25,788,789],{"class":27,"line":466},[25,790,791],{"class":49},"    std::vector\u003Cint> inDegree(numNodes, 0);\n",[25,793,794],{"class":27,"line":474},[25,795,39],{"emptyLinePlaceholder":38},[25,797,798],{"class":27,"line":482},[25,799,800],{"class":49},"    adj[0] = {1, 2}; inDegree[1]++; inDegree[2]++;\n",[25,802,803],{"class":27,"line":490},[25,804,805],{"class":49},"    adj[1] = {3}; inDegree[3]++;\n",[25,807,808],{"class":27,"line":498},[25,809,810],{"class":49},"    adj[2] = {3}; inDegree[3]++;\n",[25,812,813],{"class":27,"line":506},[25,814,815],{"class":49},"    adj[3] = {4}; inDegree[4]++;\n",[25,817,818],{"class":27,"line":511},[25,819,39],{"emptyLinePlaceholder":38},[25,821,823],{"class":27,"line":822},57,[25,824,825],{"class":49},"    auto order = kahnTopologicalSort(numNodes, adj, inDegree);\n",[25,827,829],{"class":27,"line":828},58,[25,830,831],{"class":49},"    for (int n : order) std::cout \u003C\u003C n \u003C\u003C \" \";\n",[25,833,835],{"class":27,"line":834},59,[25,836,837],{"class":49},"    std::cout \u003C\u003C \"\\n\";\n",[25,839,841],{"class":27,"line":840},60,[25,842,767],{"class":49},[844,845,847],"h2",{"id":846},"kelebihan-dan-kekurangan","Kelebihan dan Kekurangan",[849,850,852],"h3",{"id":851},"kelebihan","‚úÖ Kelebihan:",[854,855,856,860,863,866],"ul",{},[857,858,859],"li",{},"Menjamin hasil urutan topologis (jika DAG).",[857,861,862],{},"Dapat mendeteksi siklus.",[857,864,865],{},"Intuitif & mudah dipahami.",[857,867,868,869,873],{},"Kompleksitas waktu ",[870,871,872],"strong",{},"O(V + E)",", efisien untuk graf besar.",[849,875,877],{"id":876},"kekurangan","‚ùå Kekurangan:",[854,879,880,887,893],{},[857,881,882,883,886],{},"Hanya untuk ",[870,884,885],{},"grafik tanpa siklus",".",[857,888,889,890,886],{},"Tidak menemukan ",[870,891,892],{},"jalur terpendek",[857,894,895],{},"Bisa ada banyak urutan yang valid.",[844,897,899],{"id":898},"kesimpulan","Kesimpulan",[518,901,902,903,906],{},"Algoritma Kahn adalah metode yang elegan dan efisien untuk menyusun urutan topologis pada DAG. Dengan memanfaatkan ",[870,904,905],{},"in-degree"," dan struktur antrian, ia cocok untuk berbagai kasus yang melibatkan dependensi dan penjadwalan.",[908,909,910],"blockquote",{},[518,911,912],{},"Pemahaman konsep dasar seperti in-degree dan traversal node adalah kunci untuk menguasai algoritma ini secara menyeluruh.",[914,915,916],"style",{},"html pre.shiki code .sXvaJ, html code.shiki .sXvaJ{--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;--shiki-default:#79B8FF;--shiki-default-font-weight:bold;--shiki-light:#005CC5;--shiki-light-font-weight:bold}html pre.shiki code .s9_AW, html code.shiki .s9_AW{--shiki-dark:#E1E4E8;--shiki-dark-font-weight:bold;--shiki-default:#E1E4E8;--shiki-default-font-weight:bold;--shiki-light:#24292E;--shiki-light-font-weight:bold}html pre.shiki code .suVJd, html code.shiki .suVJd{--shiki-dark:#E1E4E8;--shiki-default:#E1E4E8;--shiki-light:#24292E}html pre.shiki code .sszsK, html code.shiki .sszsK{--shiki-dark:#E1E4E8;--shiki-dark-font-style:italic;--shiki-default:#E1E4E8;--shiki-default-font-style:italic;--shiki-light:#24292E;--shiki-light-font-style:italic}html pre.shiki code .sAPL1, html code.shiki .sAPL1{--shiki-dark:#79B8FF;--shiki-default:#79B8FF;--shiki-light:#005CC5}html pre.shiki code .scWFE, html code.shiki .scWFE{--shiki-dark:#85E89D;--shiki-default:#85E89D;--shiki-light:#22863A}html pre.shiki code .s1uPE, html code.shiki .s1uPE{--shiki-dark:#FFAB70;--shiki-default:#FFAB70;--shiki-light:#E36209}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html pre.shiki code .se7mT, html code.shiki .se7mT{--shiki-dark:#79B8FF;--shiki-dark-font-style:italic;--shiki-default:#79B8FF;--shiki-default-font-style:italic;--shiki-light:#005CC5;--shiki-light-font-style:italic}",{"title":20,"searchDepth":35,"depth":35,"links":918},[919,923],{"id":846,"depth":35,"text":847,"children":920},[921,922],{"id":851,"depth":42,"text":852},{"id":876,"depth":42,"text":877},{"id":898,"depth":35,"text":899},null,"Selami dunia pengurutan topologis dengan salah satu algoritma paling fundamental.",{"script":927},[928],{"type":929,"key":930,"data-nuxt-schema-org":38,"nodes":931},"application/ld+json","schema-org-graph",[932],{"_resolver":933},"webPage","/articles/2.jpeg",{},{"props":937},{},"/en/articles/khans-algorithm",{"_resolver":933},{"title":5,"description":925},{"loc":938,"videos":942,"images":943,"lastmod":944},[],[],"2025-06-13T00:00:00.000Z","en/articles/khans-algorithm",[],"W36-DRcXG7gnUAjRLs8nvjLtyYqPDhqmNr_kOwiKvPs",1750352580063]