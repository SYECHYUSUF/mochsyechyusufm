[{"data":1,"prerenderedAt":872},["ShallowReactive",2],{"/en/articles/breadth-firts-search":3},{"id":4,"title":5,"body":6,"date":848,"description":849,"extension":19,"head":850,"image":858,"meta":859,"navigation":38,"ogImage":860,"path":862,"readingTime":848,"robots":848,"schemaOrg":863,"seo":864,"sitemap":865,"stem":869,"tags":870,"__hash__":871},"articles_en/en/articles/breadth-firts-search.md","Mengenal Algoritma Breadth-First Search (BFS)",{"type":7,"value":8,"toc":841},"minimal",[9,14,348,359,363,752,757,762,782,786,804,822,826,832,837],[10,11,13],"h1",{"id":12},"breadth-firts-search","BREADTH FIRTS SEARCH",[15,16,21],"pre",{"className":17,"code":18,"language":19,"meta":20,"style":20},"language-md shiki shiki-themes github-dark github-dark github-light","# Apa itu Algoritma Breadth-First Search (BFS)?\n\n**Breadth-First Search (BFS)** adalah algoritma pencarian dan penelusuran pada struktur data **grafik** atau **pohon**. BFS menjelajahi simpul (node) grafik dengan memulai dari node awal, lalu mengunjungi semua tetangga terdekat terlebih dahulu sebelum bergerak ke level berikutnya.\n\n> 🔍 BFS menelusuri secara **melebar**, bukan menyelam seperti DFS.\n\n---\n\n## Aplikasi BFS\n\nBFS banyak digunakan dalam berbagai masalah komputer, antara lain:\n\n- 🔁 **Menemukan jalur terpendek** dalam graf tak berbobot.\n- 🔍 **Pencarian elemen** dalam pohon atau graf.\n- 🌐 **Analisis jaringan**: Menentukan jarak antar simpul.\n- 🔧 **Pemecahan puzzle** seperti Rubik, Sudoku, atau pencarian labirin.\n- 📶 **Broadcasting**: Menyebarkan informasi dari satu node ke semua node.\n\n---\n\n## Cara Kerja BFS\n\n### Struktur Pendukung:\n- **Queue (antrian)**: Untuk mengatur urutan simpul yang akan dieksplorasi.\n- **Visited[]**: Untuk menandai simpul yang sudah dikunjungi agar tidak dikunjungi dua kali.\n\n### Langkah-langkah BFS:\n\n1. Masukkan `start node` ke queue dan tandai sebagai dikunjungi.\n2. Selama queue tidak kosong:\n   - Ambil node dari depan queue (dequeue).\n   - Proses node (misalnya cetak atau simpan hasil).\n   - Tambahkan semua tetangga **yang belum dikunjungi** ke queue dan tandai sebagai dikunjungi.\n\n---\n\n## Contoh Kasus\n\nGrafik:\n","md","",[22,23,24,33,40,63,68,81,86,92,97,103,108,114,119,135,149,163,177,191,196,201,206,212,217,223,234,245,250,256,261,277,286,295,303,316,321,326,331,337,342],"code",{"__ignoreMap":20},[25,26,29],"span",{"class":27,"line":28},"line",1,[25,30,32],{"class":31},"sXvaJ","# Apa itu Algoritma Breadth-First Search (BFS)?\n",[25,34,36],{"class":27,"line":35},2,[25,37,39],{"emptyLinePlaceholder":38},true,"\n",[25,41,43,47,51,54,57,60],{"class":27,"line":42},3,[25,44,46],{"class":45},"s9_AW","**Breadth-First Search (BFS)**",[25,48,50],{"class":49},"suVJd"," adalah algoritma pencarian dan penelusuran pada struktur data ",[25,52,53],{"class":45},"**grafik**",[25,55,56],{"class":49}," atau ",[25,58,59],{"class":45},"**pohon**",[25,61,62],{"class":49},". BFS menjelajahi simpul (node) grafik dengan memulai dari node awal, lalu mengunjungi semua tetangga terdekat terlebih dahulu sebelum bergerak ke level berikutnya.\n",[25,64,66],{"class":27,"line":65},4,[25,67,39],{"emptyLinePlaceholder":38},[25,69,71,75,78],{"class":27,"line":70},5,[25,72,74],{"class":73},"scWFE","> 🔍 BFS menelusuri secara ",[25,76,77],{"class":45},"**melebar**",[25,79,80],{"class":73},", bukan menyelam seperti DFS.\n",[25,82,84],{"class":27,"line":83},6,[25,85,39],{"emptyLinePlaceholder":38},[25,87,89],{"class":27,"line":88},7,[25,90,91],{"class":31},"---\n",[25,93,95],{"class":27,"line":94},8,[25,96,39],{"emptyLinePlaceholder":38},[25,98,100],{"class":27,"line":99},9,[25,101,102],{"class":31},"## Aplikasi BFS\n",[25,104,106],{"class":27,"line":105},10,[25,107,39],{"emptyLinePlaceholder":38},[25,109,111],{"class":27,"line":110},11,[25,112,113],{"class":49},"BFS banyak digunakan dalam berbagai masalah komputer, antara lain:\n",[25,115,117],{"class":27,"line":116},12,[25,118,39],{"emptyLinePlaceholder":38},[25,120,122,126,129,132],{"class":27,"line":121},13,[25,123,125],{"class":124},"s1uPE","-",[25,127,128],{"class":49}," 🔁 ",[25,130,131],{"class":45},"**Menemukan jalur terpendek**",[25,133,134],{"class":49}," dalam graf tak berbobot.\n",[25,136,138,140,143,146],{"class":27,"line":137},14,[25,139,125],{"class":124},[25,141,142],{"class":49}," 🔍 ",[25,144,145],{"class":45},"**Pencarian elemen**",[25,147,148],{"class":49}," dalam pohon atau graf.\n",[25,150,152,154,157,160],{"class":27,"line":151},15,[25,153,125],{"class":124},[25,155,156],{"class":49}," 🌐 ",[25,158,159],{"class":45},"**Analisis jaringan**",[25,161,162],{"class":49},": Menentukan jarak antar simpul.\n",[25,164,166,168,171,174],{"class":27,"line":165},16,[25,167,125],{"class":124},[25,169,170],{"class":49}," 🔧 ",[25,172,173],{"class":45},"**Pemecahan puzzle**",[25,175,176],{"class":49}," seperti Rubik, Sudoku, atau pencarian labirin.\n",[25,178,180,182,185,188],{"class":27,"line":179},17,[25,181,125],{"class":124},[25,183,184],{"class":49}," 📶 ",[25,186,187],{"class":45},"**Broadcasting**",[25,189,190],{"class":49},": Menyebarkan informasi dari satu node ke semua node.\n",[25,192,194],{"class":27,"line":193},18,[25,195,39],{"emptyLinePlaceholder":38},[25,197,199],{"class":27,"line":198},19,[25,200,91],{"class":31},[25,202,204],{"class":27,"line":203},20,[25,205,39],{"emptyLinePlaceholder":38},[25,207,209],{"class":27,"line":208},21,[25,210,211],{"class":31},"## Cara Kerja BFS\n",[25,213,215],{"class":27,"line":214},22,[25,216,39],{"emptyLinePlaceholder":38},[25,218,220],{"class":27,"line":219},23,[25,221,222],{"class":31},"### Struktur Pendukung:\n",[25,224,226,228,231],{"class":27,"line":225},24,[25,227,125],{"class":124},[25,229,230],{"class":45}," **Queue (antrian)**",[25,232,233],{"class":49},": Untuk mengatur urutan simpul yang akan dieksplorasi.\n",[25,235,237,239,242],{"class":27,"line":236},25,[25,238,125],{"class":124},[25,240,241],{"class":45}," **Visited[]**",[25,243,244],{"class":49},": Untuk menandai simpul yang sudah dikunjungi agar tidak dikunjungi dua kali.\n",[25,246,248],{"class":27,"line":247},26,[25,249,39],{"emptyLinePlaceholder":38},[25,251,253],{"class":27,"line":252},27,[25,254,255],{"class":31},"### Langkah-langkah BFS:\n",[25,257,259],{"class":27,"line":258},28,[25,260,39],{"emptyLinePlaceholder":38},[25,262,264,267,270,274],{"class":27,"line":263},29,[25,265,266],{"class":124},"1.",[25,268,269],{"class":49}," Masukkan ",[25,271,273],{"class":272},"sAPL1","`start node`",[25,275,276],{"class":49}," ke queue dan tandai sebagai dikunjungi.\n",[25,278,280,283],{"class":27,"line":279},30,[25,281,282],{"class":124},"2.",[25,284,285],{"class":49}," Selama queue tidak kosong:\n",[25,287,289,292],{"class":27,"line":288},31,[25,290,291],{"class":124},"   -",[25,293,294],{"class":49}," Ambil node dari depan queue (dequeue).\n",[25,296,298,300],{"class":27,"line":297},32,[25,299,291],{"class":124},[25,301,302],{"class":49}," Proses node (misalnya cetak atau simpan hasil).\n",[25,304,306,308,311,314],{"class":27,"line":305},33,[25,307,291],{"class":124},[25,309,310],{"class":49}," Tambahkan semua tetangga ",[25,312,313],{"class":45},"**yang belum dikunjungi**",[25,315,276],{"class":49},[25,317,319],{"class":27,"line":318},34,[25,320,39],{"emptyLinePlaceholder":38},[25,322,324],{"class":27,"line":323},35,[25,325,91],{"class":31},[25,327,329],{"class":27,"line":328},36,[25,330,39],{"emptyLinePlaceholder":38},[25,332,334],{"class":27,"line":333},37,[25,335,336],{"class":31},"## Contoh Kasus\n",[25,338,340],{"class":27,"line":339},38,[25,341,39],{"emptyLinePlaceholder":38},[25,343,345],{"class":27,"line":344},39,[25,346,347],{"class":49},"Grafik:\n",[15,349,353],{"className":350,"code":351,"language":352,"meta":20,"style":20},"language-js shiki shiki-themes github-dark github-dark github-light","A\n","js",[22,354,355],{"__ignoreMap":20},[25,356,357],{"class":27,"line":28},[25,358,351],{"class":272},[360,361,362],"p",{},"/ B C / \\ D E F",[15,364,366],{"className":17,"code":365,"language":19,"meta":20,"style":20},"\n**Tujuan**: Lakukan penelusuran BFS dari node `A`.\n\n### Urutan Penjelajahan:\n`A → B → C → D → E → F`\n\n**Langkah BFS**:\n1. Mulai dari A → `visited[A] = true`, queue: `[A]`\n2. Dequeue A → tetangga B, C → queue: `[B, C]`\n3. Dequeue B → tetangga D, E → queue: `[C, D, E]`\n4. Dequeue C → tetangga F → queue: `[D, E, F]`\n5. Dequeue D → tidak ada tetangga baru\n6. Dequeue E → tidak ada tetangga baru\n7. Dequeue F → selesai\n\n---\n\n## Implementasi BFS dalam C++\n\n```cpp\n#include \u003Ciostream>\n#include \u003Cvector>\n#include \u003Cqueue>\n\nstd::vector\u003Cstd::vector\u003Cint>> adj;\nstd::vector\u003Cbool> visited;\n\nvoid bfs(int startNode) {\n    std::queue\u003Cint> q;\n    visited[startNode] = true;\n    q.push(startNode);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        std::cout \u003C\u003C u \u003C\u003C \" \";\n\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nint main() {\n    int numNodes = 6; // A=0, B=1, C=2, D=3, E=4, F=5\n    adj.resize(numNodes);\n    visited.resize(numNodes, false);\n\n    // Membangun graf (tidak berarah)\n    adj[0] = {1, 2};     // A → B, C\n    adj[1] = {0, 3, 4};  // B → A, D, E\n    adj[2] = {0, 5};     // C → A, F\n    adj[3] = {1};        // D → B\n    adj[4] = {1};        // E → B\n    adj[5] = {2};        // F → C\n\n    std::cout \u003C\u003C \"BFS dari node A (0): \";\n    bfs(0); // Start dari A (index 0)\n    std::cout \u003C\u003C \"\\n\";\n\n    return 0;\n}\n",[22,367,368,372,386,390,395,400,404,412,428,438,449,460,468,476,484,488,492,496,501,505,510,515,520,525,529,534,539,543,548,553,558,563,567,572,577,582,587,591,596,601,607,613,619,625,631,637,642,648,654,660,666,671,677,683,689,695,701,707,713,718,724,730,736,741,747],{"__ignoreMap":20},[25,369,370],{"class":27,"line":28},[25,371,39],{"emptyLinePlaceholder":38},[25,373,374,377,380,383],{"class":27,"line":35},[25,375,376],{"class":45},"**Tujuan**",[25,378,379],{"class":49},": Lakukan penelusuran BFS dari node ",[25,381,382],{"class":272},"`A`",[25,384,385],{"class":49},".\n",[25,387,388],{"class":27,"line":42},[25,389,39],{"emptyLinePlaceholder":38},[25,391,392],{"class":27,"line":65},[25,393,394],{"class":31},"### Urutan Penjelajahan:\n",[25,396,397],{"class":27,"line":70},[25,398,399],{"class":272},"`A → B → C → D → E → F`\n",[25,401,402],{"class":27,"line":83},[25,403,39],{"emptyLinePlaceholder":38},[25,405,406,409],{"class":27,"line":88},[25,407,408],{"class":45},"**Langkah BFS**",[25,410,411],{"class":49},":\n",[25,413,414,416,419,422,425],{"class":27,"line":94},[25,415,266],{"class":124},[25,417,418],{"class":49}," Mulai dari A → ",[25,420,421],{"class":272},"`visited[A] = true`",[25,423,424],{"class":49},", queue: ",[25,426,427],{"class":272},"`[A]`\n",[25,429,430,432,435],{"class":27,"line":99},[25,431,282],{"class":124},[25,433,434],{"class":49}," Dequeue A → tetangga B, C → queue: ",[25,436,437],{"class":272},"`[B, C]`\n",[25,439,440,443,446],{"class":27,"line":105},[25,441,442],{"class":124},"3.",[25,444,445],{"class":49}," Dequeue B → tetangga D, E → queue: ",[25,447,448],{"class":272},"`[C, D, E]`\n",[25,450,451,454,457],{"class":27,"line":110},[25,452,453],{"class":124},"4.",[25,455,456],{"class":49}," Dequeue C → tetangga F → queue: ",[25,458,459],{"class":272},"`[D, E, F]`\n",[25,461,462,465],{"class":27,"line":116},[25,463,464],{"class":124},"5.",[25,466,467],{"class":49}," Dequeue D → tidak ada tetangga baru\n",[25,469,470,473],{"class":27,"line":121},[25,471,472],{"class":124},"6.",[25,474,475],{"class":49}," Dequeue E → tidak ada tetangga baru\n",[25,477,478,481],{"class":27,"line":137},[25,479,480],{"class":124},"7.",[25,482,483],{"class":49}," Dequeue F → selesai\n",[25,485,486],{"class":27,"line":151},[25,487,39],{"emptyLinePlaceholder":38},[25,489,490],{"class":27,"line":165},[25,491,91],{"class":31},[25,493,494],{"class":27,"line":179},[25,495,39],{"emptyLinePlaceholder":38},[25,497,498],{"class":27,"line":193},[25,499,500],{"class":31},"## Implementasi BFS dalam C++\n",[25,502,503],{"class":27,"line":198},[25,504,39],{"emptyLinePlaceholder":38},[25,506,507],{"class":27,"line":203},[25,508,509],{"class":49},"```cpp\n",[25,511,512],{"class":27,"line":208},[25,513,514],{"class":49},"#include \u003Ciostream>\n",[25,516,517],{"class":27,"line":214},[25,518,519],{"class":49},"#include \u003Cvector>\n",[25,521,522],{"class":27,"line":219},[25,523,524],{"class":49},"#include \u003Cqueue>\n",[25,526,527],{"class":27,"line":225},[25,528,39],{"emptyLinePlaceholder":38},[25,530,531],{"class":27,"line":236},[25,532,533],{"class":49},"std::vector\u003Cstd::vector\u003Cint>> adj;\n",[25,535,536],{"class":27,"line":247},[25,537,538],{"class":49},"std::vector\u003Cbool> visited;\n",[25,540,541],{"class":27,"line":252},[25,542,39],{"emptyLinePlaceholder":38},[25,544,545],{"class":27,"line":258},[25,546,547],{"class":49},"void bfs(int startNode) {\n",[25,549,550],{"class":27,"line":263},[25,551,552],{"class":49},"    std::queue\u003Cint> q;\n",[25,554,555],{"class":27,"line":279},[25,556,557],{"class":49},"    visited[startNode] = true;\n",[25,559,560],{"class":27,"line":288},[25,561,562],{"class":49},"    q.push(startNode);\n",[25,564,565],{"class":27,"line":297},[25,566,39],{"emptyLinePlaceholder":38},[25,568,569],{"class":27,"line":305},[25,570,571],{"class":49},"    while (!q.empty()) {\n",[25,573,574],{"class":27,"line":318},[25,575,576],{"class":49},"        int u = q.front();\n",[25,578,579],{"class":27,"line":323},[25,580,581],{"class":49},"        q.pop();\n",[25,583,584],{"class":27,"line":328},[25,585,586],{"class":49},"        std::cout \u003C\u003C u \u003C\u003C \" \";\n",[25,588,589],{"class":27,"line":333},[25,590,39],{"emptyLinePlaceholder":38},[25,592,593],{"class":27,"line":339},[25,594,595],{"class":49},"        for (int v : adj[u]) {\n",[25,597,598],{"class":27,"line":344},[25,599,600],{"class":49},"            if (!visited[v]) {\n",[25,602,604],{"class":27,"line":603},40,[25,605,606],{"class":49},"                visited[v] = true;\n",[25,608,610],{"class":27,"line":609},41,[25,611,612],{"class":49},"                q.push(v);\n",[25,614,616],{"class":27,"line":615},42,[25,617,618],{"class":49},"            }\n",[25,620,622],{"class":27,"line":621},43,[25,623,624],{"class":49},"        }\n",[25,626,628],{"class":27,"line":627},44,[25,629,630],{"class":49},"    }\n",[25,632,634],{"class":27,"line":633},45,[25,635,636],{"class":49},"}\n",[25,638,640],{"class":27,"line":639},46,[25,641,39],{"emptyLinePlaceholder":38},[25,643,645],{"class":27,"line":644},47,[25,646,647],{"class":49},"int main() {\n",[25,649,651],{"class":27,"line":650},48,[25,652,653],{"class":49},"    int numNodes = 6; // A=0, B=1, C=2, D=3, E=4, F=5\n",[25,655,657],{"class":27,"line":656},49,[25,658,659],{"class":49},"    adj.resize(numNodes);\n",[25,661,663],{"class":27,"line":662},50,[25,664,665],{"class":49},"    visited.resize(numNodes, false);\n",[25,667,669],{"class":27,"line":668},51,[25,670,39],{"emptyLinePlaceholder":38},[25,672,674],{"class":27,"line":673},52,[25,675,676],{"class":49},"    // Membangun graf (tidak berarah)\n",[25,678,680],{"class":27,"line":679},53,[25,681,682],{"class":49},"    adj[0] = {1, 2};     // A → B, C\n",[25,684,686],{"class":27,"line":685},54,[25,687,688],{"class":49},"    adj[1] = {0, 3, 4};  // B → A, D, E\n",[25,690,692],{"class":27,"line":691},55,[25,693,694],{"class":49},"    adj[2] = {0, 5};     // C → A, F\n",[25,696,698],{"class":27,"line":697},56,[25,699,700],{"class":49},"    adj[3] = {1};        // D → B\n",[25,702,704],{"class":27,"line":703},57,[25,705,706],{"class":49},"    adj[4] = {1};        // E → B\n",[25,708,710],{"class":27,"line":709},58,[25,711,712],{"class":49},"    adj[5] = {2};        // F → C\n",[25,714,716],{"class":27,"line":715},59,[25,717,39],{"emptyLinePlaceholder":38},[25,719,721],{"class":27,"line":720},60,[25,722,723],{"class":49},"    std::cout \u003C\u003C \"BFS dari node A (0): \";\n",[25,725,727],{"class":27,"line":726},61,[25,728,729],{"class":49},"    bfs(0); // Start dari A (index 0)\n",[25,731,733],{"class":27,"line":732},62,[25,734,735],{"class":49},"    std::cout \u003C\u003C \"\\n\";\n",[25,737,739],{"class":27,"line":738},63,[25,740,39],{"emptyLinePlaceholder":38},[25,742,744],{"class":27,"line":743},64,[25,745,746],{"class":49},"    return 0;\n",[25,748,750],{"class":27,"line":749},65,[25,751,636],{"class":49},[753,754,756],"h2",{"id":755},"kelebihan-dan-kekurangan","Kelebihan dan Kekurangan",[758,759,761],"h3",{"id":760},"kelebihan-bfs","✅ Kelebihan BFS:",[763,764,765,773,779],"ul",{},[766,767,768,772],"li",{},[769,770,771],"strong",{},"Menemukan jalur terpendek"," dalam graf tak berbobot.",[766,774,775,778],{},[769,776,777],{},"Bekerja baik pada graf level-wise",", misalnya puzzle, pohon.",[766,780,781],{},"Efektif untuk menjelajahi semua node dalam urutan terstruktur.",[758,783,785],{"id":784},"kekurangan-bfs","❌ Kekurangan BFS:",[763,787,788,795,798],{},[766,789,790,791,794],{},"Memakan ",[769,792,793],{},"memori besar"," jika graf memiliki banyak node di level yang sama.",[766,796,797],{},"Kurang cocok untuk graf sangat dalam (deep tree) dibanding DFS.",[766,799,800,803],{},[769,801,802],{},"Lebih lambat"," dari DFS pada graf dengan solusi dalam jalur panjang tunggal.",[805,806,807],"blockquote",{},[360,808,809,810,813,814,817,818,821],{},"Kompleksitas waktu BFS adalah ",[769,811,812],{},"O(V + E)",", di mana ",[22,815,816],{},"V"," = simpul, ",[22,819,820],{},"E"," = sisi.",[753,823,825],{"id":824},"kesimpulan","Kesimpulan",[360,827,828,831],{},[769,829,830],{},"Breadth-First Search (BFS)"," adalah algoritma fundamental yang sangat berguna dalam berbagai aplikasi komputer, terutama ketika kita ingin mengeksplorasi data secara level-by-level atau mencari solusi tercepat.",[805,833,834],{},[360,835,836],{},"BFS sangat cocok untuk pencarian jalur terpendek dan eksplorasi yang merata, menjadikannya pelengkap ideal dari DFS.",[838,839,840],"style",{},"html pre.shiki code .sXvaJ, html code.shiki .sXvaJ{--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;--shiki-default:#79B8FF;--shiki-default-font-weight:bold;--shiki-light:#005CC5;--shiki-light-font-weight:bold}html pre.shiki code .s9_AW, html code.shiki .s9_AW{--shiki-dark:#E1E4E8;--shiki-dark-font-weight:bold;--shiki-default:#E1E4E8;--shiki-default-font-weight:bold;--shiki-light:#24292E;--shiki-light-font-weight:bold}html pre.shiki code .suVJd, html code.shiki .suVJd{--shiki-dark:#E1E4E8;--shiki-default:#E1E4E8;--shiki-light:#24292E}html pre.shiki code .scWFE, html code.shiki .scWFE{--shiki-dark:#85E89D;--shiki-default:#85E89D;--shiki-light:#22863A}html pre.shiki code .s1uPE, html code.shiki .s1uPE{--shiki-dark:#FFAB70;--shiki-default:#FFAB70;--shiki-light:#E36209}html pre.shiki code .sAPL1, html code.shiki .sAPL1{--shiki-dark:#79B8FF;--shiki-default:#79B8FF;--shiki-light:#005CC5}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}",{"title":20,"searchDepth":35,"depth":35,"links":842},[843,847],{"id":755,"depth":35,"text":756,"children":844},[845,846],{"id":760,"depth":42,"text":761},{"id":784,"depth":42,"text":785},{"id":824,"depth":35,"text":825},null,"BFS adalah algoritma penelusuran graf yang menjelajahi simpul tingkat demi tingkat, memastikan semua tetangga pada tingkat saat ini dikunjungi sebelum pindah ke tingkat berikutnya.",{"script":851},[852],{"type":853,"key":854,"data-nuxt-schema-org":38,"nodes":855},"application/ld+json","schema-org-graph",[856],{"_resolver":857},"webPage","/articles/4.jpeg",{},{"props":861},{},"/en/articles/breadth-firts-search",{"_resolver":857},{"title":5,"description":849},{"loc":862,"videos":866,"images":867,"lastmod":868},[],[],"2025-06-13T00:00:00.000Z","en/articles/breadth-firts-search",[],"7ANCLnUMcTjPRw2s8830PSNgjBhd9uZHLFOtocxqyX0",1750352580039]