[{"data":1,"prerenderedAt":9355},["ShallowReactive",2],{"/en/writing":3,"articles-en":36},{"id":4,"title":5,"body":6,"date":27,"description":23,"extension":28,"head":27,"meta":29,"navigation":30,"ogImage":27,"path":31,"robots":27,"schemaOrg":27,"seo":32,"sitemap":33,"stem":34,"__hash__":35},"content_en/en/3.writing.md","Writing",{"type":7,"value":8,"toc":24},"minimal",[9],[10,11,12,19],"writing",{},[13,14,16],"template",{"v-slot:title":15},"",[17,18,5],"p",{},[13,20,21],{"v-slot:subtitle":15},[17,22,23],{},"Some writings on topics that are close to my heart",{"title":15,"searchDepth":25,"depth":25,"links":26},2,[],null,"md",{},true,"/en/writing",{"title":5,"description":23},{"loc":31},"en/3.writing","VBhFPblhIs7ztqNmOXKNmg0rhNWTR1-BWkTC4h5gNAE",[37,1118,1800,2583,3450,4049,4652,5618,6549,7067,8062,8106,8885],{"id":38,"title":39,"body":40,"date":1104,"description":51,"extension":28,"head":27,"image":1105,"meta":1106,"navigation":30,"ogImage":27,"path":1107,"readingTime":1108,"robots":27,"schemaOrg":27,"seo":1109,"sitemap":1110,"stem":1111,"tags":1112,"__hash__":1117},"articles_en/en/articles/5-amazing-raycast-nuxt-snippets.md","5 Amazing Raycast Snippets for Enhancing Your Nuxt (Vue) Projects",{"type":7,"value":41,"toc":1088},[42,49,52,57,60,64,67,78,84,92,98,108,328,335,344,352,446,453,459,467,669,676,682,689,758,765,770,778,1049,1053,1058,1061,1065,1068,1072,1075,1079,1082,1085],[17,43,44],{},[45,46],"img",{"alt":47,"src":48},"preview","/articles/5-raycast-snippets.jpg",[17,50,51],{},"In the realm of web development, where efficiency is as valuable as expertise, tools that streamline and simplify our workflow are indispensable. Among these, Raycast snippets emerge as a powerful ally, especially for those working with Nuxt and Vue frameworks. But what exactly are these snippets, and how can they transform your development experience?",[53,54,56],"h2",{"id":55},"what-are-raycast-snippets","What Are Raycast Snippets?",[17,58,59],{},"Raycast snippets are small, reusable pieces of text or code that can be quickly inserted into your work. Think of them as shortcuts for frequently used content - whether it's code, canned email responses, or even emojis. They are designed to save time and reduce repetitive typing, allowing developers and writers to work more efficiently.",[53,61,63],{"id":62},"how-to-use-raycast-snippets","How to Use Raycast Snippets",[17,65,66],{},"Using Raycast snippets is straightforward. Once you've created or imported a snippet within the Raycast app, you can assign a specific keyword to it. This keyword acts as a trigger - whenever you type it in any application, the snippet will automatically expand in place, replacing the keyword with the full text or code of the snippet.",[17,68,69,70,74,75,77],{},"For instance, if you have a snippet for a standard email sign-off, you can assign a keyword like ",[71,72,73],"code",{},"sig1",". Typing ",[71,76,73],{}," in an email will then automatically expand to the full signature text. This feature is especially useful in coding, where you can have snippets for common code patterns or configurations.",[17,79,80],{},[45,81],{"alt":82,"src":83},"snippets-exemple","/articles/snippets-exemple.gif",[85,86,88,89],"h3",{"id":87},"component-template-comp","Component Template: ",[71,90,91],{},"!comp",[17,93,94,95,97],{},"The ",[71,96,91],{}," snippet is a basic yet powerful template for creating new Vue components. It includes a script setup with TypeScript support, a template section, and scoped styling. This snippet is ideal for rapidly scaffolding new components in your project.",[17,99,100,104,105,107],{},[101,102,103],"strong",{},"Usage Example:"," Use ",[71,106,91],{}," to quickly create new Vue components, ensuring consistency and saving time on setup.",[109,110,115],"pre",{"className":111,"code":112,"filename":113,"language":114,"meta":15,"style":15},"language-vue shiki shiki-themes github-dark github-dark github-light","\u003Cscript setup lang=\"ts\">\nimport type { PropType } from \"vue\";\n\nconst props = defineProps({\n item: {\n  type: String, \n  required: true\n }\n});\n\u003C/script>\n\n\u003Ctemplate>\n  \u003Cdiv>\n    \u003Ch1>{{ item }}\u003C/h1>\n  \u003C/div>\n\u003C/template>\n\n\u003Cstyle scoped>\n\n\u003C/style>\n","MyComponent.vue","vue",[71,116,117,147,168,174,193,199,205,214,220,226,236,241,250,261,277,287,296,301,314,319],{"__ignoreMap":15},[118,119,122,126,130,134,137,140,144],"span",{"class":120,"line":121},"line",1,[118,123,125],{"class":124},"suVJd","\u003C",[118,127,129],{"class":128},"scWFE","script",[118,131,133],{"class":132},"s9E-l"," setup",[118,135,136],{"class":132}," lang",[118,138,139],{"class":124},"=",[118,141,143],{"class":142},"sYTnl","\"ts\"",[118,145,146],{"class":124},">\n",[118,148,149,153,156,159,162,165],{"class":120,"line":25},[118,150,152],{"class":151},"sEiGg","import",[118,154,155],{"class":151}," type",[118,157,158],{"class":124}," { PropType } ",[118,160,161],{"class":151},"from",[118,163,164],{"class":142}," \"vue\"",[118,166,167],{"class":124},";\n",[118,169,171],{"class":120,"line":170},3,[118,172,173],{"emptyLinePlaceholder":30},"\n",[118,175,177,180,184,187,190],{"class":120,"line":176},4,[118,178,179],{"class":151},"const",[118,181,183],{"class":182},"sAPL1"," props",[118,185,186],{"class":151}," =",[118,188,189],{"class":132}," defineProps",[118,191,192],{"class":124},"({\n",[118,194,196],{"class":120,"line":195},5,[118,197,198],{"class":124}," item: {\n",[118,200,202],{"class":120,"line":201},6,[118,203,204],{"class":124},"  type: String, \n",[118,206,208,211],{"class":120,"line":207},7,[118,209,210],{"class":124},"  required: ",[118,212,213],{"class":182},"true\n",[118,215,217],{"class":120,"line":216},8,[118,218,219],{"class":124}," }\n",[118,221,223],{"class":120,"line":222},9,[118,224,225],{"class":124},"});\n",[118,227,229,232,234],{"class":120,"line":228},10,[118,230,231],{"class":124},"\u003C/",[118,233,129],{"class":128},[118,235,146],{"class":124},[118,237,239],{"class":120,"line":238},11,[118,240,173],{"emptyLinePlaceholder":30},[118,242,244,246,248],{"class":120,"line":243},12,[118,245,125],{"class":124},[118,247,13],{"class":128},[118,249,146],{"class":124},[118,251,253,256,259],{"class":120,"line":252},13,[118,254,255],{"class":124},"  \u003C",[118,257,258],{"class":128},"div",[118,260,146],{"class":124},[118,262,264,267,270,273,275],{"class":120,"line":263},14,[118,265,266],{"class":124},"    \u003C",[118,268,269],{"class":128},"h1",[118,271,272],{"class":124},">{{ item }}\u003C/",[118,274,269],{"class":128},[118,276,146],{"class":124},[118,278,280,283,285],{"class":120,"line":279},15,[118,281,282],{"class":124},"  \u003C/",[118,284,258],{"class":128},[118,286,146],{"class":124},[118,288,290,292,294],{"class":120,"line":289},16,[118,291,231],{"class":124},[118,293,13],{"class":128},[118,295,146],{"class":124},[118,297,299],{"class":120,"line":298},17,[118,300,173],{"emptyLinePlaceholder":30},[118,302,304,306,309,312],{"class":120,"line":303},18,[118,305,125],{"class":124},[118,307,308],{"class":128},"style",[118,310,311],{"class":132}," scoped",[118,313,146],{"class":124},[118,315,317],{"class":120,"line":316},19,[118,318,173],{"emptyLinePlaceholder":30},[118,320,322,324,326],{"class":120,"line":321},20,[118,323,231],{"class":124},[118,325,308],{"class":128},[118,327,146],{"class":124},[85,329,331,332],{"id":330},"api-handler-template-api","API Handler Template: ",[71,333,334],{},"!api",[17,336,337,338,340,341,343],{},"Handling API requests is a common task in modern web applications. The ",[71,339,334],{}," snippet provides a template for creating API handlers using ",[71,342,85],{},", a lightweight HTTP toolkit. This snippet streamlines the process of setting up API routes and handling requests.",[17,345,346,348,349,351],{},[101,347,103],{}," Implement the ",[71,350,334],{}," snippet for creating efficient API routes in your Nuxt application, especially when dealing with CRUD operations.",[109,353,358],{"className":354,"code":355,"filename":356,"language":357,"meta":15,"style":15},"language-ts shiki shiki-themes github-dark github-dark github-light","import { H3Event } from \"h3\";\n\nexport default defineEventHandler(async (event: H3Event) => {\n  const body = await readBody(event);\n  // your_api_logic\n});\n","~/server/api/MyHandler.ts","ts",[71,359,360,374,378,417,436,442],{"__ignoreMap":15},[118,361,362,364,367,369,372],{"class":120,"line":121},[118,363,152],{"class":151},[118,365,366],{"class":124}," { H3Event } ",[118,368,161],{"class":151},[118,370,371],{"class":142}," \"h3\"",[118,373,167],{"class":124},[118,375,376],{"class":120,"line":25},[118,377,173],{"emptyLinePlaceholder":30},[118,379,380,383,386,389,392,395,398,402,405,408,411,414],{"class":120,"line":170},[118,381,382],{"class":151},"export",[118,384,385],{"class":151}," default",[118,387,388],{"class":132}," defineEventHandler",[118,390,391],{"class":124},"(",[118,393,394],{"class":151},"async",[118,396,397],{"class":124}," (",[118,399,401],{"class":400},"s1uPE","event",[118,403,404],{"class":151},":",[118,406,407],{"class":132}," H3Event",[118,409,410],{"class":124},") ",[118,412,413],{"class":151},"=>",[118,415,416],{"class":124}," {\n",[118,418,419,422,425,427,430,433],{"class":120,"line":176},[118,420,421],{"class":151},"  const",[118,423,424],{"class":182}," body",[118,426,186],{"class":151},[118,428,429],{"class":151}," await",[118,431,432],{"class":132}," readBody",[118,434,435],{"class":124},"(event);\n",[118,437,438],{"class":120,"line":195},[118,439,441],{"class":440},"sOPP3","  // your_api_logic\n",[118,443,444],{"class":120,"line":201},[118,445,225],{"class":124},[85,447,449,450],{"id":448},"state-management-with-pinia-store","State Management with Pinia: ",[71,451,452],{},"!store",[17,454,455,456,458],{},"State management is crucial in large-scale applications. The ",[71,457,452],{}," snippet utilizes Pinia, a Vue store, offering a structured template for managing application state. It includes a state definition, getters, and actions.",[17,460,461,463,464,466],{},[101,462,103],{}," Utilize ",[71,465,452],{}," for setting up store modules in your Nuxt/Vue app, managing state more effectively and cleanly. the { clipboard } while be replaced by your actual clipboard.",[109,468,472],{"className":354,"code":469,"filename":470,"language":357,"meta":471,"style":15},"import { defineStore } from 'pinia';\n\ntype {clipboard}Store = { \n  count: number;\n} \n\nexport const use{clipboard}Store = defineStore('{clipboard}', {\n  state: (): {clipboard}Store => ({ \n    count: 0,\n  }), \n  getters: { \n    getCount(): number { \n      return this.count; \n    }\n  },\n  actions: { \n    increment() {\n      this.count++; \n    }, \n  } \n});\n","~/store/{clipboard}.ts","[~/store/.ts]",[71,473,474,488,492,502,507,512,516,542,570,581,586,591,606,617,622,627,632,640,654,659,664],{"__ignoreMap":15},[118,475,476,478,481,483,486],{"class":120,"line":121},[118,477,152],{"class":151},[118,479,480],{"class":124}," { defineStore } ",[118,482,161],{"class":151},[118,484,485],{"class":142}," 'pinia'",[118,487,167],{"class":124},[118,489,490],{"class":120,"line":25},[118,491,173],{"emptyLinePlaceholder":30},[118,493,494,497,499],{"class":120,"line":170},[118,495,496],{"class":124},"type {clipboard}Store ",[118,498,139],{"class":151},[118,500,501],{"class":124}," { \n",[118,503,504],{"class":120,"line":176},[118,505,506],{"class":124},"  count: number;\n",[118,508,509],{"class":120,"line":195},[118,510,511],{"class":124},"} \n",[118,513,514],{"class":120,"line":201},[118,515,173],{"emptyLinePlaceholder":30},[118,517,518,520,523,526,529,531,534,536,539],{"class":120,"line":207},[118,519,382],{"class":151},[118,521,522],{"class":151}," const",[118,524,525],{"class":182}," use",[118,527,528],{"class":124},"{clipboard}Store ",[118,530,139],{"class":151},[118,532,533],{"class":132}," defineStore",[118,535,391],{"class":124},[118,537,538],{"class":142},"'{clipboard}'",[118,540,541],{"class":124},", {\n",[118,543,544,547,550,552,555,558,561,564,567],{"class":120,"line":216},[118,545,546],{"class":132},"  state",[118,548,549],{"class":124},": ()",[118,551,404],{"class":151},[118,553,554],{"class":124}," {",[118,556,557],{"class":400},"clipboard",[118,559,560],{"class":124},"}",[118,562,563],{"class":132},"Store",[118,565,566],{"class":151}," =>",[118,568,569],{"class":124}," ({ \n",[118,571,572,575,578],{"class":120,"line":222},[118,573,574],{"class":124},"    count: ",[118,576,577],{"class":182},"0",[118,579,580],{"class":124},",\n",[118,582,583],{"class":120,"line":228},[118,584,585],{"class":124},"  }), \n",[118,587,588],{"class":120,"line":238},[118,589,590],{"class":124},"  getters: { \n",[118,592,593,596,599,601,604],{"class":120,"line":243},[118,594,595],{"class":132},"    getCount",[118,597,598],{"class":124},"()",[118,600,404],{"class":151},[118,602,603],{"class":182}," number",[118,605,501],{"class":124},[118,607,608,611,614],{"class":120,"line":252},[118,609,610],{"class":151},"      return",[118,612,613],{"class":182}," this",[118,615,616],{"class":124},".count; \n",[118,618,619],{"class":120,"line":263},[118,620,621],{"class":124},"    }\n",[118,623,624],{"class":120,"line":279},[118,625,626],{"class":124},"  },\n",[118,628,629],{"class":120,"line":289},[118,630,631],{"class":124},"  actions: { \n",[118,633,634,637],{"class":120,"line":298},[118,635,636],{"class":132},"    increment",[118,638,639],{"class":124},"() {\n",[118,641,642,645,648,651],{"class":120,"line":303},[118,643,644],{"class":182},"      this",[118,646,647],{"class":124},".count",[118,649,650],{"class":151},"++",[118,652,653],{"class":124},"; \n",[118,655,656],{"class":120,"line":316},[118,657,658],{"class":124},"    }, \n",[118,660,661],{"class":120,"line":321},[118,662,663],{"class":124},"  } \n",[118,665,667],{"class":120,"line":666},21,[118,668,225],{"class":124},[85,670,672,673],{"id":671},"composable-function-template-cps","Composable Function Template: ",[71,674,675],{},"!cps",[17,677,678,679,681],{},"Composable functions in Vue 3 bring reusability and organization to your code. The ",[71,680,675],{}," snippet offers a template for creating these functions, aiding in maintaining a clean and modular codebase.",[17,683,684,104,686,688],{},[101,685,103],{},[71,687,675],{}," for creating reusable composable functions that can be shared across components, enhancing code reusability and maintainability.",[109,690,693],{"className":354,"code":691,"filename":692,"language":357,"meta":15,"style":15},"export function use{clipboard}() {\n  const {clipboard} = ref(null);\n  \n  // Composable logic\n  \n  return { {clipboard} };\n}\n","~/composables/useComposables.ts",[71,694,695,707,731,736,741,745,753],{"__ignoreMap":15},[118,696,697,699,702,704],{"class":120,"line":121},[118,698,382],{"class":151},[118,700,701],{"class":151}," function",[118,703,525],{"class":132},[118,705,706],{"class":124},"{clipboard}() {\n",[118,708,709,711,713,715,718,720,723,725,728],{"class":120,"line":25},[118,710,421],{"class":151},[118,712,554],{"class":124},[118,714,557],{"class":182},[118,716,717],{"class":124},"} ",[118,719,139],{"class":151},[118,721,722],{"class":132}," ref",[118,724,391],{"class":124},[118,726,727],{"class":182},"null",[118,729,730],{"class":124},");\n",[118,732,733],{"class":120,"line":170},[118,734,735],{"class":124},"  \n",[118,737,738],{"class":120,"line":176},[118,739,740],{"class":440},"  // Composable logic\n",[118,742,743],{"class":120,"line":195},[118,744,735],{"class":124},[118,746,747,750],{"class":120,"line":201},[118,748,749],{"class":151},"  return",[118,751,752],{"class":124}," { {clipboard} };\n",[118,754,755],{"class":120,"line":207},[118,756,757],{"class":124},"}\n",[85,759,761,762],{"id":760},"fetching-data-with-composition-api-fcomp","Fetching Data with Composition API: ",[71,763,764],{},"!fcomp",[17,766,94,767,769],{},[71,768,764],{}," snippet is designed for fetching data using Vue's Composition API. It provides a setup for making HTTP requests, handling loading states, and managing errors, all within a component.",[17,771,772,774,775,777],{},[101,773,103],{}," Implement ",[71,776,764],{}," in scenarios where you need to fetch data from an API, providing a robust structure for data fetching and state management.",[109,779,781],{"className":111,"code":780,"filename":113,"language":114,"meta":15,"style":15},"\u003Cscript setup lang=\"ts\">\nconst { data, pending, error, refresh } = useFetch(\"your_url\", { \n  immediate: false,\n  watch: false,\n});\n\nfunction loadData() {\n  await refresh();\n}\n\u003C/script>\n\n\u003Ctemplate>\n  \u003Cdiv>\n    \u003Cbutton @click=\"loadData\">Load Data\u003C/button>\n    \u003Cdiv v-if=\"pending\">Loading...\u003C/div>\n    \u003Cdiv v-if=\"error\">{{ error }}\u003C/div>\n    \u003Cdiv v-if=\"data\">{{ data }}\u003C/div>\n  \u003C/div>\n\u003C/template>\n\n\u003Cstyle scoped>\n/* composant styles */\n\u003C/style>\n",[71,782,783,799,841,851,860,864,868,878,889,893,901,905,913,921,943,964,984,1004,1012,1020,1024,1034,1040],{"__ignoreMap":15},[118,784,785,787,789,791,793,795,797],{"class":120,"line":121},[118,786,125],{"class":124},[118,788,129],{"class":128},[118,790,133],{"class":132},[118,792,136],{"class":132},[118,794,139],{"class":124},[118,796,143],{"class":142},[118,798,146],{"class":124},[118,800,801,803,806,809,812,815,817,820,822,825,828,830,833,835,838],{"class":120,"line":25},[118,802,179],{"class":151},[118,804,805],{"class":124}," { ",[118,807,808],{"class":182},"data",[118,810,811],{"class":124},", ",[118,813,814],{"class":182},"pending",[118,816,811],{"class":124},[118,818,819],{"class":182},"error",[118,821,811],{"class":124},[118,823,824],{"class":182},"refresh",[118,826,827],{"class":124}," } ",[118,829,139],{"class":151},[118,831,832],{"class":132}," useFetch",[118,834,391],{"class":124},[118,836,837],{"class":142},"\"your_url\"",[118,839,840],{"class":124},", { \n",[118,842,843,846,849],{"class":120,"line":170},[118,844,845],{"class":124},"  immediate: ",[118,847,848],{"class":182},"false",[118,850,580],{"class":124},[118,852,853,856,858],{"class":120,"line":176},[118,854,855],{"class":124},"  watch: ",[118,857,848],{"class":182},[118,859,580],{"class":124},[118,861,862],{"class":120,"line":195},[118,863,225],{"class":124},[118,865,866],{"class":120,"line":201},[118,867,173],{"emptyLinePlaceholder":30},[118,869,870,873,876],{"class":120,"line":207},[118,871,872],{"class":151},"function",[118,874,875],{"class":132}," loadData",[118,877,639],{"class":124},[118,879,880,883,886],{"class":120,"line":216},[118,881,882],{"class":151},"  await",[118,884,885],{"class":132}," refresh",[118,887,888],{"class":124},"();\n",[118,890,891],{"class":120,"line":222},[118,892,757],{"class":124},[118,894,895,897,899],{"class":120,"line":228},[118,896,231],{"class":124},[118,898,129],{"class":128},[118,900,146],{"class":124},[118,902,903],{"class":120,"line":238},[118,904,173],{"emptyLinePlaceholder":30},[118,906,907,909,911],{"class":120,"line":243},[118,908,125],{"class":124},[118,910,13],{"class":128},[118,912,146],{"class":124},[118,914,915,917,919],{"class":120,"line":252},[118,916,255],{"class":124},[118,918,258],{"class":128},[118,920,146],{"class":124},[118,922,923,925,928,931,933,936,939,941],{"class":120,"line":263},[118,924,266],{"class":124},[118,926,927],{"class":128},"button",[118,929,930],{"class":132}," @click",[118,932,139],{"class":124},[118,934,935],{"class":142},"\"loadData\"",[118,937,938],{"class":124},">Load Data\u003C/",[118,940,927],{"class":128},[118,942,146],{"class":124},[118,944,945,947,949,952,954,957,960,962],{"class":120,"line":279},[118,946,266],{"class":124},[118,948,258],{"class":128},[118,950,951],{"class":132}," v-if",[118,953,139],{"class":124},[118,955,956],{"class":142},"\"pending\"",[118,958,959],{"class":124},">Loading...\u003C/",[118,961,258],{"class":128},[118,963,146],{"class":124},[118,965,966,968,970,972,974,977,980,982],{"class":120,"line":289},[118,967,266],{"class":124},[118,969,258],{"class":128},[118,971,951],{"class":132},[118,973,139],{"class":124},[118,975,976],{"class":142},"\"error\"",[118,978,979],{"class":124},">{{ error }}\u003C/",[118,981,258],{"class":128},[118,983,146],{"class":124},[118,985,986,988,990,992,994,997,1000,1002],{"class":120,"line":298},[118,987,266],{"class":124},[118,989,258],{"class":128},[118,991,951],{"class":132},[118,993,139],{"class":124},[118,995,996],{"class":142},"\"data\"",[118,998,999],{"class":124},">{{ data }}\u003C/",[118,1001,258],{"class":128},[118,1003,146],{"class":124},[118,1005,1006,1008,1010],{"class":120,"line":303},[118,1007,282],{"class":124},[118,1009,258],{"class":128},[118,1011,146],{"class":124},[118,1013,1014,1016,1018],{"class":120,"line":316},[118,1015,231],{"class":124},[118,1017,13],{"class":128},[118,1019,146],{"class":124},[118,1021,1022],{"class":120,"line":321},[118,1023,173],{"emptyLinePlaceholder":30},[118,1025,1026,1028,1030,1032],{"class":120,"line":666},[118,1027,125],{"class":124},[118,1029,308],{"class":128},[118,1031,311],{"class":132},[118,1033,146],{"class":124},[118,1035,1037],{"class":120,"line":1036},22,[118,1038,1039],{"class":440},"/* composant styles */\n",[118,1041,1043,1045,1047],{"class":120,"line":1042},23,[118,1044,231],{"class":124},[118,1046,308],{"class":128},[118,1048,146],{"class":124},[85,1050,1052],{"id":1051},"why-use-these-snippets","Why Use These Snippets?",[1054,1055,1057],"h4",{"id":1056},"enhance-productivity","Enhance Productivity",[17,1059,1060],{},"Raycast snippets save time and effort by providing ready-to-use code templates, allowing you to focus on the unique aspects of your project.",[1054,1062,1064],{"id":1063},"maintain-consistency","Maintain Consistency",[17,1066,1067],{},"Using standardized snippets ensures consistency across your codebase, making it easier to read, maintain, and collaborate on.",[1054,1069,1071],{"id":1070},"streamline-development","Streamline Development",[17,1073,1074],{},"Snippets cater to common development tasks, streamlining your workflow and reducing the likelihood of errors or oversights.",[1054,1076,1078],{"id":1077},"foster-learning","Foster Learning",[17,1080,1081],{},"For new developers or those new to Nuxt and Vue, these snippets offer insight into best practices and efficient coding patterns.",[17,1083,1084],{},"In conclusion, incorporating these Raycast snippets into your Nuxt and Vue development workflow can significantly enhance productivity, maintain code consistency, and streamline your development process. Whether you're building a small project or a large-scale application, these snippets are invaluable tools in the modern developer's arsenal.",[308,1086,1087],{},"html pre.shiki code .suVJd, html code.shiki .suVJd{--shiki-dark:#E1E4E8;--shiki-default:#E1E4E8;--shiki-light:#24292E}html pre.shiki code .scWFE, html code.shiki .scWFE{--shiki-dark:#85E89D;--shiki-default:#85E89D;--shiki-light:#22863A}html pre.shiki code .s9E-l, html code.shiki .s9E-l{--shiki-dark:#B392F0;--shiki-default:#B392F0;--shiki-light:#6F42C1}html pre.shiki code .sYTnl, html code.shiki .sYTnl{--shiki-dark:#9ECBFF;--shiki-default:#9ECBFF;--shiki-light:#032F62}html pre.shiki code .sEiGg, html code.shiki .sEiGg{--shiki-dark:#F97583;--shiki-default:#F97583;--shiki-light:#D73A49}html pre.shiki code .sAPL1, html code.shiki .sAPL1{--shiki-dark:#79B8FF;--shiki-default:#79B8FF;--shiki-light:#005CC5}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html pre.shiki code .s1uPE, html code.shiki .s1uPE{--shiki-dark:#FFAB70;--shiki-default:#FFAB70;--shiki-light:#E36209}html pre.shiki code .sOPP3, html code.shiki .sOPP3{--shiki-dark:#6A737D;--shiki-default:#6A737D;--shiki-light:#6A737D}",{"title":15,"searchDepth":25,"depth":25,"links":1089},[1090,1091],{"id":55,"depth":25,"text":56},{"id":62,"depth":25,"text":63,"children":1092},[1093,1095,1097,1099,1101,1103],{"id":87,"depth":170,"text":1094},"Component Template: !comp",{"id":330,"depth":170,"text":1096},"API Handler Template: !api",{"id":448,"depth":170,"text":1098},"State Management with Pinia: !store",{"id":671,"depth":170,"text":1100},"Composable Function Template: !cps",{"id":760,"depth":170,"text":1102},"Fetching Data with Composition API: !fcomp",{"id":1051,"depth":170,"text":1052},"22/01/2024","https://canvas.hrcd.fr/articles/5-raycast-snippets.jpg",{},"/en/articles/5-amazing-raycast-nuxt-snippets","10",{"title":39,"description":51},{"loc":1107},"en/articles/5-amazing-raycast-nuxt-snippets",[1113,1114,1115,1116],"Nuxt","Vue","Raycast","Productivity","DvWjZ-Za5rsz15ju2kBY-ofMipMfYZO7AORuAVmlTgE",{"id":1119,"title":1120,"body":1121,"date":27,"description":1777,"extension":28,"head":1778,"image":1786,"meta":1787,"navigation":30,"ogImage":1788,"path":1790,"readingTime":27,"robots":27,"schemaOrg":1791,"seo":1792,"sitemap":1793,"stem":1797,"tags":1798,"__hash__":1799},"articles_en/en/articles/activity-promblem-selection.md","Memahami Activity Selection Problem",{"type":7,"value":1122,"toc":1764},[1123,1127,1530,1534,1640,1644,1651,1658,1665,1670,1674,1687,1691,1708,1712,1729,1733,1751,1761],[269,1124,1126],{"id":1125},"activity-promblem-selection","ACTIVITY PROMBLEM SELECTION",[109,1128,1132],{"className":1129,"code":1130,"language":1131,"meta":15,"style":15},"language-markdown shiki shiki-themes github-dark github-dark github-light","# ğŸ—“ï¸ Apa itu Activity Selection Problem?\n\n**Activity Selection Problem** adalah masalah optimisasi klasik dalam ilmu komputer. Tujuannya adalah untuk **memilih sebanyak mungkin aktivitas** dari himpunan yang diberikan **tanpa ada yang saling tumpang tindih**, dengan setiap aktivitas memiliki waktu mulai dan selesai.\n\nğŸ§  Masalah ini diselesaikan menggunakan pendekatan **greedy**, yang memilih aktivitas dengan **waktu selesai paling awal** terlebih dahulu.\n\n---\n\n## ğŸ“Œ Aplikasi Nyata\n\n- ğŸ“… Penjadwalan rapat atau kelas dalam satu ruangan\n- ğŸ§‘â€ğŸ’¼ Manajemen tugas dalam satu waktu kerja\n- ğŸ–¥ï¸ Penjadwalan proses di CPU\n- ğŸŒ Alokasi bandwidth di jaringan\n\n---\n\n## ğŸ”§ Cara Kerja Algoritma Greedy\n\n1. **Urutkan aktivitas** berdasarkan waktu selesai secara ascending.\n2. **Pilih aktivitas pertama** (dengan waktu selesai paling awal).\n3. Tandai waktu selesai aktivitas ini sebagai batas terakhir.\n4. Untuk setiap aktivitas berikutnya:\n   - Jika waktu mulai â‰¥ batas terakhir â†’ pilih aktivitas\n   - Perbarui batas terakhir menjadi waktu selesai aktivitas tersebut.\n\nğŸ“ˆ Algoritma ini **menjamin jumlah maksimal aktivitas** yang dapat dipilih **tanpa konflik**.\n\n---\n\n## ğŸ§® Contoh Permasalahan\n\n### Daftar Aktivitas\n\n| Aktivitas | Mulai | Selesai |\n|-----------|--------|---------|\n| A1        | 1      | 4       |\n| A2        | 3      | 5       |\n| A3        | 5      | 7       |\n| A4        | 3      | 8       |\n| A5        | 8      | 9       |\n\n### Langkah Solusi:\n\n1. Urutkan: A1(4), A2(5), A3(7), A4(8), A5(9)\n2. Pilih A1 (selesai jam 4)\n3. Lewati A2 & A4 (karena mulai \u003C 4)\n4. Pilih A3 (mulai jam 5)\n5. Pilih A5 (mulai jam 8)\n\nâœ… **Solusi:** A1, A3, A5\n\n---\n\n## ğŸ Implementasi Python\n\n```python\ndef activity_selection(start, finish):\n    activities = sorted(zip(start, finish), key=lambda x: x[1])\n    result = []\n    last_finish_time = -1\n\n    for s, f in activities:\n        if s >= last_finish_time:\n            result.append((s, f))\n            last_finish_time = f\n\n    return result\n\n# Contoh penggunaan\nstart = [1, 3, 5, 3, 8]\nfinish = [4, 5, 7, 8, 9]\nselected = activity_selection(start, finish)\nprint(\"Aktivitas yang dipilih:\", selected)\n","markdown",[71,1133,1134,1139,1143,1148,1152,1157,1161,1166,1170,1175,1179,1184,1189,1194,1199,1203,1207,1211,1216,1220,1225,1230,1235,1240,1246,1252,1257,1263,1268,1273,1278,1284,1289,1295,1300,1306,1312,1318,1324,1330,1336,1342,1347,1353,1358,1364,1370,1376,1382,1388,1393,1399,1404,1409,1414,1420,1425,1431,1437,1443,1449,1455,1460,1466,1472,1478,1484,1489,1495,1500,1506,1512,1518,1524],{"__ignoreMap":15},[118,1135,1136],{"class":120,"line":121},[118,1137,1138],{},"# ğŸ—“ï¸ Apa itu Activity Selection Problem?\n",[118,1140,1141],{"class":120,"line":25},[118,1142,173],{"emptyLinePlaceholder":30},[118,1144,1145],{"class":120,"line":170},[118,1146,1147],{},"**Activity Selection Problem** adalah masalah optimisasi klasik dalam ilmu komputer. Tujuannya adalah untuk **memilih sebanyak mungkin aktivitas** dari himpunan yang diberikan **tanpa ada yang saling tumpang tindih**, dengan setiap aktivitas memiliki waktu mulai dan selesai.\n",[118,1149,1150],{"class":120,"line":176},[118,1151,173],{"emptyLinePlaceholder":30},[118,1153,1154],{"class":120,"line":195},[118,1155,1156],{},"ğŸ§  Masalah ini diselesaikan menggunakan pendekatan **greedy**, yang memilih aktivitas dengan **waktu selesai paling awal** terlebih dahulu.\n",[118,1158,1159],{"class":120,"line":201},[118,1160,173],{"emptyLinePlaceholder":30},[118,1162,1163],{"class":120,"line":207},[118,1164,1165],{},"---\n",[118,1167,1168],{"class":120,"line":216},[118,1169,173],{"emptyLinePlaceholder":30},[118,1171,1172],{"class":120,"line":222},[118,1173,1174],{},"## ğŸ“Œ Aplikasi Nyata\n",[118,1176,1177],{"class":120,"line":228},[118,1178,173],{"emptyLinePlaceholder":30},[118,1180,1181],{"class":120,"line":238},[118,1182,1183],{},"- ğŸ“… Penjadwalan rapat atau kelas dalam satu ruangan\n",[118,1185,1186],{"class":120,"line":243},[118,1187,1188],{},"- ğŸ§‘â€ğŸ’¼ Manajemen tugas dalam satu waktu kerja\n",[118,1190,1191],{"class":120,"line":252},[118,1192,1193],{},"- ğŸ–¥ï¸ Penjadwalan proses di CPU\n",[118,1195,1196],{"class":120,"line":263},[118,1197,1198],{},"- ğŸŒ Alokasi bandwidth di jaringan\n",[118,1200,1201],{"class":120,"line":279},[118,1202,173],{"emptyLinePlaceholder":30},[118,1204,1205],{"class":120,"line":289},[118,1206,1165],{},[118,1208,1209],{"class":120,"line":298},[118,1210,173],{"emptyLinePlaceholder":30},[118,1212,1213],{"class":120,"line":303},[118,1214,1215],{},"## ğŸ”§ Cara Kerja Algoritma Greedy\n",[118,1217,1218],{"class":120,"line":316},[118,1219,173],{"emptyLinePlaceholder":30},[118,1221,1222],{"class":120,"line":321},[118,1223,1224],{},"1. **Urutkan aktivitas** berdasarkan waktu selesai secara ascending.\n",[118,1226,1227],{"class":120,"line":666},[118,1228,1229],{},"2. **Pilih aktivitas pertama** (dengan waktu selesai paling awal).\n",[118,1231,1232],{"class":120,"line":1036},[118,1233,1234],{},"3. Tandai waktu selesai aktivitas ini sebagai batas terakhir.\n",[118,1236,1237],{"class":120,"line":1042},[118,1238,1239],{},"4. Untuk setiap aktivitas berikutnya:\n",[118,1241,1243],{"class":120,"line":1242},24,[118,1244,1245],{},"   - Jika waktu mulai â‰¥ batas terakhir â†’ pilih aktivitas\n",[118,1247,1249],{"class":120,"line":1248},25,[118,1250,1251],{},"   - Perbarui batas terakhir menjadi waktu selesai aktivitas tersebut.\n",[118,1253,1255],{"class":120,"line":1254},26,[118,1256,173],{"emptyLinePlaceholder":30},[118,1258,1260],{"class":120,"line":1259},27,[118,1261,1262],{},"ğŸ“ˆ Algoritma ini **menjamin jumlah maksimal aktivitas** yang dapat dipilih **tanpa konflik**.\n",[118,1264,1266],{"class":120,"line":1265},28,[118,1267,173],{"emptyLinePlaceholder":30},[118,1269,1271],{"class":120,"line":1270},29,[118,1272,1165],{},[118,1274,1276],{"class":120,"line":1275},30,[118,1277,173],{"emptyLinePlaceholder":30},[118,1279,1281],{"class":120,"line":1280},31,[118,1282,1283],{},"## ğŸ§® Contoh Permasalahan\n",[118,1285,1287],{"class":120,"line":1286},32,[118,1288,173],{"emptyLinePlaceholder":30},[118,1290,1292],{"class":120,"line":1291},33,[118,1293,1294],{},"### Daftar Aktivitas\n",[118,1296,1298],{"class":120,"line":1297},34,[118,1299,173],{"emptyLinePlaceholder":30},[118,1301,1303],{"class":120,"line":1302},35,[118,1304,1305],{},"| Aktivitas | Mulai | Selesai |\n",[118,1307,1309],{"class":120,"line":1308},36,[118,1310,1311],{},"|-----------|--------|---------|\n",[118,1313,1315],{"class":120,"line":1314},37,[118,1316,1317],{},"| A1        | 1      | 4       |\n",[118,1319,1321],{"class":120,"line":1320},38,[118,1322,1323],{},"| A2        | 3      | 5       |\n",[118,1325,1327],{"class":120,"line":1326},39,[118,1328,1329],{},"| A3        | 5      | 7       |\n",[118,1331,1333],{"class":120,"line":1332},40,[118,1334,1335],{},"| A4        | 3      | 8       |\n",[118,1337,1339],{"class":120,"line":1338},41,[118,1340,1341],{},"| A5        | 8      | 9       |\n",[118,1343,1345],{"class":120,"line":1344},42,[118,1346,173],{"emptyLinePlaceholder":30},[118,1348,1350],{"class":120,"line":1349},43,[118,1351,1352],{},"### Langkah Solusi:\n",[118,1354,1356],{"class":120,"line":1355},44,[118,1357,173],{"emptyLinePlaceholder":30},[118,1359,1361],{"class":120,"line":1360},45,[118,1362,1363],{},"1. Urutkan: A1(4), A2(5), A3(7), A4(8), A5(9)\n",[118,1365,1367],{"class":120,"line":1366},46,[118,1368,1369],{},"2. Pilih A1 (selesai jam 4)\n",[118,1371,1373],{"class":120,"line":1372},47,[118,1374,1375],{},"3. Lewati A2 & A4 (karena mulai \u003C 4)\n",[118,1377,1379],{"class":120,"line":1378},48,[118,1380,1381],{},"4. Pilih A3 (mulai jam 5)\n",[118,1383,1385],{"class":120,"line":1384},49,[118,1386,1387],{},"5. Pilih A5 (mulai jam 8)\n",[118,1389,1391],{"class":120,"line":1390},50,[118,1392,173],{"emptyLinePlaceholder":30},[118,1394,1396],{"class":120,"line":1395},51,[118,1397,1398],{},"âœ… **Solusi:** A1, A3, A5\n",[118,1400,1402],{"class":120,"line":1401},52,[118,1403,173],{"emptyLinePlaceholder":30},[118,1405,1407],{"class":120,"line":1406},53,[118,1408,1165],{},[118,1410,1412],{"class":120,"line":1411},54,[118,1413,173],{"emptyLinePlaceholder":30},[118,1415,1417],{"class":120,"line":1416},55,[118,1418,1419],{},"## ğŸ Implementasi Python\n",[118,1421,1423],{"class":120,"line":1422},56,[118,1424,173],{"emptyLinePlaceholder":30},[118,1426,1428],{"class":120,"line":1427},57,[118,1429,1430],{},"```python\n",[118,1432,1434],{"class":120,"line":1433},58,[118,1435,1436],{},"def activity_selection(start, finish):\n",[118,1438,1440],{"class":120,"line":1439},59,[118,1441,1442],{},"    activities = sorted(zip(start, finish), key=lambda x: x[1])\n",[118,1444,1446],{"class":120,"line":1445},60,[118,1447,1448],{},"    result = []\n",[118,1450,1452],{"class":120,"line":1451},61,[118,1453,1454],{},"    last_finish_time = -1\n",[118,1456,1458],{"class":120,"line":1457},62,[118,1459,173],{"emptyLinePlaceholder":30},[118,1461,1463],{"class":120,"line":1462},63,[118,1464,1465],{},"    for s, f in activities:\n",[118,1467,1469],{"class":120,"line":1468},64,[118,1470,1471],{},"        if s >= last_finish_time:\n",[118,1473,1475],{"class":120,"line":1474},65,[118,1476,1477],{},"            result.append((s, f))\n",[118,1479,1481],{"class":120,"line":1480},66,[118,1482,1483],{},"            last_finish_time = f\n",[118,1485,1487],{"class":120,"line":1486},67,[118,1488,173],{"emptyLinePlaceholder":30},[118,1490,1492],{"class":120,"line":1491},68,[118,1493,1494],{},"    return result\n",[118,1496,1498],{"class":120,"line":1497},69,[118,1499,173],{"emptyLinePlaceholder":30},[118,1501,1503],{"class":120,"line":1502},70,[118,1504,1505],{},"# Contoh penggunaan\n",[118,1507,1509],{"class":120,"line":1508},71,[118,1510,1511],{},"start = [1, 3, 5, 3, 8]\n",[118,1513,1515],{"class":120,"line":1514},72,[118,1516,1517],{},"finish = [4, 5, 7, 8, 9]\n",[118,1519,1521],{"class":120,"line":1520},73,[118,1522,1523],{},"selected = activity_selection(start, finish)\n",[118,1525,1527],{"class":120,"line":1526},74,[118,1528,1529],{},"print(\"Aktivitas yang dipilih:\", selected)\n",[53,1531,1533],{"id":1532},"ï¸-implementasi-javascript","ğŸ–¥ï¸ Implementasi JavaScript",[109,1535,1539],{"className":1536,"code":1537,"language":1538,"meta":15,"style":15},"language-javascript shiki shiki-themes github-dark github-dark github-light","function activitySelection(start, finish) {\n    const activities = start.map((s, i) => ({ start: s, finish: finish[i] }));\n    activities.sort((a, b) => a.finish - b.finish);\n\n    const result = [];\n    let lastFinish = -1;\n\n    for (let act of activities) {\n        if (act.start >= lastFinish) {\n            result.push(act);\n            lastFinish = act.finish;\n        }\n    }\n\n    return result;\n}\n\n// Contoh penggunaan\nconst start = [1, 3, 5, 3, 8];\nconst finish = [4, 5, 7, 8, 9];\nconsole.log(\"Aktivitas yang dipilih:\", activitySelection(start, finish));\n","javascript",[71,1540,1541,1546,1551,1556,1560,1565,1570,1574,1579,1584,1589,1594,1599,1603,1607,1612,1616,1620,1625,1630,1635],{"__ignoreMap":15},[118,1542,1543],{"class":120,"line":121},[118,1544,1545],{},"function activitySelection(start, finish) {\n",[118,1547,1548],{"class":120,"line":25},[118,1549,1550],{},"    const activities = start.map((s, i) => ({ start: s, finish: finish[i] }));\n",[118,1552,1553],{"class":120,"line":170},[118,1554,1555],{},"    activities.sort((a, b) => a.finish - b.finish);\n",[118,1557,1558],{"class":120,"line":176},[118,1559,173],{"emptyLinePlaceholder":30},[118,1561,1562],{"class":120,"line":195},[118,1563,1564],{},"    const result = [];\n",[118,1566,1567],{"class":120,"line":201},[118,1568,1569],{},"    let lastFinish = -1;\n",[118,1571,1572],{"class":120,"line":207},[118,1573,173],{"emptyLinePlaceholder":30},[118,1575,1576],{"class":120,"line":216},[118,1577,1578],{},"    for (let act of activities) {\n",[118,1580,1581],{"class":120,"line":222},[118,1582,1583],{},"        if (act.start >= lastFinish) {\n",[118,1585,1586],{"class":120,"line":228},[118,1587,1588],{},"            result.push(act);\n",[118,1590,1591],{"class":120,"line":238},[118,1592,1593],{},"            lastFinish = act.finish;\n",[118,1595,1596],{"class":120,"line":243},[118,1597,1598],{},"        }\n",[118,1600,1601],{"class":120,"line":252},[118,1602,621],{},[118,1604,1605],{"class":120,"line":263},[118,1606,173],{"emptyLinePlaceholder":30},[118,1608,1609],{"class":120,"line":279},[118,1610,1611],{},"    return result;\n",[118,1613,1614],{"class":120,"line":289},[118,1615,757],{},[118,1617,1618],{"class":120,"line":298},[118,1619,173],{"emptyLinePlaceholder":30},[118,1621,1622],{"class":120,"line":303},[118,1623,1624],{},"// Contoh penggunaan\n",[118,1626,1627],{"class":120,"line":316},[118,1628,1629],{},"const start = [1, 3, 5, 3, 8];\n",[118,1631,1632],{"class":120,"line":321},[118,1633,1634],{},"const finish = [4, 5, 7, 8, 9];\n",[118,1636,1637],{"class":120,"line":666},[118,1638,1639],{},"console.log(\"Aktivitas yang dipilih:\", activitySelection(start, finish));\n",[53,1641,1643],{"id":1642},"ï¸-kompleksitas-optimasi","â±ï¸ Kompleksitas & Optimasi",[85,1645,1647,1648],{"id":1646},"waktu-on-log-n","â³ Waktu: ",[71,1649,1650],{},"O(n log n)",[1652,1653,1654],"ul",{},[1655,1656,1657],"li",{},"Karena proses pengurutan berdasarkan waktu selesai",[85,1659,1661,1662],{"id":1660},"ruang-on","ğŸ’¾ Ruang: ",[71,1663,1664],{},"O(n)",[1652,1666,1667],{},[1655,1668,1669],{},"Untuk menyimpan aktivitas yang diurutkan dan hasil",[85,1671,1673],{"id":1672},"optimasi","âš¡ Optimasi:",[1652,1675,1676,1681,1684],{},[1655,1677,1678,1679],{},"Pre-sorting jika data sudah urut â†’ ",[71,1680,1664],{},[1655,1682,1683],{},"In-place sorting â†’ hemat memori",[1655,1685,1686],{},"Penggunaan struktur data efisien untuk jumlah besar aktivitas",[53,1688,1690],{"id":1689},"kelebihan","âœ… Kelebihan",[1652,1692,1693,1699,1705],{},[1655,1694,1695,1696],{},"ğŸ§  ",[101,1697,1698],{},"Sederhana & intuitif",[1655,1700,1701,1702],{},"ğŸš€ ",[101,1703,1704],{},"Cepat & efisien",[1655,1706,1707],{},"ğŸ“š Cocok untuk pembelajaran algoritma greedy",[53,1709,1711],{"id":1710},"kekurangan","âŒ Kekurangan",[1652,1713,1714,1720,1723],{},[1655,1715,1716,1717],{},"Tidak mendukung ",[101,1718,1719],{},"aktivitas yang overlap sebagian",[1655,1721,1722],{},"Tidak optimal jika kriteria bukan waktu selesai",[1655,1724,1725,1726],{},"Memerlukan ",[101,1727,1728],{},"pengurutan awal",[53,1730,1732],{"id":1731},"kesimpulan","ğŸ¯ Kesimpulan",[17,1734,1735,1738,1739,1742,1743,1746,1747,1750],{},[101,1736,1737],{},"Activity Selection Problem"," adalah contoh klasik dari algoritma ",[101,1740,1741],{},"greedy"," yang bekerja sangat baik pada masalah ",[101,1744,1745],{},"penjadwalan",". Dengan memilih aktivitas berdasarkan waktu selesai paling cepat, kita dapat menjadwalkan aktivitas sebanyak mungkin ",[101,1748,1749],{},"tanpa konflik",".",[1752,1753,1754],"blockquote",{},[17,1755,1756,1757],{},"ğŸ” ",[1758,1759,1760],"em",{},"Greedy works when local optimum leads to global optimumâ€”Activity Selection is a perfect case for that!",[308,1762,1763],{},"html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}",{"title":15,"searchDepth":25,"depth":25,"links":1765},[1766,1767,1774,1775,1776],{"id":1532,"depth":25,"text":1533},{"id":1642,"depth":25,"text":1643,"children":1768},[1769,1771,1773],{"id":1646,"depth":170,"text":1770},"â³ Waktu: O(n log n)",{"id":1660,"depth":170,"text":1772},"ğŸ’¾ Ruang: O(n)",{"id":1672,"depth":170,"text":1673},{"id":1689,"depth":25,"text":1690},{"id":1710,"depth":25,"text":1711},{"id":1731,"depth":25,"text":1732},"Pelajari bagaimana memilih aktivitas maksimum yang tidak saling tumpang tindih menggunakan pendekatan greedy.",{"script":1779},[1780],{"type":1781,"key":1782,"data-nuxt-schema-org":30,"nodes":1783},"application/ld+json","schema-org-graph",[1784],{"_resolver":1785},"webPage","/articles/10.jpeg",{},{"props":1789},{},"/en/articles/activity-promblem-selection",{"_resolver":1785},{"title":1120,"description":1777},{"loc":1790,"videos":1794,"images":1795,"lastmod":1796},[],[],"2025-06-14T00:00:00.000Z","en/articles/activity-promblem-selection",[],"kStsjvioomql7aanPuH17vkw5U3WiKCCGHYblJ0wG88",{"id":1801,"title":1802,"body":1803,"date":27,"description":2563,"extension":28,"head":2564,"image":2569,"meta":2570,"navigation":30,"ogImage":2571,"path":2573,"readingTime":27,"robots":27,"schemaOrg":2574,"seo":2575,"sitemap":2576,"stem":2580,"tags":2581,"__hash__":2582},"articles_en/en/articles/breadth-firts-search.md","Mengenal Algoritma Breadth-First Search (BFS)",{"type":7,"value":1804,"toc":2556},[1805,1809,1992,2003,2006,2476,2480,2484,2501,2505,2523,2539,2542,2548,2553],[269,1806,1808],{"id":1807},"breadth-firts-search","BREADTH FIRTS SEARCH",[109,1810,1812],{"className":1129,"code":1811,"language":1131,"meta":15,"style":15},"# Apa itu Algoritma Breadth-First Search (BFS)?\n\n**Breadth-First Search (BFS)** adalah algoritma pencarian dan penelusuran pada struktur data **grafik** atau **pohon**. BFS menjelajahi simpul (node) grafik dengan memulai dari node awal, lalu mengunjungi semua tetangga terdekat terlebih dahulu sebelum bergerak ke level berikutnya.\n\n> ğŸ” BFS menelusuri secara **melebar**, bukan menyelam seperti DFS.\n\n---\n\n## Aplikasi BFS\n\nBFS banyak digunakan dalam berbagai masalah komputer, antara lain:\n\n- ğŸ” **Menemukan jalur terpendek** dalam graf tak berbobot.\n- ğŸ” **Pencarian elemen** dalam pohon atau graf.\n- ğŸŒ **Analisis jaringan**: Menentukan jarak antar simpul.\n- ğŸ”§ **Pemecahan puzzle** seperti Rubik, Sudoku, atau pencarian labirin.\n- ğŸ“¶ **Broadcasting**: Menyebarkan informasi dari satu node ke semua node.\n\n---\n\n## Cara Kerja BFS\n\n### Struktur Pendukung:\n- **Queue (antrian)**: Untuk mengatur urutan simpul yang akan dieksplorasi.\n- **Visited[]**: Untuk menandai simpul yang sudah dikunjungi agar tidak dikunjungi dua kali.\n\n### Langkah-langkah BFS:\n\n1. Masukkan `start node` ke queue dan tandai sebagai dikunjungi.\n2. Selama queue tidak kosong:\n   - Ambil node dari depan queue (dequeue).\n   - Proses node (misalnya cetak atau simpan hasil).\n   - Tambahkan semua tetangga **yang belum dikunjungi** ke queue dan tandai sebagai dikunjungi.\n\n---\n\n## Contoh Kasus\n\nGrafik:\n",[71,1813,1814,1819,1823,1828,1832,1837,1841,1845,1849,1854,1858,1863,1867,1872,1877,1882,1887,1892,1896,1900,1904,1909,1913,1918,1923,1928,1932,1937,1941,1946,1951,1956,1961,1966,1970,1974,1978,1983,1987],{"__ignoreMap":15},[118,1815,1816],{"class":120,"line":121},[118,1817,1818],{},"# Apa itu Algoritma Breadth-First Search (BFS)?\n",[118,1820,1821],{"class":120,"line":25},[118,1822,173],{"emptyLinePlaceholder":30},[118,1824,1825],{"class":120,"line":170},[118,1826,1827],{},"**Breadth-First Search (BFS)** adalah algoritma pencarian dan penelusuran pada struktur data **grafik** atau **pohon**. BFS menjelajahi simpul (node) grafik dengan memulai dari node awal, lalu mengunjungi semua tetangga terdekat terlebih dahulu sebelum bergerak ke level berikutnya.\n",[118,1829,1830],{"class":120,"line":176},[118,1831,173],{"emptyLinePlaceholder":30},[118,1833,1834],{"class":120,"line":195},[118,1835,1836],{},"> ğŸ” BFS menelusuri secara **melebar**, bukan menyelam seperti DFS.\n",[118,1838,1839],{"class":120,"line":201},[118,1840,173],{"emptyLinePlaceholder":30},[118,1842,1843],{"class":120,"line":207},[118,1844,1165],{},[118,1846,1847],{"class":120,"line":216},[118,1848,173],{"emptyLinePlaceholder":30},[118,1850,1851],{"class":120,"line":222},[118,1852,1853],{},"## Aplikasi BFS\n",[118,1855,1856],{"class":120,"line":228},[118,1857,173],{"emptyLinePlaceholder":30},[118,1859,1860],{"class":120,"line":238},[118,1861,1862],{},"BFS banyak digunakan dalam berbagai masalah komputer, antara lain:\n",[118,1864,1865],{"class":120,"line":243},[118,1866,173],{"emptyLinePlaceholder":30},[118,1868,1869],{"class":120,"line":252},[118,1870,1871],{},"- ğŸ” **Menemukan jalur terpendek** dalam graf tak berbobot.\n",[118,1873,1874],{"class":120,"line":263},[118,1875,1876],{},"- ğŸ” **Pencarian elemen** dalam pohon atau graf.\n",[118,1878,1879],{"class":120,"line":279},[118,1880,1881],{},"- ğŸŒ **Analisis jaringan**: Menentukan jarak antar simpul.\n",[118,1883,1884],{"class":120,"line":289},[118,1885,1886],{},"- ğŸ”§ **Pemecahan puzzle** seperti Rubik, Sudoku, atau pencarian labirin.\n",[118,1888,1889],{"class":120,"line":298},[118,1890,1891],{},"- ğŸ“¶ **Broadcasting**: Menyebarkan informasi dari satu node ke semua node.\n",[118,1893,1894],{"class":120,"line":303},[118,1895,173],{"emptyLinePlaceholder":30},[118,1897,1898],{"class":120,"line":316},[118,1899,1165],{},[118,1901,1902],{"class":120,"line":321},[118,1903,173],{"emptyLinePlaceholder":30},[118,1905,1906],{"class":120,"line":666},[118,1907,1908],{},"## Cara Kerja BFS\n",[118,1910,1911],{"class":120,"line":1036},[118,1912,173],{"emptyLinePlaceholder":30},[118,1914,1915],{"class":120,"line":1042},[118,1916,1917],{},"### Struktur Pendukung:\n",[118,1919,1920],{"class":120,"line":1242},[118,1921,1922],{},"- **Queue (antrian)**: Untuk mengatur urutan simpul yang akan dieksplorasi.\n",[118,1924,1925],{"class":120,"line":1248},[118,1926,1927],{},"- **Visited[]**: Untuk menandai simpul yang sudah dikunjungi agar tidak dikunjungi dua kali.\n",[118,1929,1930],{"class":120,"line":1254},[118,1931,173],{"emptyLinePlaceholder":30},[118,1933,1934],{"class":120,"line":1259},[118,1935,1936],{},"### Langkah-langkah BFS:\n",[118,1938,1939],{"class":120,"line":1265},[118,1940,173],{"emptyLinePlaceholder":30},[118,1942,1943],{"class":120,"line":1270},[118,1944,1945],{},"1. Masukkan `start node` ke queue dan tandai sebagai dikunjungi.\n",[118,1947,1948],{"class":120,"line":1275},[118,1949,1950],{},"2. Selama queue tidak kosong:\n",[118,1952,1953],{"class":120,"line":1280},[118,1954,1955],{},"   - Ambil node dari depan queue (dequeue).\n",[118,1957,1958],{"class":120,"line":1286},[118,1959,1960],{},"   - Proses node (misalnya cetak atau simpan hasil).\n",[118,1962,1963],{"class":120,"line":1291},[118,1964,1965],{},"   - Tambahkan semua tetangga **yang belum dikunjungi** ke queue dan tandai sebagai dikunjungi.\n",[118,1967,1968],{"class":120,"line":1297},[118,1969,173],{"emptyLinePlaceholder":30},[118,1971,1972],{"class":120,"line":1302},[118,1973,1165],{},[118,1975,1976],{"class":120,"line":1308},[118,1977,173],{"emptyLinePlaceholder":30},[118,1979,1980],{"class":120,"line":1314},[118,1981,1982],{},"## Contoh Kasus\n",[118,1984,1985],{"class":120,"line":1320},[118,1986,173],{"emptyLinePlaceholder":30},[118,1988,1989],{"class":120,"line":1326},[118,1990,1991],{},"Grafik:\n",[109,1993,1997],{"className":1994,"code":1995,"language":1996,"meta":15,"style":15},"language-js shiki shiki-themes github-dark github-dark github-light","A\n","js",[71,1998,1999],{"__ignoreMap":15},[118,2000,2001],{"class":120,"line":121},[118,2002,1995],{"class":182},[17,2004,2005],{},"/ B C / \\ D E F",[109,2007,2009],{"className":1994,"code":2008,"language":1996,"meta":15,"style":15},"\n**Tujuan**: Lakukan penelusuran BFS dari node `A`.\n\n### Urutan Penjelajahan:\n`A â†’ B â†’ C â†’ D â†’ E â†’ F`\n\n**Langkah BFS**:\n1. Mulai dari A â†’ `visited[A] = true`, queue: `[A]`\n2. Dequeue A â†’ tetangga B, C â†’ queue: `[B, C]`\n3. Dequeue B â†’ tetangga D, E â†’ queue: `[C, D, E]`\n4. Dequeue C â†’ tetangga F â†’ queue: `[D, E, F]`\n5. Dequeue D â†’ tidak ada tetangga baru\n6. Dequeue E â†’ tidak ada tetangga baru\n7. Dequeue F â†’ selesai\n\n---\n\n## Implementasi BFS dalam C++\n\n```cpp\n#include \u003Ciostream>\n#include \u003Cvector>\n#include \u003Cqueue>\n\nstd::vector\u003Cstd::vector\u003Cint>> adj;\nstd::vector\u003Cbool> visited;\n\nvoid bfs(int startNode) {\n    std::queue\u003Cint> q;\n    visited[startNode] = true;\n    q.push(startNode);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        std::cout \u003C\u003C u \u003C\u003C \" \";\n\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nint main() {\n    int numNodes = 6; // A=0, B=1, C=2, D=3, E=4, F=5\n    adj.resize(numNodes);\n    visited.resize(numNodes, false);\n\n    // Membangun graf (tidak berarah)\n    adj[0] = {1, 2};     // A â†’ B, C\n    adj[1] = {0, 3, 4};  // B â†’ A, D, E\n    adj[2] = {0, 5};     // C â†’ A, F\n    adj[3] = {1};        // D â†’ B\n    adj[4] = {1};        // E â†’ B\n    adj[5] = {2};        // F â†’ C\n\n    std::cout \u003C\u003C \"BFS dari node A (0): \";\n    bfs(0); // Start dari A (index 0)\n    std::cout \u003C\u003C \"\\n\";\n\n    return 0;\n}\n",[71,2010,2011,2015,2040,2044,2055,2060,2064,2077,2105,2135,2163,2186,2198,2209,2221,2225,2229,2233,2248,2252,2257,2262,2267,2272,2276,2281,2286,2290,2295,2300,2305,2310,2314,2319,2324,2329,2334,2338,2343,2348,2353,2358,2363,2367,2371,2375,2379,2384,2389,2394,2399,2403,2408,2413,2418,2423,2428,2433,2438,2442,2447,2452,2463,2467,2472],{"__ignoreMap":15},[118,2012,2013],{"class":120,"line":121},[118,2014,173],{"emptyLinePlaceholder":30},[118,2016,2017,2020,2023,2025,2028,2031,2034,2037],{"class":120,"line":25},[118,2018,2019],{"class":151},"**",[118,2021,2022],{"class":124},"Tujuan",[118,2024,2019],{"class":151},[118,2026,2027],{"class":124},": Lakukan penelusuran ",[118,2029,2030],{"class":182},"BFS",[118,2032,2033],{"class":124}," dari node ",[118,2035,2036],{"class":142},"`A`",[118,2038,2039],{"class":124},".\n",[118,2041,2042],{"class":120,"line":170},[118,2043,173],{"emptyLinePlaceholder":30},[118,2045,2046,2049,2052],{"class":120,"line":176},[118,2047,2048],{"class":124},"### Urutan ",[118,2050,2051],{"class":132},"Penjelajahan",[118,2053,2054],{"class":124},":\n",[118,2056,2057],{"class":120,"line":195},[118,2058,2059],{"class":142},"`A â†’ B â†’ C â†’ D â†’ E â†’ F`\n",[118,2061,2062],{"class":120,"line":201},[118,2063,173],{"emptyLinePlaceholder":30},[118,2065,2066,2068,2071,2073,2075],{"class":120,"line":207},[118,2067,2019],{"class":151},[118,2069,2070],{"class":124},"Langkah ",[118,2072,2030],{"class":182},[118,2074,2019],{"class":151},[118,2076,2054],{"class":124},[118,2078,2079,2082,2085,2088,2091,2094,2096,2099,2102],{"class":120,"line":216},[118,2080,2081],{"class":182},"1.",[118,2083,2084],{"class":124}," Mulai dari ",[118,2086,2087],{"class":182},"A",[118,2089,2090],{"class":124}," â†’ ",[118,2092,2093],{"class":142},"`visited[A] = true`",[118,2095,811],{"class":124},[118,2097,2098],{"class":132},"queue",[118,2100,2101],{"class":124},": ",[118,2103,2104],{"class":142},"`[A]`\n",[118,2106,2107,2110,2113,2115,2118,2121,2123,2126,2128,2130,2132],{"class":120,"line":222},[118,2108,2109],{"class":182},"2.",[118,2111,2112],{"class":124}," Dequeue ",[118,2114,2087],{"class":182},[118,2116,2117],{"class":124}," â†’ tetangga ",[118,2119,2120],{"class":182},"B",[118,2122,811],{"class":124},[118,2124,2125],{"class":182},"C",[118,2127,2090],{"class":124},[118,2129,2098],{"class":132},[118,2131,2101],{"class":124},[118,2133,2134],{"class":142},"`[B, C]`\n",[118,2136,2137,2140,2142,2144,2146,2149,2151,2154,2156,2158,2160],{"class":120,"line":228},[118,2138,2139],{"class":182},"3.",[118,2141,2112],{"class":124},[118,2143,2120],{"class":182},[118,2145,2117],{"class":124},[118,2147,2148],{"class":182},"D",[118,2150,811],{"class":124},[118,2152,2153],{"class":182},"E",[118,2155,2090],{"class":124},[118,2157,2098],{"class":132},[118,2159,2101],{"class":124},[118,2161,2162],{"class":142},"`[C, D, E]`\n",[118,2164,2165,2168,2170,2172,2174,2177,2179,2181,2183],{"class":120,"line":238},[118,2166,2167],{"class":182},"4.",[118,2169,2112],{"class":124},[118,2171,2125],{"class":182},[118,2173,2117],{"class":124},[118,2175,2176],{"class":182},"F",[118,2178,2090],{"class":124},[118,2180,2098],{"class":132},[118,2182,2101],{"class":124},[118,2184,2185],{"class":142},"`[D, E, F]`\n",[118,2187,2188,2191,2193,2195],{"class":120,"line":243},[118,2189,2190],{"class":182},"5.",[118,2192,2112],{"class":124},[118,2194,2148],{"class":182},[118,2196,2197],{"class":124}," â†’ tidak ada tetangga baru\n",[118,2199,2200,2203,2205,2207],{"class":120,"line":252},[118,2201,2202],{"class":182},"6.",[118,2204,2112],{"class":124},[118,2206,2153],{"class":182},[118,2208,2197],{"class":124},[118,2210,2211,2214,2216,2218],{"class":120,"line":263},[118,2212,2213],{"class":182},"7.",[118,2215,2112],{"class":124},[118,2217,2176],{"class":182},[118,2219,2220],{"class":124}," â†’ selesai\n",[118,2222,2223],{"class":120,"line":279},[118,2224,173],{"emptyLinePlaceholder":30},[118,2226,2227],{"class":120,"line":289},[118,2228,1165],{"class":151},[118,2230,2231],{"class":120,"line":298},[118,2232,173],{"emptyLinePlaceholder":30},[118,2234,2235,2238,2240,2243,2245],{"class":120,"line":303},[118,2236,2237],{"class":124},"## Implementasi ",[118,2239,2030],{"class":182},[118,2241,2242],{"class":124}," dalam ",[118,2244,2125],{"class":182},[118,2246,2247],{"class":151},"++\n",[118,2249,2250],{"class":120,"line":316},[118,2251,173],{"emptyLinePlaceholder":30},[118,2253,2254],{"class":120,"line":321},[118,2255,2256],{"class":142},"```cpp\n",[118,2258,2259],{"class":120,"line":666},[118,2260,2261],{"class":142},"#include \u003Ciostream>\n",[118,2263,2264],{"class":120,"line":1036},[118,2265,2266],{"class":142},"#include \u003Cvector>\n",[118,2268,2269],{"class":120,"line":1042},[118,2270,2271],{"class":142},"#include \u003Cqueue>\n",[118,2273,2274],{"class":120,"line":1242},[118,2275,173],{"emptyLinePlaceholder":30},[118,2277,2278],{"class":120,"line":1248},[118,2279,2280],{"class":142},"std::vector\u003Cstd::vector\u003Cint>> adj;\n",[118,2282,2283],{"class":120,"line":1254},[118,2284,2285],{"class":142},"std::vector\u003Cbool> visited;\n",[118,2287,2288],{"class":120,"line":1259},[118,2289,173],{"emptyLinePlaceholder":30},[118,2291,2292],{"class":120,"line":1265},[118,2293,2294],{"class":142},"void bfs(int startNode) {\n",[118,2296,2297],{"class":120,"line":1270},[118,2298,2299],{"class":142},"    std::queue\u003Cint> q;\n",[118,2301,2302],{"class":120,"line":1275},[118,2303,2304],{"class":142},"    visited[startNode] = true;\n",[118,2306,2307],{"class":120,"line":1280},[118,2308,2309],{"class":142},"    q.push(startNode);\n",[118,2311,2312],{"class":120,"line":1286},[118,2313,173],{"emptyLinePlaceholder":30},[118,2315,2316],{"class":120,"line":1291},[118,2317,2318],{"class":142},"    while (!q.empty()) {\n",[118,2320,2321],{"class":120,"line":1297},[118,2322,2323],{"class":142},"        int u = q.front();\n",[118,2325,2326],{"class":120,"line":1302},[118,2327,2328],{"class":142},"        q.pop();\n",[118,2330,2331],{"class":120,"line":1308},[118,2332,2333],{"class":142},"        std::cout \u003C\u003C u \u003C\u003C \" \";\n",[118,2335,2336],{"class":120,"line":1314},[118,2337,173],{"emptyLinePlaceholder":30},[118,2339,2340],{"class":120,"line":1320},[118,2341,2342],{"class":142},"        for (int v : adj[u]) {\n",[118,2344,2345],{"class":120,"line":1326},[118,2346,2347],{"class":142},"            if (!visited[v]) {\n",[118,2349,2350],{"class":120,"line":1332},[118,2351,2352],{"class":142},"                visited[v] = true;\n",[118,2354,2355],{"class":120,"line":1338},[118,2356,2357],{"class":142},"                q.push(v);\n",[118,2359,2360],{"class":120,"line":1344},[118,2361,2362],{"class":142},"            }\n",[118,2364,2365],{"class":120,"line":1349},[118,2366,1598],{"class":142},[118,2368,2369],{"class":120,"line":1355},[118,2370,621],{"class":142},[118,2372,2373],{"class":120,"line":1360},[118,2374,757],{"class":142},[118,2376,2377],{"class":120,"line":1366},[118,2378,173],{"emptyLinePlaceholder":30},[118,2380,2381],{"class":120,"line":1372},[118,2382,2383],{"class":142},"int main() {\n",[118,2385,2386],{"class":120,"line":1378},[118,2387,2388],{"class":142},"    int numNodes = 6; // A=0, B=1, C=2, D=3, E=4, F=5\n",[118,2390,2391],{"class":120,"line":1384},[118,2392,2393],{"class":142},"    adj.resize(numNodes);\n",[118,2395,2396],{"class":120,"line":1390},[118,2397,2398],{"class":142},"    visited.resize(numNodes, false);\n",[118,2400,2401],{"class":120,"line":1395},[118,2402,173],{"emptyLinePlaceholder":30},[118,2404,2405],{"class":120,"line":1401},[118,2406,2407],{"class":142},"    // Membangun graf (tidak berarah)\n",[118,2409,2410],{"class":120,"line":1406},[118,2411,2412],{"class":142},"    adj[0] = {1, 2};     // A â†’ B, C\n",[118,2414,2415],{"class":120,"line":1411},[118,2416,2417],{"class":142},"    adj[1] = {0, 3, 4};  // B â†’ A, D, E\n",[118,2419,2420],{"class":120,"line":1416},[118,2421,2422],{"class":142},"    adj[2] = {0, 5};     // C â†’ A, F\n",[118,2424,2425],{"class":120,"line":1422},[118,2426,2427],{"class":142},"    adj[3] = {1};        // D â†’ B\n",[118,2429,2430],{"class":120,"line":1427},[118,2431,2432],{"class":142},"    adj[4] = {1};        // E â†’ B\n",[118,2434,2435],{"class":120,"line":1433},[118,2436,2437],{"class":142},"    adj[5] = {2};        // F â†’ C\n",[118,2439,2440],{"class":120,"line":1439},[118,2441,173],{"emptyLinePlaceholder":30},[118,2443,2444],{"class":120,"line":1445},[118,2445,2446],{"class":142},"    std::cout \u003C\u003C \"BFS dari node A (0): \";\n",[118,2448,2449],{"class":120,"line":1451},[118,2450,2451],{"class":142},"    bfs(0); // Start dari A (index 0)\n",[118,2453,2454,2457,2460],{"class":120,"line":1457},[118,2455,2456],{"class":142},"    std::cout \u003C\u003C \"",[118,2458,2459],{"class":182},"\\n",[118,2461,2462],{"class":142},"\";\n",[118,2464,2465],{"class":120,"line":1462},[118,2466,173],{"emptyLinePlaceholder":30},[118,2468,2469],{"class":120,"line":1468},[118,2470,2471],{"class":142},"    return 0;\n",[118,2473,2474],{"class":120,"line":1474},[118,2475,757],{"class":142},[53,2477,2479],{"id":2478},"kelebihan-dan-kekurangan","Kelebihan dan Kekurangan",[85,2481,2483],{"id":2482},"kelebihan-bfs","âœ… Kelebihan BFS:",[1652,2485,2486,2492,2498],{},[1655,2487,2488,2491],{},[101,2489,2490],{},"Menemukan jalur terpendek"," dalam graf tak berbobot.",[1655,2493,2494,2497],{},[101,2495,2496],{},"Bekerja baik pada graf level-wise",", misalnya puzzle, pohon.",[1655,2499,2500],{},"Efektif untuk menjelajahi semua node dalam urutan terstruktur.",[85,2502,2504],{"id":2503},"kekurangan-bfs","âŒ Kekurangan BFS:",[1652,2506,2507,2514,2517],{},[1655,2508,2509,2510,2513],{},"Memakan ",[101,2511,2512],{},"memori besar"," jika graf memiliki banyak node di level yang sama.",[1655,2515,2516],{},"Kurang cocok untuk graf sangat dalam (deep tree) dibanding DFS.",[1655,2518,2519,2522],{},[101,2520,2521],{},"Lebih lambat"," dari DFS pada graf dengan solusi dalam jalur panjang tunggal.",[1752,2524,2525],{},[17,2526,2527,2528,2531,2532,2535,2536,2538],{},"Kompleksitas waktu BFS adalah ",[101,2529,2530],{},"O(V + E)",", di mana ",[71,2533,2534],{},"V"," = simpul, ",[71,2537,2153],{}," = sisi.",[53,2540,2541],{"id":1731},"Kesimpulan",[17,2543,2544,2547],{},[101,2545,2546],{},"Breadth-First Search (BFS)"," adalah algoritma fundamental yang sangat berguna dalam berbagai aplikasi komputer, terutama ketika kita ingin mengeksplorasi data secara level-by-level atau mencari solusi tercepat.",[1752,2549,2550],{},[17,2551,2552],{},"BFS sangat cocok untuk pencarian jalur terpendek dan eksplorasi yang merata, menjadikannya pelengkap ideal dari DFS.",[308,2554,2555],{},"html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html pre.shiki code .sAPL1, html code.shiki .sAPL1{--shiki-dark:#79B8FF;--shiki-default:#79B8FF;--shiki-light:#005CC5}html pre.shiki code .sEiGg, html code.shiki .sEiGg{--shiki-dark:#F97583;--shiki-default:#F97583;--shiki-light:#D73A49}html pre.shiki code .suVJd, html code.shiki .suVJd{--shiki-dark:#E1E4E8;--shiki-default:#E1E4E8;--shiki-light:#24292E}html pre.shiki code .sYTnl, html code.shiki .sYTnl{--shiki-dark:#9ECBFF;--shiki-default:#9ECBFF;--shiki-light:#032F62}html pre.shiki code .s9E-l, html code.shiki .s9E-l{--shiki-dark:#B392F0;--shiki-default:#B392F0;--shiki-light:#6F42C1}",{"title":15,"searchDepth":25,"depth":25,"links":2557},[2558,2562],{"id":2478,"depth":25,"text":2479,"children":2559},[2560,2561],{"id":2482,"depth":170,"text":2483},{"id":2503,"depth":170,"text":2504},{"id":1731,"depth":25,"text":2541},"BFS adalah algoritma penelusuran graf yang menjelajahi simpul tingkat demi tingkat, memastikan semua tetangga pada tingkat saat ini dikunjungi sebelum pindah ke tingkat berikutnya.",{"script":2565},[2566],{"type":1781,"key":1782,"data-nuxt-schema-org":30,"nodes":2567},[2568],{"_resolver":1785},"/articles/4.jpeg",{},{"props":2572},{},"/en/articles/breadth-firts-search",{"_resolver":1785},{"title":1802,"description":2563},{"loc":2573,"videos":2577,"images":2578,"lastmod":2579},[],[],"2025-06-13T00:00:00.000Z","en/articles/breadth-firts-search",[],"lr5lH3EUrpNDCw9-vOfyH-c6-5IWHHS3yCeuyIOyS-k",{"id":2584,"title":2585,"body":2586,"date":27,"description":3431,"extension":28,"head":3432,"image":3437,"meta":3438,"navigation":30,"ogImage":3439,"path":3441,"readingTime":27,"robots":27,"schemaOrg":3442,"seo":3443,"sitemap":3444,"stem":3447,"tags":3448,"__hash__":3449},"articles_en/en/articles/deapth-first-search-bfs.md","Memahami Algoritma Depth-First Search (DFS)",{"type":7,"value":2587,"toc":3424},[2588,2592,2814,2822,2824,3337,3339,3343,3378,3382,3404,3411,3413,3416,3421],[269,2589,2591],{"id":2590},"deapth-first-search-bfs","DEAPTH FIRST SEARCH (BFS)",[109,2593,2595],{"className":1129,"code":2594,"language":1131,"meta":15,"style":15},"# Apa itu Algoritma Depth-First Search (DFS)?\n\n**Depth-First Search (DFS)** adalah algoritma untuk melintasi atau mencari elemen dalam struktur data seperti **pohon** atau **grafik**. DFS memulai penelusuran dari node akar (atau node yang dipilih) dan menjelajah sejauh mungkin di sepanjang setiap cabang sebelum melakukan *backtrack*.\n\n> ğŸ¯ Analoginya seperti menjelajah labirin: ikuti satu jalan hingga mentok, lalu kembali ke percabangan sebelumnya dan coba jalur lain.\n\n---\n\n## Aplikasi DFS\n\nDFS digunakan dalam berbagai bidang ilmu komputer, di antaranya:\n\n- ğŸ” **Pencarian jalur**: Menemukan rute antara dua simpul dalam graf.\n- ğŸ” **Deteksi siklus**: Mengidentifikasi apakah graf mengandung siklus.\n- ğŸ“Š **Pengurutan topologis**: Alternatif untuk Algoritma Kahn.\n- ğŸ”— **Menemukan komponen terhubung** dalam graf tak berarah.\n- ğŸ§© **Penyelesaian puzzle**: Contohnya Sudoku atau labirin.\n- ğŸŒ **Analisis jaringan**: Menjelajahi struktur koneksi.\n\n---\n\n## Cara Kerja Algoritma DFS\n\nDFS dapat diimplementasikan secara **rekursif** atau **iteratif menggunakan stack**.\n\n### 1. Inisialisasi:\n\n- Buat `visited[]` untuk menandai node yang sudah dikunjungi.\n- Mulai dari `start node`.\n- Tandai node sebagai dikunjungi.\n\n### 2. Penjelajahan:\n\n- Ambil node dari stack atau parameter rekursif.\n- Proses node (misalnya: cetak, simpan).\n- Untuk setiap tetangga yang belum dikunjungi:\n  - Tandai sebagai dikunjungi.\n  - Tambahkan ke stack atau panggil DFS secara rekursif.\n\n### 3. Backtracking:\n\n- Jika semua tetangga sudah dikunjungi, kembali ke node sebelumnya.\n\n---\n\n## Contoh Kasus\n\nGrafik:\n",[71,2596,2597,2602,2606,2611,2615,2620,2624,2628,2632,2637,2641,2646,2650,2655,2660,2665,2670,2675,2680,2684,2688,2692,2697,2701,2706,2710,2715,2719,2724,2729,2734,2738,2743,2747,2752,2757,2762,2767,2772,2776,2781,2785,2790,2794,2798,2802,2806,2810],{"__ignoreMap":15},[118,2598,2599],{"class":120,"line":121},[118,2600,2601],{},"# Apa itu Algoritma Depth-First Search (DFS)?\n",[118,2603,2604],{"class":120,"line":25},[118,2605,173],{"emptyLinePlaceholder":30},[118,2607,2608],{"class":120,"line":170},[118,2609,2610],{},"**Depth-First Search (DFS)** adalah algoritma untuk melintasi atau mencari elemen dalam struktur data seperti **pohon** atau **grafik**. DFS memulai penelusuran dari node akar (atau node yang dipilih) dan menjelajah sejauh mungkin di sepanjang setiap cabang sebelum melakukan *backtrack*.\n",[118,2612,2613],{"class":120,"line":176},[118,2614,173],{"emptyLinePlaceholder":30},[118,2616,2617],{"class":120,"line":195},[118,2618,2619],{},"> ğŸ¯ Analoginya seperti menjelajah labirin: ikuti satu jalan hingga mentok, lalu kembali ke percabangan sebelumnya dan coba jalur lain.\n",[118,2621,2622],{"class":120,"line":201},[118,2623,173],{"emptyLinePlaceholder":30},[118,2625,2626],{"class":120,"line":207},[118,2627,1165],{},[118,2629,2630],{"class":120,"line":216},[118,2631,173],{"emptyLinePlaceholder":30},[118,2633,2634],{"class":120,"line":222},[118,2635,2636],{},"## Aplikasi DFS\n",[118,2638,2639],{"class":120,"line":228},[118,2640,173],{"emptyLinePlaceholder":30},[118,2642,2643],{"class":120,"line":238},[118,2644,2645],{},"DFS digunakan dalam berbagai bidang ilmu komputer, di antaranya:\n",[118,2647,2648],{"class":120,"line":243},[118,2649,173],{"emptyLinePlaceholder":30},[118,2651,2652],{"class":120,"line":252},[118,2653,2654],{},"- ğŸ” **Pencarian jalur**: Menemukan rute antara dua simpul dalam graf.\n",[118,2656,2657],{"class":120,"line":263},[118,2658,2659],{},"- ğŸ” **Deteksi siklus**: Mengidentifikasi apakah graf mengandung siklus.\n",[118,2661,2662],{"class":120,"line":279},[118,2663,2664],{},"- ğŸ“Š **Pengurutan topologis**: Alternatif untuk Algoritma Kahn.\n",[118,2666,2667],{"class":120,"line":289},[118,2668,2669],{},"- ğŸ”— **Menemukan komponen terhubung** dalam graf tak berarah.\n",[118,2671,2672],{"class":120,"line":298},[118,2673,2674],{},"- ğŸ§© **Penyelesaian puzzle**: Contohnya Sudoku atau labirin.\n",[118,2676,2677],{"class":120,"line":303},[118,2678,2679],{},"- ğŸŒ **Analisis jaringan**: Menjelajahi struktur koneksi.\n",[118,2681,2682],{"class":120,"line":316},[118,2683,173],{"emptyLinePlaceholder":30},[118,2685,2686],{"class":120,"line":321},[118,2687,1165],{},[118,2689,2690],{"class":120,"line":666},[118,2691,173],{"emptyLinePlaceholder":30},[118,2693,2694],{"class":120,"line":1036},[118,2695,2696],{},"## Cara Kerja Algoritma DFS\n",[118,2698,2699],{"class":120,"line":1042},[118,2700,173],{"emptyLinePlaceholder":30},[118,2702,2703],{"class":120,"line":1242},[118,2704,2705],{},"DFS dapat diimplementasikan secara **rekursif** atau **iteratif menggunakan stack**.\n",[118,2707,2708],{"class":120,"line":1248},[118,2709,173],{"emptyLinePlaceholder":30},[118,2711,2712],{"class":120,"line":1254},[118,2713,2714],{},"### 1. Inisialisasi:\n",[118,2716,2717],{"class":120,"line":1259},[118,2718,173],{"emptyLinePlaceholder":30},[118,2720,2721],{"class":120,"line":1265},[118,2722,2723],{},"- Buat `visited[]` untuk menandai node yang sudah dikunjungi.\n",[118,2725,2726],{"class":120,"line":1270},[118,2727,2728],{},"- Mulai dari `start node`.\n",[118,2730,2731],{"class":120,"line":1275},[118,2732,2733],{},"- Tandai node sebagai dikunjungi.\n",[118,2735,2736],{"class":120,"line":1280},[118,2737,173],{"emptyLinePlaceholder":30},[118,2739,2740],{"class":120,"line":1286},[118,2741,2742],{},"### 2. Penjelajahan:\n",[118,2744,2745],{"class":120,"line":1291},[118,2746,173],{"emptyLinePlaceholder":30},[118,2748,2749],{"class":120,"line":1297},[118,2750,2751],{},"- Ambil node dari stack atau parameter rekursif.\n",[118,2753,2754],{"class":120,"line":1302},[118,2755,2756],{},"- Proses node (misalnya: cetak, simpan).\n",[118,2758,2759],{"class":120,"line":1308},[118,2760,2761],{},"- Untuk setiap tetangga yang belum dikunjungi:\n",[118,2763,2764],{"class":120,"line":1314},[118,2765,2766],{},"  - Tandai sebagai dikunjungi.\n",[118,2768,2769],{"class":120,"line":1320},[118,2770,2771],{},"  - Tambahkan ke stack atau panggil DFS secara rekursif.\n",[118,2773,2774],{"class":120,"line":1326},[118,2775,173],{"emptyLinePlaceholder":30},[118,2777,2778],{"class":120,"line":1332},[118,2779,2780],{},"### 3. Backtracking:\n",[118,2782,2783],{"class":120,"line":1338},[118,2784,173],{"emptyLinePlaceholder":30},[118,2786,2787],{"class":120,"line":1344},[118,2788,2789],{},"- Jika semua tetangga sudah dikunjungi, kembali ke node sebelumnya.\n",[118,2791,2792],{"class":120,"line":1349},[118,2793,173],{"emptyLinePlaceholder":30},[118,2795,2796],{"class":120,"line":1355},[118,2797,1165],{},[118,2799,2800],{"class":120,"line":1360},[118,2801,173],{"emptyLinePlaceholder":30},[118,2803,2804],{"class":120,"line":1366},[118,2805,1982],{},[118,2807,2808],{"class":120,"line":1372},[118,2809,173],{"emptyLinePlaceholder":30},[118,2811,2812],{"class":120,"line":1378},[118,2813,1991],{},[109,2815,2816],{"className":1994,"code":1995,"language":1996,"meta":15,"style":15},[71,2817,2818],{"__ignoreMap":15},[118,2819,2820],{"class":120,"line":121},[118,2821,1995],{"class":182},[17,2823,2005],{},[109,2825,2827],{"className":1994,"code":2826,"language":1996,"meta":15,"style":15},"\n**Tujuan**: Jelajahi graf menggunakan DFS dari node A.\n\n**Urutan Penjelajahan (Output)**: `A, B, D, E, C, F`\n\nLangkah-langkah DFS:\n1. DFS(A) â†’ `A`\n2. DFS(B) â†’ `B`\n3. DFS(D) â†’ `D` â†’ backtrack ke B\n4. DFS(E) â†’ `E` â†’ backtrack ke B â†’ backtrack ke A\n5. DFS(C) â†’ `C`\n6. DFS(F) â†’ `F`\n\n---\n\n## Implementasi DFS dalam C++\n\n```cpp\n#include \u003Ciostream>\n#include \u003Cvector>\n#include \u003Cstack>\n\nstd::vector\u003Cstd::vector\u003Cint>> adj;\nstd::vector\u003Cbool> visited;\n\n// DFS Rekursif\nvoid dfsRecursive(int u) {\n    visited[u] = true;\n    std::cout \u003C\u003C u \u003C\u003C \" \";\n\n    for (int v : adj[u]) {\n        if (!visited[v]) dfsRecursive(v);\n    }\n}\n\n// DFS Iteratif\nvoid dfsIterative(int startNode) {\n    std::vector\u003Cbool> localVisited(adj.size(), false);\n    std::stack\u003Cint> s;\n\n    s.push(startNode);\n    localVisited[startNode] = true;\n\n    while (!s.empty()) {\n        int u = s.top();\n        s.pop();\n\n        std::cout \u003C\u003C u \u003C\u003C \" \";\n\n        for (int i = adj[u].size() - 1; i >= 0; --i) {\n            int v = adj[u][i];\n            if (!localVisited[v]) {\n                localVisited[v] = true;\n                s.push(v);\n            }\n        }\n    }\n}\n\nint main() {\n    int numNodes = 6; // A=0, B=1, C=2, D=3, E=4, F=5\n    adj.resize(numNodes);\n    visited.resize(numNodes, false);\n\n    // Menyusun graf tidak berarah\n    adj[0] = {1, 2}; // A â†’ B, C\n    adj[1] = {0, 3, 4}; // B â†’ A, D, E\n    adj[2] = {0, 5}; // C â†’ A, F\n    adj[3] = {1}; // D â†’ B\n    adj[4] = {1}; // E â†’ B\n    adj[5] = {2}; // F â†’ C\n\n    std::cout \u003C\u003C \"DFS Rekursif: \";\n    dfsRecursive(0);\n    std::cout \u003C\u003C \"\\n\";\n\n    std::cout \u003C\u003C \"DFS Iteratif: \";\n    dfsIterative(0);\n    std::cout \u003C\u003C \"\\n\";\n\n    return 0;\n}\n",[71,2828,2829,2833,2853,2857,2876,2880,2895,2912,2927,2948,2971,2986,3001,3005,3009,3013,3025,3029,3033,3037,3041,3046,3050,3054,3058,3062,3067,3072,3077,3082,3086,3091,3096,3100,3104,3108,3113,3118,3123,3128,3132,3137,3142,3146,3151,3156,3161,3165,3169,3173,3178,3183,3188,3193,3198,3202,3206,3210,3214,3218,3222,3226,3230,3234,3238,3243,3248,3253,3258,3263,3268,3273,3277,3282,3287,3296,3301,3307,3313,3322,3327,3332],{"__ignoreMap":15},[118,2830,2831],{"class":120,"line":121},[118,2832,173],{"emptyLinePlaceholder":30},[118,2834,2835,2837,2839,2841,2844,2847,2849,2851],{"class":120,"line":25},[118,2836,2019],{"class":151},[118,2838,2022],{"class":124},[118,2840,2019],{"class":151},[118,2842,2843],{"class":124},": Jelajahi graf menggunakan ",[118,2845,2846],{"class":182},"DFS",[118,2848,2033],{"class":124},[118,2850,2087],{"class":182},[118,2852,2039],{"class":124},[118,2854,2855],{"class":120,"line":170},[118,2856,173],{"emptyLinePlaceholder":30},[118,2858,2859,2861,2864,2866,2869,2871,2873],{"class":120,"line":176},[118,2860,2019],{"class":151},[118,2862,2863],{"class":124},"Urutan ",[118,2865,2051],{"class":132},[118,2867,2868],{"class":124}," (Output)",[118,2870,2019],{"class":151},[118,2872,2101],{"class":124},[118,2874,2875],{"class":142},"`A, B, D, E, C, F`\n",[118,2877,2878],{"class":120,"line":195},[118,2879,173],{"emptyLinePlaceholder":30},[118,2881,2882,2885,2888,2891,2893],{"class":120,"line":201},[118,2883,2884],{"class":124},"Langkah",[118,2886,2887],{"class":151},"-",[118,2889,2890],{"class":124},"langkah ",[118,2892,2846],{"class":132},[118,2894,2054],{"class":124},[118,2896,2897,2899,2902,2904,2906,2909],{"class":120,"line":207},[118,2898,2081],{"class":182},[118,2900,2901],{"class":132}," DFS",[118,2903,391],{"class":124},[118,2905,2087],{"class":182},[118,2907,2908],{"class":124},") â†’ ",[118,2910,2911],{"class":142},"`A`\n",[118,2913,2914,2916,2918,2920,2922,2924],{"class":120,"line":216},[118,2915,2109],{"class":182},[118,2917,2901],{"class":132},[118,2919,391],{"class":124},[118,2921,2120],{"class":182},[118,2923,2908],{"class":124},[118,2925,2926],{"class":142},"`B`\n",[118,2928,2929,2931,2933,2935,2937,2939,2942,2945],{"class":120,"line":222},[118,2930,2139],{"class":182},[118,2932,2901],{"class":132},[118,2934,391],{"class":124},[118,2936,2148],{"class":182},[118,2938,2908],{"class":124},[118,2940,2941],{"class":142},"`D`",[118,2943,2944],{"class":124}," â†’ backtrack ke ",[118,2946,2947],{"class":182},"B\n",[118,2949,2950,2952,2954,2956,2958,2960,2963,2965,2967,2969],{"class":120,"line":228},[118,2951,2167],{"class":182},[118,2953,2901],{"class":132},[118,2955,391],{"class":124},[118,2957,2153],{"class":182},[118,2959,2908],{"class":124},[118,2961,2962],{"class":142},"`E`",[118,2964,2944],{"class":124},[118,2966,2120],{"class":182},[118,2968,2944],{"class":124},[118,2970,1995],{"class":182},[118,2972,2973,2975,2977,2979,2981,2983],{"class":120,"line":238},[118,2974,2190],{"class":182},[118,2976,2901],{"class":132},[118,2978,391],{"class":124},[118,2980,2125],{"class":182},[118,2982,2908],{"class":124},[118,2984,2985],{"class":142},"`C`\n",[118,2987,2988,2990,2992,2994,2996,2998],{"class":120,"line":243},[118,2989,2202],{"class":182},[118,2991,2901],{"class":132},[118,2993,391],{"class":124},[118,2995,2176],{"class":182},[118,2997,2908],{"class":124},[118,2999,3000],{"class":142},"`F`\n",[118,3002,3003],{"class":120,"line":252},[118,3004,173],{"emptyLinePlaceholder":30},[118,3006,3007],{"class":120,"line":263},[118,3008,1165],{"class":151},[118,3010,3011],{"class":120,"line":279},[118,3012,173],{"emptyLinePlaceholder":30},[118,3014,3015,3017,3019,3021,3023],{"class":120,"line":289},[118,3016,2237],{"class":124},[118,3018,2846],{"class":182},[118,3020,2242],{"class":124},[118,3022,2125],{"class":182},[118,3024,2247],{"class":151},[118,3026,3027],{"class":120,"line":298},[118,3028,173],{"emptyLinePlaceholder":30},[118,3030,3031],{"class":120,"line":303},[118,3032,2256],{"class":142},[118,3034,3035],{"class":120,"line":316},[118,3036,2261],{"class":142},[118,3038,3039],{"class":120,"line":321},[118,3040,2266],{"class":142},[118,3042,3043],{"class":120,"line":666},[118,3044,3045],{"class":142},"#include \u003Cstack>\n",[118,3047,3048],{"class":120,"line":1036},[118,3049,173],{"emptyLinePlaceholder":30},[118,3051,3052],{"class":120,"line":1042},[118,3053,2280],{"class":142},[118,3055,3056],{"class":120,"line":1242},[118,3057,2285],{"class":142},[118,3059,3060],{"class":120,"line":1248},[118,3061,173],{"emptyLinePlaceholder":30},[118,3063,3064],{"class":120,"line":1254},[118,3065,3066],{"class":142},"// DFS Rekursif\n",[118,3068,3069],{"class":120,"line":1259},[118,3070,3071],{"class":142},"void dfsRecursive(int u) {\n",[118,3073,3074],{"class":120,"line":1265},[118,3075,3076],{"class":142},"    visited[u] = true;\n",[118,3078,3079],{"class":120,"line":1270},[118,3080,3081],{"class":142},"    std::cout \u003C\u003C u \u003C\u003C \" \";\n",[118,3083,3084],{"class":120,"line":1275},[118,3085,173],{"emptyLinePlaceholder":30},[118,3087,3088],{"class":120,"line":1280},[118,3089,3090],{"class":142},"    for (int v : adj[u]) {\n",[118,3092,3093],{"class":120,"line":1286},[118,3094,3095],{"class":142},"        if (!visited[v]) dfsRecursive(v);\n",[118,3097,3098],{"class":120,"line":1291},[118,3099,621],{"class":142},[118,3101,3102],{"class":120,"line":1297},[118,3103,757],{"class":142},[118,3105,3106],{"class":120,"line":1302},[118,3107,173],{"emptyLinePlaceholder":30},[118,3109,3110],{"class":120,"line":1308},[118,3111,3112],{"class":142},"// DFS Iteratif\n",[118,3114,3115],{"class":120,"line":1314},[118,3116,3117],{"class":142},"void dfsIterative(int startNode) {\n",[118,3119,3120],{"class":120,"line":1320},[118,3121,3122],{"class":142},"    std::vector\u003Cbool> localVisited(adj.size(), false);\n",[118,3124,3125],{"class":120,"line":1326},[118,3126,3127],{"class":142},"    std::stack\u003Cint> s;\n",[118,3129,3130],{"class":120,"line":1332},[118,3131,173],{"emptyLinePlaceholder":30},[118,3133,3134],{"class":120,"line":1338},[118,3135,3136],{"class":142},"    s.push(startNode);\n",[118,3138,3139],{"class":120,"line":1344},[118,3140,3141],{"class":142},"    localVisited[startNode] = true;\n",[118,3143,3144],{"class":120,"line":1349},[118,3145,173],{"emptyLinePlaceholder":30},[118,3147,3148],{"class":120,"line":1355},[118,3149,3150],{"class":142},"    while (!s.empty()) {\n",[118,3152,3153],{"class":120,"line":1360},[118,3154,3155],{"class":142},"        int u = s.top();\n",[118,3157,3158],{"class":120,"line":1366},[118,3159,3160],{"class":142},"        s.pop();\n",[118,3162,3163],{"class":120,"line":1372},[118,3164,173],{"emptyLinePlaceholder":30},[118,3166,3167],{"class":120,"line":1378},[118,3168,2333],{"class":142},[118,3170,3171],{"class":120,"line":1384},[118,3172,173],{"emptyLinePlaceholder":30},[118,3174,3175],{"class":120,"line":1390},[118,3176,3177],{"class":142},"        for (int i = adj[u].size() - 1; i >= 0; --i) {\n",[118,3179,3180],{"class":120,"line":1395},[118,3181,3182],{"class":142},"            int v = adj[u][i];\n",[118,3184,3185],{"class":120,"line":1401},[118,3186,3187],{"class":142},"            if (!localVisited[v]) {\n",[118,3189,3190],{"class":120,"line":1406},[118,3191,3192],{"class":142},"                localVisited[v] = true;\n",[118,3194,3195],{"class":120,"line":1411},[118,3196,3197],{"class":142},"                s.push(v);\n",[118,3199,3200],{"class":120,"line":1416},[118,3201,2362],{"class":142},[118,3203,3204],{"class":120,"line":1422},[118,3205,1598],{"class":142},[118,3207,3208],{"class":120,"line":1427},[118,3209,621],{"class":142},[118,3211,3212],{"class":120,"line":1433},[118,3213,757],{"class":142},[118,3215,3216],{"class":120,"line":1439},[118,3217,173],{"emptyLinePlaceholder":30},[118,3219,3220],{"class":120,"line":1445},[118,3221,2383],{"class":142},[118,3223,3224],{"class":120,"line":1451},[118,3225,2388],{"class":142},[118,3227,3228],{"class":120,"line":1457},[118,3229,2393],{"class":142},[118,3231,3232],{"class":120,"line":1462},[118,3233,2398],{"class":142},[118,3235,3236],{"class":120,"line":1468},[118,3237,173],{"emptyLinePlaceholder":30},[118,3239,3240],{"class":120,"line":1474},[118,3241,3242],{"class":142},"    // Menyusun graf tidak berarah\n",[118,3244,3245],{"class":120,"line":1480},[118,3246,3247],{"class":142},"    adj[0] = {1, 2}; // A â†’ B, C\n",[118,3249,3250],{"class":120,"line":1486},[118,3251,3252],{"class":142},"    adj[1] = {0, 3, 4}; // B â†’ A, D, E\n",[118,3254,3255],{"class":120,"line":1491},[118,3256,3257],{"class":142},"    adj[2] = {0, 5}; // C â†’ A, F\n",[118,3259,3260],{"class":120,"line":1497},[118,3261,3262],{"class":142},"    adj[3] = {1}; // D â†’ B\n",[118,3264,3265],{"class":120,"line":1502},[118,3266,3267],{"class":142},"    adj[4] = {1}; // E â†’ B\n",[118,3269,3270],{"class":120,"line":1508},[118,3271,3272],{"class":142},"    adj[5] = {2}; // F â†’ C\n",[118,3274,3275],{"class":120,"line":1514},[118,3276,173],{"emptyLinePlaceholder":30},[118,3278,3279],{"class":120,"line":1520},[118,3280,3281],{"class":142},"    std::cout \u003C\u003C \"DFS Rekursif: \";\n",[118,3283,3284],{"class":120,"line":1526},[118,3285,3286],{"class":142},"    dfsRecursive(0);\n",[118,3288,3290,3292,3294],{"class":120,"line":3289},75,[118,3291,2456],{"class":142},[118,3293,2459],{"class":182},[118,3295,2462],{"class":142},[118,3297,3299],{"class":120,"line":3298},76,[118,3300,173],{"emptyLinePlaceholder":30},[118,3302,3304],{"class":120,"line":3303},77,[118,3305,3306],{"class":142},"    std::cout \u003C\u003C \"DFS Iteratif: \";\n",[118,3308,3310],{"class":120,"line":3309},78,[118,3311,3312],{"class":142},"    dfsIterative(0);\n",[118,3314,3316,3318,3320],{"class":120,"line":3315},79,[118,3317,2456],{"class":142},[118,3319,2459],{"class":182},[118,3321,2462],{"class":142},[118,3323,3325],{"class":120,"line":3324},80,[118,3326,173],{"emptyLinePlaceholder":30},[118,3328,3330],{"class":120,"line":3329},81,[118,3331,2471],{"class":142},[118,3333,3335],{"class":120,"line":3334},82,[118,3336,757],{"class":142},[53,3338,2479],{"id":2478},[85,3340,3342],{"id":3341},"kelebihan-dfs","âœ… Kelebihan DFS:",[1652,3344,3345,3351,3357,3371],{},[1655,3346,3347,3350],{},[101,3348,3349],{},"Sederhana & Efisien",": Mudah diimplementasikan.",[1655,3352,3353,3356],{},[101,3354,3355],{},"Memori rendah"," untuk graf luas dan dangkal.",[1655,3358,3359,3360],{},"Cocok untuk:\n",[1652,3361,3362,3365,3368],{},[1655,3363,3364],{},"Deteksi siklus",[1655,3366,3367],{},"Pengurutan topologis",[1655,3369,3370],{},"Komponen terhubung",[1655,3372,3373,3374,3377],{},"Dapat menemukan ",[101,3375,3376],{},"salah satu jalur"," antara dua node.",[85,3379,3381],{"id":3380},"kekurangan-dfs","âŒ Kekurangan DFS:",[1652,3383,3384,3391,3401],{},[1655,3385,3386,3387,3390],{},"âŒ ",[101,3388,3389],{},"Tidak optimal"," untuk jalur terpendek.",[1655,3392,3393,3394,3397,3398,1750],{},"âŒ Bisa masuk ",[101,3395,3396],{},"loop tak terbatas"," jika tidak ada ",[71,3399,3400],{},"visited",[1655,3402,3403],{},"âŒ Tidak cocok untuk graf berbobot negatif.",[1752,3405,3406],{},[17,3407,3408,3409,1750],{},"Kompleksitas waktu DFS adalah ",[101,3410,2530],{},[53,3412,2541],{"id":1731},[17,3414,3415],{},"Algoritma DFS adalah salah satu teknik dasar namun sangat powerful dalam pemrosesan graf. Cocok untuk berbagai aplikasi dari penelusuran, analisis struktur, hingga penyelesaian puzzle.",[1752,3417,3418],{},[17,3419,3420],{},"âš™ï¸ Meskipun tidak cocok untuk semua jenis masalah (seperti jalur terpendek), DFS wajib dikuasai oleh siapa pun yang mempelajari algoritma dan struktur data.",[308,3422,3423],{},"html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html pre.shiki code .sAPL1, html code.shiki .sAPL1{--shiki-dark:#79B8FF;--shiki-default:#79B8FF;--shiki-light:#005CC5}html pre.shiki code .sEiGg, html code.shiki .sEiGg{--shiki-dark:#F97583;--shiki-default:#F97583;--shiki-light:#D73A49}html pre.shiki code .suVJd, html code.shiki .suVJd{--shiki-dark:#E1E4E8;--shiki-default:#E1E4E8;--shiki-light:#24292E}html pre.shiki code .s9E-l, html code.shiki .s9E-l{--shiki-dark:#B392F0;--shiki-default:#B392F0;--shiki-light:#6F42C1}html pre.shiki code .sYTnl, html code.shiki .sYTnl{--shiki-dark:#9ECBFF;--shiki-default:#9ECBFF;--shiki-light:#032F62}",{"title":15,"searchDepth":25,"depth":25,"links":3425},[3426,3430],{"id":2478,"depth":25,"text":2479,"children":3427},[3428,3429],{"id":3341,"depth":170,"text":3342},{"id":3380,"depth":170,"text":3381},{"id":1731,"depth":25,"text":2541},"Selami dunia penjelajahan grafik secara mendalam.",{"script":3433},[3434],{"type":1781,"key":1782,"data-nuxt-schema-org":30,"nodes":3435},[3436],{"_resolver":1785},"/articles/3.jpeg",{},{"props":3440},{},"/en/articles/deapth-first-search-bfs",{"_resolver":1785},{"title":2585,"description":3431},{"loc":3441,"videos":3445,"images":3446,"lastmod":2579},[],[],"en/articles/deapth-first-search-bfs",[],"PRLUwJCHIwxOhRQZ83Ee9JFTOqjadPgbqRHNwXyGeeg",{"id":3451,"title":3452,"body":3453,"date":4029,"description":4030,"extension":28,"head":4031,"image":4036,"meta":4037,"navigation":30,"ogImage":4038,"path":4040,"readingTime":1108,"robots":27,"schemaOrg":4041,"seo":4042,"sitemap":4043,"stem":4046,"tags":4047,"__hash__":4048},"articles_en/en/articles/djikstra-algorithm.md","Memahami Algoritma Dijkstra",{"type":7,"value":3454,"toc":4022},[3455,3462,3466,3473,3500,3517,3521,3528,3708,3712,3715,3826,3835,3937,3942,3958,3962,3965,3991,3995,4016,4019],[17,3456,3457,3458,3461],{},"Algoritma Dijkstra, yang dinamai dari penemunya Edsger W. Dijkstra, adalah salah satu algoritma ",[101,3459,3460],{},"pencarian jalur terpendek (shortest path algorithm)"," yang paling terkenal dan banyak digunakan. Algoritma ini dirancang untuk menemukan jalur terpendek antara satu titik awal (disebut \"sumber\") ke semua titik lainnya dalam sebuah graf berbobot (weighted graph).",[85,3463,3465],{"id":3464},"apa-itu-graf-berbobot","Apa itu Graf Berbobot?",[17,3467,3468,3469,3472],{},"Sebelum masuk lebih dalam, penting untuk memahami apa itu ",[101,3470,3471],{},"graf berbobot",". Dalam konteks algoritma Dijkstra:",[1652,3474,3475,3481,3487],{},[1655,3476,3477,3480],{},[101,3478,3479],{},"Node (Titik/Simpul)",": Merepresentasikan lokasi atau entitas. Misalnya, kota-kota dalam peta, atau server dalam jaringan komputer.",[1655,3482,3483,3486],{},[101,3484,3485],{},"Edge (Sisi/Tepi)",": Merepresentasikan koneksi atau hubungan antara dua node.",[1655,3488,3489,3492,3493,3496,3497,3499],{},[101,3490,3491],{},"Bobot (Weight)",": Nilai numerik yang terkait dengan setiap ",[1758,3494,3495],{},"edge",". Bobot ini bisa berupa jarak, waktu, biaya, atau hambatan. Algoritma Dijkstra mencari jalur di mana total bobot ",[1758,3498,3495],{}," yang dilalui adalah yang terkecil.",[17,3501,3502,3505,3506,3509,3510,3512,3513,3516],{},[101,3503,3504],{},"Contoh Sederhana:"," Bayangkan peta jalan. Kota adalah ",[1758,3507,3508],{},"node",", jalan adalah ",[1758,3511,3495],{},", dan jarak antar kota adalah ",[1758,3514,3515],{},"bobot",". Algoritma Dijkstra bisa membantumu menemukan rute terpendek dari rumahmu ke semua tempat tujuan lain di peta.",[85,3518,3520],{"id":3519},"bagaimana-cara-kerja-algoritma-dijkstra","Bagaimana Cara Kerja Algoritma Dijkstra?",[17,3522,3523,3524,3527],{},"Algoritma Dijkstra bekerja secara ",[101,3525,3526],{},"rakus (greedy)",", artinya pada setiap langkah, ia membuat pilihan yang tampak terbaik saat itu dengan harapan akan membawa ke solusi optimal secara keseluruhan. Berikut adalah langkah-langkah intinya:",[3529,3530,3531,3563,3595,3660,3689],"ol",{},[1655,3532,3533,2054,3536],{},[101,3534,3535],{},"Inisialisasi",[1652,3537,3538,3554],{},[1655,3539,3540,3541,3543,3544,3547,3548,3550,3551,3553],{},"Setiap ",[1758,3542,3508],{}," diberikan ",[101,3545,3546],{},"jarak sementara (tentative distance)",". Jarak ke ",[1758,3549,3508],{}," sumber diatur ke 0, dan semua ",[1758,3552,3508],{}," lainnya diatur ke tak hingga (âˆ).",[1655,3555,3556,3557,3559,3560,3562],{},"Sebuah set ",[1758,3558,3508],{}," yang belum dikunjungi (atau belum \"diselesaikan\") dibuat dan awalnya berisi semua ",[1758,3561,3508],{}," dalam graf.",[1655,3564,3565,3568,3569,3568,3574,2054,3577],{},[101,3566,3567],{},"Pemilihan"," ",[1758,3570,3571],{},[101,3572,3573],{},"Node",[101,3575,3576],{},"Saat Ini",[1652,3578,3579],{},[1655,3580,3581,3582,3584,3585,3587,3588,3591,3592,3594],{},"Dari set ",[1758,3583,3508],{}," yang belum dikunjungi, pilih ",[1758,3586,3508],{}," dengan jarak sementara terkecil. Ini akan menjadi ",[101,3589,3590],{},"current node"," atau ",[1758,3593,3508],{}," yang sedang \"diperiksa\".",[1655,3596,3597,2054,3600],{},[101,3598,3599],{},"Pembaruan Jarak Tetangga",[1652,3601,3602],{},[1655,3603,3604,3605,3608,3609,2054,3611],{},"Untuk setiap ",[101,3606,3607],{},"tetangga"," dari ",[1758,3610,3590],{},[1652,3612,3613,3646],{},[1655,3614,3615,3616,3618,3619,3621,3622,3568,3625,3568,3629,3568,3632,3568,3636,3568,3639,3568,3643,1750],{},"Hitung jarak baru dari ",[1758,3617,3508],{}," sumber ke tetangga tersebut melalui ",[1758,3620,3590],{},". Caranya adalah ",[101,3623,3624],{},"jarak",[1758,3626,3627],{},[101,3628,3590],{},[101,3630,3631],{},"(dari sumber) + bobot",[1758,3633,3634],{},[101,3635,3495],{},[101,3637,3638],{},"dari",[1758,3640,3641],{},[101,3642,3590],{},[101,3644,3645],{},"ke tetangga",[1655,3647,3648,3649,3652,3653,3655,3656,3659],{},"Jika jarak baru ini lebih kecil dari jarak sementara yang sudah ada untuk tetangga tersebut, ",[101,3650,3651],{},"perbarui jarak sementara tetangga"," dan catat ",[1758,3654,3590],{}," sebagai ",[101,3657,3658],{},"pendahulu (predecessor)"," dari tetangga tersebut. Ini penting untuk merekonstruksi jalur nantinya.",[1655,3661,3662,3568,3665,3568,3669,2054,3672],{},[101,3663,3664],{},"Tandai",[1758,3666,3667],{},[101,3668,3573],{},[101,3670,3671],{},"Sebagai Telah Dikunjungi",[1652,3673,3674],{},[1655,3675,3676,3677,3679,3680,3682,3683,3685,3686,3688],{},"Setelah semua tetangga ",[1758,3678,3590],{}," diperiksa dan jaraknya diperbarui jika perlu, ",[1758,3681,3590],{}," dihapus dari set ",[1758,3684,3508],{}," yang belum dikunjungi. Ini berarti jalur terpendek ke ",[1758,3687,3508],{}," tersebut telah \"ditemukan\" dan \"final\".",[1655,3690,3691,2054,3694],{},[101,3692,3693],{},"Ulangi",[1652,3695,3696],{},[1655,3697,3698,3699,3701,3702,3704,3705,3707],{},"Langkah 2 sampai 4 diulang sampai set ",[1758,3700,3508],{}," yang belum dikunjungi kosong, atau sampai ",[1758,3703,3508],{}," tujuan yang spesifik telah \"diselesaikan\" (jika kamu hanya mencari jalur ke satu ",[1758,3706,3508],{}," tertentu).",[85,3709,3711],{"id":3710},"ilustrasi-sederhana","Ilustrasi Sederhana:",[17,3713,3714],{},"Misalkan kita punya graf ini:",[109,3716,3718],{"className":1994,"code":3717,"language":1996,"meta":15,"style":15},"A --(1)--> B --(3)--> D\n|           ^          ^\n(4)         |          |\n|           (1)        (2)\nv           |          |\nC --(1)-----+          E\n",[71,3719,3720,3755,3766,3781,3799,3808],{"__ignoreMap":15},[118,3721,3722,3724,3727,3729,3732,3735,3738,3741,3743,3745,3748,3750,3752],{"class":120,"line":121},[118,3723,2087],{"class":182},[118,3725,3726],{"class":151}," --",[118,3728,391],{"class":124},[118,3730,3731],{"class":182},"1",[118,3733,3734],{"class":124},")",[118,3736,3737],{"class":151},"-->",[118,3739,3740],{"class":182}," B",[118,3742,3726],{"class":151},[118,3744,391],{"class":124},[118,3746,3747],{"class":182},"3",[118,3749,3734],{"class":124},[118,3751,3737],{"class":151},[118,3753,3754],{"class":182}," D\n",[118,3756,3757,3760,3763],{"class":120,"line":25},[118,3758,3759],{"class":151},"|",[118,3761,3762],{"class":151},"           ^",[118,3764,3765],{"class":151},"          ^\n",[118,3767,3768,3770,3773,3776,3778],{"class":120,"line":170},[118,3769,391],{"class":124},[118,3771,3772],{"class":182},"4",[118,3774,3775],{"class":124},")         ",[118,3777,3759],{"class":151},[118,3779,3780],{"class":151},"          |\n",[118,3782,3783,3785,3788,3790,3793,3796],{"class":120,"line":176},[118,3784,3759],{"class":151},[118,3786,3787],{"class":124},"           (",[118,3789,3731],{"class":182},[118,3791,3792],{"class":124},")        (",[118,3794,3795],{"class":182},"2",[118,3797,3798],{"class":124},")\n",[118,3800,3801,3804,3806],{"class":120,"line":195},[118,3802,3803],{"class":124},"v           ",[118,3805,3759],{"class":151},[118,3807,3780],{"class":151},[118,3809,3810,3812,3814,3816,3818,3820,3823],{"class":120,"line":201},[118,3811,2125],{"class":182},[118,3813,3726],{"class":151},[118,3815,391],{"class":124},[118,3817,3731],{"class":182},[118,3819,3734],{"class":124},[118,3821,3822],{"class":151},"-----+",[118,3824,3825],{"class":182},"          E\n",[17,3827,3828,3829,3831,3832,3834],{},"Dan kita ingin mencari jalur terpendek dari ",[101,3830,2087],{}," ke semua ",[1758,3833,3508],{}," lainnya.",[1652,3836,3837,3861,3878,3895,3909,3923],{},[1655,3838,3839,2054,3841],{},[101,3840,3535],{},[1652,3842,3843,3846,3849,3852,3855,3858],{},[1655,3844,3845],{},"A: 0",[1655,3847,3848],{},"B: âˆ",[1655,3850,3851],{},"C: âˆ",[1655,3853,3854],{},"D: âˆ",[1655,3856,3857],{},"E: âˆ",[1655,3859,3860],{},"Belum Dikunjungi: {A, B, C, D, E}",[1655,3862,3863,3866,3867],{},[101,3864,3865],{},"Langkah 1",": Pilih A (jarak 0).\n",[1652,3868,3869,3872,3875],{},[1655,3870,3871],{},"Perbarui B: dist(A) + w(A,B) = 0 + 1 = 1. dist(B) = 1. Pendahulu B = A.",[1655,3873,3874],{},"Perbarui C: dist(A) + w(A,C) = 0 + 4 = 4. dist(C) = 4. Pendahulu C = A.",[1655,3876,3877],{},"A selesai. Belum Dikunjungi: {B, C, D, E}",[1655,3879,3880,3883,3884],{},[101,3881,3882],{},"Langkah 2",": Pilih B (jarak 1).\n",[1652,3885,3886,3889,3892],{},[1655,3887,3888],{},"Perbarui D: dist(B) + w(B,D) = 1 + 3 = 4. dist(D) = 4. Pendahulu D = B.",[1655,3890,3891],{},"Perbarui C: dist(B) + w(B,C) = 1 + 1 = 2. dist(C) saat ini 4. Karena 2 \u003C 4, perbarui dist(C) = 2. Pendahulu C = B.",[1655,3893,3894],{},"B selesai. Belum Dikunjungi: {C, D, E}",[1655,3896,3897,3900,3901],{},[101,3898,3899],{},"Langkah 3",": Pilih C (jarak 2).\n",[1652,3902,3903,3906],{},[1655,3904,3905],{},"C tidak punya tetangga yang belum dikunjungi.",[1655,3907,3908],{},"C selesai. Belum Dikunjungi: {D, E}",[1655,3910,3911,3914,3915],{},[101,3912,3913],{},"Langkah 4",": Pilih D (jarak 4).\n",[1652,3916,3917,3920],{},[1655,3918,3919],{},"Perbarui E: dist(D) + w(D,E) = 4 + 2 = 6. dist(E) = 6. Pendahulu E = D.",[1655,3921,3922],{},"D selesai. Belum Dikunjungi: {E}",[1655,3924,3925,3928,3929],{},[101,3926,3927],{},"Langkah 5",": Pilih E (jarak 6).\n",[1652,3930,3931,3934],{},[1655,3932,3933],{},"E tidak punya tetangga yang belum dikunjungi.",[1655,3935,3936],{},"E selesai. Belum Dikunjungi: {}",[17,3938,3939],{},[101,3940,3941],{},"Hasil Akhir (Jarak Terpendek dari A):",[1652,3943,3944,3946,3949,3952,3955],{},[1655,3945,3845],{},[1655,3947,3948],{},"B: 1 (A -> B)",[1655,3950,3951],{},"C: 2 (A -> B -> C)",[1655,3953,3954],{},"D: 4 (A -> B -> D)",[1655,3956,3957],{},"E: 6 (A -> B -> D -> E)",[85,3959,3961],{"id":3960},"kapan-menggunakan-dijkstra","Kapan Menggunakan Dijkstra?",[17,3963,3964],{},"Algoritma Dijkstra sangat berguna dalam berbagai skenario:",[1652,3966,3967,3973,3979,3985],{},[1655,3968,3969,3972],{},[101,3970,3971],{},"Pencarian Rute GPS",": Menemukan jalur terpendek atau tercepat antar lokasi.",[1655,3974,3975,3978],{},[101,3976,3977],{},"Jaringan Komputer",": Menemukan jalur terbaik untuk paket data.",[1655,3980,3981,3984],{},[101,3982,3983],{},"Logistik dan Pengiriman",": Mengoptimalkan rute pengiriman barang.",[1655,3986,3987,3990],{},[101,3988,3989],{},"Game Development",": Menemukan jalur untuk AI (Artificial Intelligence) musuh atau karakter.",[85,3992,3994],{"id":3993},"batasan-algoritma-dijkstra","Batasan Algoritma Dijkstra",[17,3996,3997,3998,3568,4001,3568,4005,4008,4009,4012,4013,4015],{},"Penting untuk dicatat bahwa Dijkstra ",[101,3999,4000],{},"tidak dapat bekerja dengan",[1758,4002,4003],{},[101,4004,3495],{},[101,4006,4007],{},"yang memiliki bobot negatif",". Jika grafmu memiliki bobot negatif, kamu perlu menggunakan algoritma lain seperti ",[101,4010,4011],{},"Bellman-Ford",". Hal ini karena bobot negatif dapat mengacaukan logika \"rakus\" Dijkstra, di mana jalur yang awalnya terlihat lebih panjang bisa menjadi lebih pendek setelah melewati ",[1758,4014,3495],{}," berbobot negatif.",[17,4017,4018],{},"Semoga penjelasan ini cukup jelas dan informatif untuk artikelmu! Apakah ada bagian lain yang ingin kamu tambahkan atau jelaskan lebih lanjut?",[308,4020,4021],{},"html pre.shiki code .sAPL1, html code.shiki .sAPL1{--shiki-dark:#79B8FF;--shiki-default:#79B8FF;--shiki-light:#005CC5}html pre.shiki code .sEiGg, html code.shiki .sEiGg{--shiki-dark:#F97583;--shiki-default:#F97583;--shiki-light:#D73A49}html pre.shiki code .suVJd, html code.shiki .suVJd{--shiki-dark:#E1E4E8;--shiki-default:#E1E4E8;--shiki-light:#24292E}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}",{"title":15,"searchDepth":25,"depth":25,"links":4023},[4024,4025,4026,4027,4028],{"id":3464,"depth":170,"text":3465},{"id":3519,"depth":170,"text":3520},{"id":3710,"depth":170,"text":3711},{"id":3960,"depth":170,"text":3961},{"id":3993,"depth":170,"text":3994},"19/06/2025","Selami dunia pencarian jalur terpendek dengan salah satu algoritma paling fundamental.",{"script":4032},[4033],{"type":1781,"key":1782,"data-nuxt-schema-org":30,"nodes":4034},[4035],{"_resolver":1785},"/articles/1.jpeg",{},{"props":4039},{},"/en/articles/djikstra-algorithm",{"_resolver":1785},{"title":3452,"description":4030},{"loc":4040,"videos":4044,"images":4045,"lastmod":2579},[],[],"en/articles/djikstra-algorithm",[],"JkYGUmcz3xYypUr3CePPtGRVL5plRyH0MRGCdLUItjs",{"id":4050,"title":4051,"body":4052,"date":27,"description":4633,"extension":28,"head":4634,"image":4639,"meta":4640,"navigation":30,"ogImage":4641,"path":4643,"readingTime":27,"robots":27,"schemaOrg":4644,"seo":4645,"sitemap":4646,"stem":4649,"tags":4650,"__hash__":4651},"articles_en/en/articles/fractional-knapsack.md","Memahami Fractional Knapsack Problem",{"type":7,"value":4053,"toc":4622},[4054,4058,4384,4386,4527,4529,4533,4538,4542,4547,4549,4569,4571,4588,4590,4601,4603,4613,4620],[269,4055,4057],{"id":4056},"fractional-knapsack","FRACTIONAL KNAPSACK",[109,4059,4061],{"className":1129,"code":4060,"language":1131,"meta":15,"style":15},"# ğŸ’ Apa itu Fractional Knapsack Problem?\n\n**Fractional Knapsack Problem** adalah masalah optimisasi klasik yang menggunakan **algoritma greedy** untuk memilih item dengan **nilai maksimum** yang dapat dimasukkan ke dalam tas (knapsack) dengan kapasitas terbatas.\n\nğŸ”„ **Berbeda dengan 0/1 Knapsack**, dalam masalah ini **item dapat diambil sebagian (fraksional)**.\n\n---\n\n## ğŸ’¡ Aplikasi Fractional Knapsack\n\n- ğŸ’° Manajemen anggaran dan sumber daya terbatas\n- ğŸ“ˆ Pemilihan investasi dalam portofolio\n- ğŸš› Logistik dan distribusi barang\n- ğŸ§® Pengolahan data berdasarkan prioritas\n\n---\n\n## âš™ï¸ Cara Kerja Algoritma\n\n1. **Hitung rasio nilai/berat (value/weight)** untuk setiap item\n2. **Urutkan item** berdasarkan rasio tersebut secara menurun (descending)\n3. **Pilih item secara greedy**:\n   - Jika seluruh berat item â‰¤ kapasitas sisa â†’ ambil penuh\n   - Jika berat item > kapasitas sisa â†’ ambil sebagian (fraksi)\n4. **Akumulasikan nilai** dan kurangi kapasitas\n\n---\n\n## ğŸ“Š Contoh Masalah\n\nKita punya knapsack dengan kapasitas **50 unit**, dan 3 item berikut:\n\n| Item | Nilai | Berat | Rasio Nilai/Berat |\n|------|-------|--------|-------------------|\n| I1   | 60    | 10     | 6.0               |\n| I2   | 100   | 20     | 5.0               |\n| I3   | 120   | 30     | 4.0               |\n\n### ğŸ”¢ Langkah-langkah:\n- Urutkan: I1 (6), I2 (5), I3 (4)\n- Ambil I1 penuh (10): nilai += 60, kapasitas = 40\n- Ambil I2 penuh (20): nilai += 100, kapasitas = 20\n- Ambil 2/3 dari I3 (20 dari 30): nilai += 80\n- âœ… **Total nilai: 60 + 100 + 80 = 240**\n\n---\n\n## ğŸ Implementasi Python\n\n```python\ndef fractional_knapsack(values, weights, capacity):\n    items = [(v / w, v, w) for v, w in zip(values, weights)]\n    items.sort(reverse=True)  # Urutkan berdasarkan rasio\n    \n    total_value = 0\n    for ratio, value, weight in items:\n        if capacity >= weight:\n            total_value += value\n            capacity -= weight\n        else:\n            total_value += value * (capacity / weight)\n            break\n    return total_value\n\n# Contoh penggunaan\nvalues = [60, 100, 120]\nweights = [10, 20, 30]\ncapacity = 50\nprint(\"Nilai maksimum:\", fractional_knapsack(values, weights, capacity))\n",[71,4062,4063,4068,4072,4077,4081,4086,4090,4094,4098,4103,4107,4112,4117,4122,4127,4131,4135,4139,4144,4148,4153,4158,4163,4168,4173,4178,4182,4186,4190,4195,4199,4204,4208,4213,4218,4223,4228,4233,4237,4242,4247,4252,4257,4262,4267,4271,4275,4279,4283,4287,4291,4296,4301,4306,4311,4316,4321,4326,4331,4336,4341,4346,4351,4356,4360,4364,4369,4374,4379],{"__ignoreMap":15},[118,4064,4065],{"class":120,"line":121},[118,4066,4067],{},"# ğŸ’ Apa itu Fractional Knapsack Problem?\n",[118,4069,4070],{"class":120,"line":25},[118,4071,173],{"emptyLinePlaceholder":30},[118,4073,4074],{"class":120,"line":170},[118,4075,4076],{},"**Fractional Knapsack Problem** adalah masalah optimisasi klasik yang menggunakan **algoritma greedy** untuk memilih item dengan **nilai maksimum** yang dapat dimasukkan ke dalam tas (knapsack) dengan kapasitas terbatas.\n",[118,4078,4079],{"class":120,"line":176},[118,4080,173],{"emptyLinePlaceholder":30},[118,4082,4083],{"class":120,"line":195},[118,4084,4085],{},"ğŸ”„ **Berbeda dengan 0/1 Knapsack**, dalam masalah ini **item dapat diambil sebagian (fraksional)**.\n",[118,4087,4088],{"class":120,"line":201},[118,4089,173],{"emptyLinePlaceholder":30},[118,4091,4092],{"class":120,"line":207},[118,4093,1165],{},[118,4095,4096],{"class":120,"line":216},[118,4097,173],{"emptyLinePlaceholder":30},[118,4099,4100],{"class":120,"line":222},[118,4101,4102],{},"## ğŸ’¡ Aplikasi Fractional Knapsack\n",[118,4104,4105],{"class":120,"line":228},[118,4106,173],{"emptyLinePlaceholder":30},[118,4108,4109],{"class":120,"line":238},[118,4110,4111],{},"- ğŸ’° Manajemen anggaran dan sumber daya terbatas\n",[118,4113,4114],{"class":120,"line":243},[118,4115,4116],{},"- ğŸ“ˆ Pemilihan investasi dalam portofolio\n",[118,4118,4119],{"class":120,"line":252},[118,4120,4121],{},"- ğŸš› Logistik dan distribusi barang\n",[118,4123,4124],{"class":120,"line":263},[118,4125,4126],{},"- ğŸ§® Pengolahan data berdasarkan prioritas\n",[118,4128,4129],{"class":120,"line":279},[118,4130,173],{"emptyLinePlaceholder":30},[118,4132,4133],{"class":120,"line":289},[118,4134,1165],{},[118,4136,4137],{"class":120,"line":298},[118,4138,173],{"emptyLinePlaceholder":30},[118,4140,4141],{"class":120,"line":303},[118,4142,4143],{},"## âš™ï¸ Cara Kerja Algoritma\n",[118,4145,4146],{"class":120,"line":316},[118,4147,173],{"emptyLinePlaceholder":30},[118,4149,4150],{"class":120,"line":321},[118,4151,4152],{},"1. **Hitung rasio nilai/berat (value/weight)** untuk setiap item\n",[118,4154,4155],{"class":120,"line":666},[118,4156,4157],{},"2. **Urutkan item** berdasarkan rasio tersebut secara menurun (descending)\n",[118,4159,4160],{"class":120,"line":1036},[118,4161,4162],{},"3. **Pilih item secara greedy**:\n",[118,4164,4165],{"class":120,"line":1042},[118,4166,4167],{},"   - Jika seluruh berat item â‰¤ kapasitas sisa â†’ ambil penuh\n",[118,4169,4170],{"class":120,"line":1242},[118,4171,4172],{},"   - Jika berat item > kapasitas sisa â†’ ambil sebagian (fraksi)\n",[118,4174,4175],{"class":120,"line":1248},[118,4176,4177],{},"4. **Akumulasikan nilai** dan kurangi kapasitas\n",[118,4179,4180],{"class":120,"line":1254},[118,4181,173],{"emptyLinePlaceholder":30},[118,4183,4184],{"class":120,"line":1259},[118,4185,1165],{},[118,4187,4188],{"class":120,"line":1265},[118,4189,173],{"emptyLinePlaceholder":30},[118,4191,4192],{"class":120,"line":1270},[118,4193,4194],{},"## ğŸ“Š Contoh Masalah\n",[118,4196,4197],{"class":120,"line":1275},[118,4198,173],{"emptyLinePlaceholder":30},[118,4200,4201],{"class":120,"line":1280},[118,4202,4203],{},"Kita punya knapsack dengan kapasitas **50 unit**, dan 3 item berikut:\n",[118,4205,4206],{"class":120,"line":1286},[118,4207,173],{"emptyLinePlaceholder":30},[118,4209,4210],{"class":120,"line":1291},[118,4211,4212],{},"| Item | Nilai | Berat | Rasio Nilai/Berat |\n",[118,4214,4215],{"class":120,"line":1297},[118,4216,4217],{},"|------|-------|--------|-------------------|\n",[118,4219,4220],{"class":120,"line":1302},[118,4221,4222],{},"| I1   | 60    | 10     | 6.0               |\n",[118,4224,4225],{"class":120,"line":1308},[118,4226,4227],{},"| I2   | 100   | 20     | 5.0               |\n",[118,4229,4230],{"class":120,"line":1314},[118,4231,4232],{},"| I3   | 120   | 30     | 4.0               |\n",[118,4234,4235],{"class":120,"line":1320},[118,4236,173],{"emptyLinePlaceholder":30},[118,4238,4239],{"class":120,"line":1326},[118,4240,4241],{},"### ğŸ”¢ Langkah-langkah:\n",[118,4243,4244],{"class":120,"line":1332},[118,4245,4246],{},"- Urutkan: I1 (6), I2 (5), I3 (4)\n",[118,4248,4249],{"class":120,"line":1338},[118,4250,4251],{},"- Ambil I1 penuh (10): nilai += 60, kapasitas = 40\n",[118,4253,4254],{"class":120,"line":1344},[118,4255,4256],{},"- Ambil I2 penuh (20): nilai += 100, kapasitas = 20\n",[118,4258,4259],{"class":120,"line":1349},[118,4260,4261],{},"- Ambil 2/3 dari I3 (20 dari 30): nilai += 80\n",[118,4263,4264],{"class":120,"line":1355},[118,4265,4266],{},"- âœ… **Total nilai: 60 + 100 + 80 = 240**\n",[118,4268,4269],{"class":120,"line":1360},[118,4270,173],{"emptyLinePlaceholder":30},[118,4272,4273],{"class":120,"line":1366},[118,4274,1165],{},[118,4276,4277],{"class":120,"line":1372},[118,4278,173],{"emptyLinePlaceholder":30},[118,4280,4281],{"class":120,"line":1378},[118,4282,1419],{},[118,4284,4285],{"class":120,"line":1384},[118,4286,173],{"emptyLinePlaceholder":30},[118,4288,4289],{"class":120,"line":1390},[118,4290,1430],{},[118,4292,4293],{"class":120,"line":1395},[118,4294,4295],{},"def fractional_knapsack(values, weights, capacity):\n",[118,4297,4298],{"class":120,"line":1401},[118,4299,4300],{},"    items = [(v / w, v, w) for v, w in zip(values, weights)]\n",[118,4302,4303],{"class":120,"line":1406},[118,4304,4305],{},"    items.sort(reverse=True)  # Urutkan berdasarkan rasio\n",[118,4307,4308],{"class":120,"line":1411},[118,4309,4310],{},"    \n",[118,4312,4313],{"class":120,"line":1416},[118,4314,4315],{},"    total_value = 0\n",[118,4317,4318],{"class":120,"line":1422},[118,4319,4320],{},"    for ratio, value, weight in items:\n",[118,4322,4323],{"class":120,"line":1427},[118,4324,4325],{},"        if capacity >= weight:\n",[118,4327,4328],{"class":120,"line":1433},[118,4329,4330],{},"            total_value += value\n",[118,4332,4333],{"class":120,"line":1439},[118,4334,4335],{},"            capacity -= weight\n",[118,4337,4338],{"class":120,"line":1445},[118,4339,4340],{},"        else:\n",[118,4342,4343],{"class":120,"line":1451},[118,4344,4345],{},"            total_value += value * (capacity / weight)\n",[118,4347,4348],{"class":120,"line":1457},[118,4349,4350],{},"            break\n",[118,4352,4353],{"class":120,"line":1462},[118,4354,4355],{},"    return total_value\n",[118,4357,4358],{"class":120,"line":1468},[118,4359,173],{"emptyLinePlaceholder":30},[118,4361,4362],{"class":120,"line":1474},[118,4363,1505],{},[118,4365,4366],{"class":120,"line":1480},[118,4367,4368],{},"values = [60, 100, 120]\n",[118,4370,4371],{"class":120,"line":1486},[118,4372,4373],{},"weights = [10, 20, 30]\n",[118,4375,4376],{"class":120,"line":1491},[118,4377,4378],{},"capacity = 50\n",[118,4380,4381],{"class":120,"line":1497},[118,4382,4383],{},"print(\"Nilai maksimum:\", fractional_knapsack(values, weights, capacity))\n",[53,4385,1533],{"id":1532},[109,4387,4389],{"className":1536,"code":4388,"language":1538,"meta":15,"style":15},"function fractionalKnapsack(values, weights, capacity) {\n    const items = values.map((v, i) => ({\n        ratio: v / weights[i],\n        value: v,\n        weight: weights[i],\n    }));\n\n    items.sort((a, b) => b.ratio - a.ratio);\n\n    let totalValue = 0;\n\n    for (let item of items) {\n        if (capacity >= item.weight) {\n            totalValue += item.value;\n            capacity -= item.weight;\n        } else {\n            totalValue += item.value * (capacity / item.weight);\n            break;\n        }\n    }\n\n    return totalValue;\n}\n\n// Contoh penggunaan\nconst values = [60, 100, 120];\nconst weights = [10, 20, 30];\nconst capacity = 50;\nconsole.log(\"Nilai maksimum:\", fractionalKnapsack(values, weights, capacity));\n",[71,4390,4391,4396,4401,4406,4411,4416,4421,4425,4430,4434,4439,4443,4448,4453,4458,4463,4468,4473,4478,4482,4486,4490,4495,4499,4503,4507,4512,4517,4522],{"__ignoreMap":15},[118,4392,4393],{"class":120,"line":121},[118,4394,4395],{},"function fractionalKnapsack(values, weights, capacity) {\n",[118,4397,4398],{"class":120,"line":25},[118,4399,4400],{},"    const items = values.map((v, i) => ({\n",[118,4402,4403],{"class":120,"line":170},[118,4404,4405],{},"        ratio: v / weights[i],\n",[118,4407,4408],{"class":120,"line":176},[118,4409,4410],{},"        value: v,\n",[118,4412,4413],{"class":120,"line":195},[118,4414,4415],{},"        weight: weights[i],\n",[118,4417,4418],{"class":120,"line":201},[118,4419,4420],{},"    }));\n",[118,4422,4423],{"class":120,"line":207},[118,4424,173],{"emptyLinePlaceholder":30},[118,4426,4427],{"class":120,"line":216},[118,4428,4429],{},"    items.sort((a, b) => b.ratio - a.ratio);\n",[118,4431,4432],{"class":120,"line":222},[118,4433,173],{"emptyLinePlaceholder":30},[118,4435,4436],{"class":120,"line":228},[118,4437,4438],{},"    let totalValue = 0;\n",[118,4440,4441],{"class":120,"line":238},[118,4442,173],{"emptyLinePlaceholder":30},[118,4444,4445],{"class":120,"line":243},[118,4446,4447],{},"    for (let item of items) {\n",[118,4449,4450],{"class":120,"line":252},[118,4451,4452],{},"        if (capacity >= item.weight) {\n",[118,4454,4455],{"class":120,"line":263},[118,4456,4457],{},"            totalValue += item.value;\n",[118,4459,4460],{"class":120,"line":279},[118,4461,4462],{},"            capacity -= item.weight;\n",[118,4464,4465],{"class":120,"line":289},[118,4466,4467],{},"        } else {\n",[118,4469,4470],{"class":120,"line":298},[118,4471,4472],{},"            totalValue += item.value * (capacity / item.weight);\n",[118,4474,4475],{"class":120,"line":303},[118,4476,4477],{},"            break;\n",[118,4479,4480],{"class":120,"line":316},[118,4481,1598],{},[118,4483,4484],{"class":120,"line":321},[118,4485,621],{},[118,4487,4488],{"class":120,"line":666},[118,4489,173],{"emptyLinePlaceholder":30},[118,4491,4492],{"class":120,"line":1036},[118,4493,4494],{},"    return totalValue;\n",[118,4496,4497],{"class":120,"line":1042},[118,4498,757],{},[118,4500,4501],{"class":120,"line":1242},[118,4502,173],{"emptyLinePlaceholder":30},[118,4504,4505],{"class":120,"line":1248},[118,4506,1624],{},[118,4508,4509],{"class":120,"line":1254},[118,4510,4511],{},"const values = [60, 100, 120];\n",[118,4513,4514],{"class":120,"line":1259},[118,4515,4516],{},"const weights = [10, 20, 30];\n",[118,4518,4519],{"class":120,"line":1265},[118,4520,4521],{},"const capacity = 50;\n",[118,4523,4524],{"class":120,"line":1270},[118,4525,4526],{},"console.log(\"Nilai maksimum:\", fractionalKnapsack(values, weights, capacity));\n",[53,4528,1643],{"id":1642},[85,4530,1647,4531],{"id":1646},[101,4532,1650],{},[1652,4534,4535],{},[1655,4536,4537],{},"Karena pengurutan berdasarkan rasio",[85,4539,1661,4540],{"id":1660},[101,4541,1664],{},[1652,4543,4544],{},[1655,4545,4546],{},"Untuk menyimpan daftar item dan hasil",[85,4548,1673],{"id":1672},[1652,4550,4551,4557,4563],{},[1655,4552,4553,4556],{},[101,4554,4555],{},"In-place sorting"," â†’ hemat memori",[1655,4558,4559,4562],{},[101,4560,4561],{},"Parallel sort"," â†’ untuk skala besar",[1655,4564,4565,4568],{},[101,4566,4567],{},"Pre-sorting"," â†’ jika data sudah terurut",[53,4570,1690],{"id":1689},[1652,4572,4573,4576,4582],{},[1655,4574,4575],{},"Greedy, efisien, dan mudah diimplementasikan",[1655,4577,4578,4579],{},"Menjamin ",[101,4580,4581],{},"solusi optimal",[1655,4583,4584,4585],{},"Mendukung ",[101,4586,4587],{},"pengambilan fraksional",[53,4589,1711],{"id":1710},[1652,4591,4592,4595,4598],{},[1655,4593,4594],{},"Tidak cocok untuk item yang harus diambil utuh (gunakan 0/1 Knapsack)",[1655,4596,4597],{},"Perlu sorting terlebih dahulu",[1655,4599,4600],{},"Hanya mengoptimalkan berdasarkan rasio, tidak mempertimbangkan kombinasi",[53,4602,1732],{"id":1731},[17,4604,4605,4608,4609,4612],{},[101,4606,4607],{},"Fractional Knapsack Problem"," adalah contoh sempurna penggunaan algoritma greedy untuk ",[101,4610,4611],{},"masalah optimisasi nilai maksimum"," dalam batasan kapasitas. Dengan memilih berdasarkan rasio nilai per berat, algoritma ini menawarkan efisiensi tinggi dan solusi optimal untuk berbagai aplikasi dunia nyata.",[1752,4614,4615],{},[17,4616,1701,4617],{},[1758,4618,4619],{},"Simple yet powerful. Fractional Knapsack shows how greedy choice leads to global optimum when conditions are right.",[308,4621,1763],{},{"title":15,"searchDepth":25,"depth":25,"links":4623},[4624,4625,4630,4631,4632],{"id":1532,"depth":25,"text":1533},{"id":1642,"depth":25,"text":1643,"children":4626},[4627,4628,4629],{"id":1646,"depth":170,"text":1770},{"id":1660,"depth":170,"text":1772},{"id":1672,"depth":170,"text":1673},{"id":1689,"depth":25,"text":1690},{"id":1710,"depth":25,"text":1711},{"id":1731,"depth":25,"text":1732},"Pelajari bagaimana memaksimalkan nilai dalam knapsack dengan kapasitas terbatas menggunakan pendekatan greedy.",{"script":4635},[4636],{"type":1781,"key":1782,"data-nuxt-schema-org":30,"nodes":4637},[4638],{"_resolver":1785},"/articles/9.jpeg",{},{"props":4642},{},"/en/articles/fractional-knapsack",{"_resolver":1785},{"title":4051,"description":4633},{"loc":4643,"videos":4647,"images":4648,"lastmod":2579},[],[],"en/articles/fractional-knapsack",[],"jLyeOKxCtnDjEnc1pcUJBABVsLW5U2ekO9hhxAtP8nk",{"id":4653,"title":4654,"body":4655,"date":27,"description":5599,"extension":28,"head":5600,"image":5605,"meta":5606,"navigation":30,"ogImage":5607,"path":5609,"readingTime":27,"robots":27,"schemaOrg":5610,"seo":5611,"sitemap":5612,"stem":5615,"tags":5616,"__hash__":5617},"articles_en/en/articles/huffman-coding.md","Memahami Algoritma Huffman Coding",{"type":7,"value":4656,"toc":5588},[4657,4661,5184,5188,5457,5460,5464,5471,5475,5490,5493,5517,5521,5544,5546,5560,5562,5576,5579,5586],[269,4658,4660],{"id":4659},"huffman-coding","HUFFMAN CODING",[109,4662,4664],{"className":1129,"code":4663,"language":1131,"meta":15,"style":15},"# Apa itu Huffman Coding?\n\n**Huffman Coding** adalah algoritma kompresi data yang menggunakan pendekatan **greedy** untuk membuat **kode biner dengan panjang variabel**. Karakter yang lebih sering muncul diberi kode yang lebih pendek, dan karakter yang lebih jarang diberi kode yang lebih panjang.\n\n---\n\n## ğŸ”§ Aplikasi Huffman Coding\n- ğŸ“¦ Kompresi file (ZIP, JPEG)\n- ğŸ“¡ Komunikasi data (pengurangan bandwidth)\n- ğŸ’¾ Penyimpanan data (penghematan ruang)\n- ğŸ” Kriptografi (penyandian berbasis frekuensi)\n\n---\n\n## ğŸ”„ Cara Kerja Huffman Coding\n\n### 1. **Hitung Frekuensi**\n- Hitung kemunculan setiap karakter.\n\n### 2. **Bangun Huffman Tree**\n- Buat node daun untuk tiap karakter.\n- Masukkan node ke dalam **min-heap** berdasarkan frekuensi.\n- Gabungkan dua node dengan frekuensi terkecil.\n- Ulangi hingga hanya tersisa satu node (akar pohon).\n\n### 3. **Hasilkan Kode**\n- Telusuri pohon dari akar ke tiap daun.\n- Tetapkan `0` ke cabang kiri dan `1` ke cabang kanan.\n- Karakter disandikan dengan jalur dari akar ke daunnya.\n\n---\n\n## ğŸ“Œ Contoh Masalah\n\n**Input:** `\"AABBCC\"`\n\n### Langkah-langkah:\n- Frekuensi: `A=2`, `B=2`, `C=2`\n- Min-heap awal: `[A:2, B:2, C:2]`\n- Gabung A dan B â†’ `AB:4`\n- Gabung AB dan C â†’ `ABC:6`\n- Hasil kode (contoh):\n  - A: `00`\n  - B: `01`\n  - C: `1`\n- Hasil encoding: `AABBCC` â†’ `000001011`\n\n**Efisiensi:**\n- ASCII: `6 Ã— 8 = 48 bit`\n- Huffman: `9 bit` â†’ Hemat ruang signifikan!\n\n---\n\n## ğŸ§ª Implementasi Python\n\n```python\nimport heapq\nfrom collections import Counter\n\nclass Node:\n    def __init__(self, char, freq):\n        self.char = char\n        self.freq = freq\n        self.left = None\n        self.right = None\n    \n    def __lt__(self, other):\n        return self.freq \u003C other.freq\n\ndef build_huffman_tree(data):\n    freq = Counter(data)\n    heap = [Node(char, f) for char, f in freq.items()]\n    heapq.heapify(heap)\n    \n    while len(heap) > 1:\n        left = heapq.heappop(heap)\n        right = heapq.heappop(heap)\n        parent = Node(None, left.freq + right.freq)\n        parent.left = left\n        parent.right = right\n        heapq.heappush(heap, parent)\n    \n    return heap[0]\n\ndef generate_codes(root, code=\"\", codes={}):\n    if root:\n        if root.char is not None:\n            codes[root.char] = code or \"0\"\n        generate_codes(root.left, code + \"0\", codes)\n        generate_codes(root.right, code + \"1\", codes)\n    return codes\n\ndef huffman_coding(data):\n    if not data:\n        return \"\", {}\n    root = build_huffman_tree(data)\n    codes = generate_codes(root)\n    encoded = ''.join(codes[char] for char in data)\n    return encoded, codes\n\n# Contoh penggunaan\ndata = \"AABBCC\"\nencoded, codes = huffman_coding(data)\nprint(\"Kode Huffman:\", codes)\nprint(\"Data tersandi:\", encoded)\n",[71,4665,4666,4671,4675,4680,4684,4688,4692,4697,4702,4707,4712,4717,4721,4725,4729,4734,4738,4743,4748,4752,4757,4762,4767,4772,4777,4781,4786,4791,4796,4801,4805,4809,4813,4818,4822,4827,4831,4836,4841,4846,4851,4856,4861,4866,4871,4876,4881,4885,4890,4895,4900,4904,4908,4912,4917,4921,4925,4930,4935,4939,4944,4949,4954,4959,4964,4969,4973,4978,4983,4987,4992,4997,5002,5007,5011,5016,5021,5026,5031,5036,5041,5046,5050,5056,5061,5067,5073,5079,5085,5091,5097,5103,5108,5114,5120,5126,5132,5138,5144,5150,5155,5160,5166,5172,5178],{"__ignoreMap":15},[118,4667,4668],{"class":120,"line":121},[118,4669,4670],{},"# Apa itu Huffman Coding?\n",[118,4672,4673],{"class":120,"line":25},[118,4674,173],{"emptyLinePlaceholder":30},[118,4676,4677],{"class":120,"line":170},[118,4678,4679],{},"**Huffman Coding** adalah algoritma kompresi data yang menggunakan pendekatan **greedy** untuk membuat **kode biner dengan panjang variabel**. Karakter yang lebih sering muncul diberi kode yang lebih pendek, dan karakter yang lebih jarang diberi kode yang lebih panjang.\n",[118,4681,4682],{"class":120,"line":176},[118,4683,173],{"emptyLinePlaceholder":30},[118,4685,4686],{"class":120,"line":195},[118,4687,1165],{},[118,4689,4690],{"class":120,"line":201},[118,4691,173],{"emptyLinePlaceholder":30},[118,4693,4694],{"class":120,"line":207},[118,4695,4696],{},"## ğŸ”§ Aplikasi Huffman Coding\n",[118,4698,4699],{"class":120,"line":216},[118,4700,4701],{},"- ğŸ“¦ Kompresi file (ZIP, JPEG)\n",[118,4703,4704],{"class":120,"line":222},[118,4705,4706],{},"- ğŸ“¡ Komunikasi data (pengurangan bandwidth)\n",[118,4708,4709],{"class":120,"line":228},[118,4710,4711],{},"- ğŸ’¾ Penyimpanan data (penghematan ruang)\n",[118,4713,4714],{"class":120,"line":238},[118,4715,4716],{},"- ğŸ” Kriptografi (penyandian berbasis frekuensi)\n",[118,4718,4719],{"class":120,"line":243},[118,4720,173],{"emptyLinePlaceholder":30},[118,4722,4723],{"class":120,"line":252},[118,4724,1165],{},[118,4726,4727],{"class":120,"line":263},[118,4728,173],{"emptyLinePlaceholder":30},[118,4730,4731],{"class":120,"line":279},[118,4732,4733],{},"## ğŸ”„ Cara Kerja Huffman Coding\n",[118,4735,4736],{"class":120,"line":289},[118,4737,173],{"emptyLinePlaceholder":30},[118,4739,4740],{"class":120,"line":298},[118,4741,4742],{},"### 1. **Hitung Frekuensi**\n",[118,4744,4745],{"class":120,"line":303},[118,4746,4747],{},"- Hitung kemunculan setiap karakter.\n",[118,4749,4750],{"class":120,"line":316},[118,4751,173],{"emptyLinePlaceholder":30},[118,4753,4754],{"class":120,"line":321},[118,4755,4756],{},"### 2. **Bangun Huffman Tree**\n",[118,4758,4759],{"class":120,"line":666},[118,4760,4761],{},"- Buat node daun untuk tiap karakter.\n",[118,4763,4764],{"class":120,"line":1036},[118,4765,4766],{},"- Masukkan node ke dalam **min-heap** berdasarkan frekuensi.\n",[118,4768,4769],{"class":120,"line":1042},[118,4770,4771],{},"- Gabungkan dua node dengan frekuensi terkecil.\n",[118,4773,4774],{"class":120,"line":1242},[118,4775,4776],{},"- Ulangi hingga hanya tersisa satu node (akar pohon).\n",[118,4778,4779],{"class":120,"line":1248},[118,4780,173],{"emptyLinePlaceholder":30},[118,4782,4783],{"class":120,"line":1254},[118,4784,4785],{},"### 3. **Hasilkan Kode**\n",[118,4787,4788],{"class":120,"line":1259},[118,4789,4790],{},"- Telusuri pohon dari akar ke tiap daun.\n",[118,4792,4793],{"class":120,"line":1265},[118,4794,4795],{},"- Tetapkan `0` ke cabang kiri dan `1` ke cabang kanan.\n",[118,4797,4798],{"class":120,"line":1270},[118,4799,4800],{},"- Karakter disandikan dengan jalur dari akar ke daunnya.\n",[118,4802,4803],{"class":120,"line":1275},[118,4804,173],{"emptyLinePlaceholder":30},[118,4806,4807],{"class":120,"line":1280},[118,4808,1165],{},[118,4810,4811],{"class":120,"line":1286},[118,4812,173],{"emptyLinePlaceholder":30},[118,4814,4815],{"class":120,"line":1291},[118,4816,4817],{},"## ğŸ“Œ Contoh Masalah\n",[118,4819,4820],{"class":120,"line":1297},[118,4821,173],{"emptyLinePlaceholder":30},[118,4823,4824],{"class":120,"line":1302},[118,4825,4826],{},"**Input:** `\"AABBCC\"`\n",[118,4828,4829],{"class":120,"line":1308},[118,4830,173],{"emptyLinePlaceholder":30},[118,4832,4833],{"class":120,"line":1314},[118,4834,4835],{},"### Langkah-langkah:\n",[118,4837,4838],{"class":120,"line":1320},[118,4839,4840],{},"- Frekuensi: `A=2`, `B=2`, `C=2`\n",[118,4842,4843],{"class":120,"line":1326},[118,4844,4845],{},"- Min-heap awal: `[A:2, B:2, C:2]`\n",[118,4847,4848],{"class":120,"line":1332},[118,4849,4850],{},"- Gabung A dan B â†’ `AB:4`\n",[118,4852,4853],{"class":120,"line":1338},[118,4854,4855],{},"- Gabung AB dan C â†’ `ABC:6`\n",[118,4857,4858],{"class":120,"line":1344},[118,4859,4860],{},"- Hasil kode (contoh):\n",[118,4862,4863],{"class":120,"line":1349},[118,4864,4865],{},"  - A: `00`\n",[118,4867,4868],{"class":120,"line":1355},[118,4869,4870],{},"  - B: `01`\n",[118,4872,4873],{"class":120,"line":1360},[118,4874,4875],{},"  - C: `1`\n",[118,4877,4878],{"class":120,"line":1366},[118,4879,4880],{},"- Hasil encoding: `AABBCC` â†’ `000001011`\n",[118,4882,4883],{"class":120,"line":1372},[118,4884,173],{"emptyLinePlaceholder":30},[118,4886,4887],{"class":120,"line":1378},[118,4888,4889],{},"**Efisiensi:**\n",[118,4891,4892],{"class":120,"line":1384},[118,4893,4894],{},"- ASCII: `6 Ã— 8 = 48 bit`\n",[118,4896,4897],{"class":120,"line":1390},[118,4898,4899],{},"- Huffman: `9 bit` â†’ Hemat ruang signifikan!\n",[118,4901,4902],{"class":120,"line":1395},[118,4903,173],{"emptyLinePlaceholder":30},[118,4905,4906],{"class":120,"line":1401},[118,4907,1165],{},[118,4909,4910],{"class":120,"line":1406},[118,4911,173],{"emptyLinePlaceholder":30},[118,4913,4914],{"class":120,"line":1411},[118,4915,4916],{},"## ğŸ§ª Implementasi Python\n",[118,4918,4919],{"class":120,"line":1416},[118,4920,173],{"emptyLinePlaceholder":30},[118,4922,4923],{"class":120,"line":1422},[118,4924,1430],{},[118,4926,4927],{"class":120,"line":1427},[118,4928,4929],{},"import heapq\n",[118,4931,4932],{"class":120,"line":1433},[118,4933,4934],{},"from collections import Counter\n",[118,4936,4937],{"class":120,"line":1439},[118,4938,173],{"emptyLinePlaceholder":30},[118,4940,4941],{"class":120,"line":1445},[118,4942,4943],{},"class Node:\n",[118,4945,4946],{"class":120,"line":1451},[118,4947,4948],{},"    def __init__(self, char, freq):\n",[118,4950,4951],{"class":120,"line":1457},[118,4952,4953],{},"        self.char = char\n",[118,4955,4956],{"class":120,"line":1462},[118,4957,4958],{},"        self.freq = freq\n",[118,4960,4961],{"class":120,"line":1468},[118,4962,4963],{},"        self.left = None\n",[118,4965,4966],{"class":120,"line":1474},[118,4967,4968],{},"        self.right = None\n",[118,4970,4971],{"class":120,"line":1480},[118,4972,4310],{},[118,4974,4975],{"class":120,"line":1486},[118,4976,4977],{},"    def __lt__(self, other):\n",[118,4979,4980],{"class":120,"line":1491},[118,4981,4982],{},"        return self.freq \u003C other.freq\n",[118,4984,4985],{"class":120,"line":1497},[118,4986,173],{"emptyLinePlaceholder":30},[118,4988,4989],{"class":120,"line":1502},[118,4990,4991],{},"def build_huffman_tree(data):\n",[118,4993,4994],{"class":120,"line":1508},[118,4995,4996],{},"    freq = Counter(data)\n",[118,4998,4999],{"class":120,"line":1514},[118,5000,5001],{},"    heap = [Node(char, f) for char, f in freq.items()]\n",[118,5003,5004],{"class":120,"line":1520},[118,5005,5006],{},"    heapq.heapify(heap)\n",[118,5008,5009],{"class":120,"line":1526},[118,5010,4310],{},[118,5012,5013],{"class":120,"line":3289},[118,5014,5015],{},"    while len(heap) > 1:\n",[118,5017,5018],{"class":120,"line":3298},[118,5019,5020],{},"        left = heapq.heappop(heap)\n",[118,5022,5023],{"class":120,"line":3303},[118,5024,5025],{},"        right = heapq.heappop(heap)\n",[118,5027,5028],{"class":120,"line":3309},[118,5029,5030],{},"        parent = Node(None, left.freq + right.freq)\n",[118,5032,5033],{"class":120,"line":3315},[118,5034,5035],{},"        parent.left = left\n",[118,5037,5038],{"class":120,"line":3324},[118,5039,5040],{},"        parent.right = right\n",[118,5042,5043],{"class":120,"line":3329},[118,5044,5045],{},"        heapq.heappush(heap, parent)\n",[118,5047,5048],{"class":120,"line":3334},[118,5049,4310],{},[118,5051,5053],{"class":120,"line":5052},83,[118,5054,5055],{},"    return heap[0]\n",[118,5057,5059],{"class":120,"line":5058},84,[118,5060,173],{"emptyLinePlaceholder":30},[118,5062,5064],{"class":120,"line":5063},85,[118,5065,5066],{},"def generate_codes(root, code=\"\", codes={}):\n",[118,5068,5070],{"class":120,"line":5069},86,[118,5071,5072],{},"    if root:\n",[118,5074,5076],{"class":120,"line":5075},87,[118,5077,5078],{},"        if root.char is not None:\n",[118,5080,5082],{"class":120,"line":5081},88,[118,5083,5084],{},"            codes[root.char] = code or \"0\"\n",[118,5086,5088],{"class":120,"line":5087},89,[118,5089,5090],{},"        generate_codes(root.left, code + \"0\", codes)\n",[118,5092,5094],{"class":120,"line":5093},90,[118,5095,5096],{},"        generate_codes(root.right, code + \"1\", codes)\n",[118,5098,5100],{"class":120,"line":5099},91,[118,5101,5102],{},"    return codes\n",[118,5104,5106],{"class":120,"line":5105},92,[118,5107,173],{"emptyLinePlaceholder":30},[118,5109,5111],{"class":120,"line":5110},93,[118,5112,5113],{},"def huffman_coding(data):\n",[118,5115,5117],{"class":120,"line":5116},94,[118,5118,5119],{},"    if not data:\n",[118,5121,5123],{"class":120,"line":5122},95,[118,5124,5125],{},"        return \"\", {}\n",[118,5127,5129],{"class":120,"line":5128},96,[118,5130,5131],{},"    root = build_huffman_tree(data)\n",[118,5133,5135],{"class":120,"line":5134},97,[118,5136,5137],{},"    codes = generate_codes(root)\n",[118,5139,5141],{"class":120,"line":5140},98,[118,5142,5143],{},"    encoded = ''.join(codes[char] for char in data)\n",[118,5145,5147],{"class":120,"line":5146},99,[118,5148,5149],{},"    return encoded, codes\n",[118,5151,5153],{"class":120,"line":5152},100,[118,5154,173],{"emptyLinePlaceholder":30},[118,5156,5158],{"class":120,"line":5157},101,[118,5159,1505],{},[118,5161,5163],{"class":120,"line":5162},102,[118,5164,5165],{},"data = \"AABBCC\"\n",[118,5167,5169],{"class":120,"line":5168},103,[118,5170,5171],{},"encoded, codes = huffman_coding(data)\n",[118,5173,5175],{"class":120,"line":5174},104,[118,5176,5177],{},"print(\"Kode Huffman:\", codes)\n",[118,5179,5181],{"class":120,"line":5180},105,[118,5182,5183],{},"print(\"Data tersandi:\", encoded)\n",[53,5185,5187],{"id":5186},"implementasi-javascript","ğŸ’» Implementasi JavaScript",[109,5189,5191],{"className":1536,"code":5190,"language":1538,"meta":15,"style":15},"class Node {\n    constructor(char, freq) {\n        this.char = char;\n        this.freq = freq;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nfunction huffmanCoding(data) {\n    if (!data) return { encoded: \"\", codes: {} };\n\n    // Frekuensi karakter\n    const freq = {};\n    for (let char of data) {\n        freq[char] = (freq[char] || 0) + 1;\n    }\n\n    // Buat min-heap\n    const heap = Object.entries(freq).map(([char, freq]) => new Node(char, freq));\n    heap.sort((a, b) => a.freq - b.freq);\n\n    // Bangun pohon\n    while (heap.length > 1) {\n        const left = heap.shift();\n        const right = heap.shift();\n        const parent = new Node(null, left.freq + right.freq);\n        parent.left = left;\n        parent.right = right;\n        heap.push(parent);\n        heap.sort((a, b) => a.freq - b.freq);\n    }\n\n    // Generate kode\n    const codes = {};\n    function generateCodes(node, code = \"\") {\n        if (!node) return;\n        if (node.char !== null) {\n            codes[node.char] = code || \"0\";\n        }\n        generateCodes(node.left, code + \"0\");\n        generateCodes(node.right, code + \"1\");\n    }\n\n    generateCodes(heap[0]);\n\n    // Encode data\n    const encoded = data.split(\"\").map(char => codes[char]).join(\"\");\n    return { encoded, codes };\n}\n\n// Contoh penggunaan\nconst data = \"AABBCC\";\nconst { encoded, codes } = huffmanCoding(data);\nconsole.log(\"Kode Huffman:\", codes);\nconsole.log(\"Data tersandi:\", encoded);\n",[71,5192,5193,5198,5203,5208,5213,5218,5223,5227,5231,5235,5240,5245,5249,5254,5259,5264,5269,5273,5277,5282,5287,5292,5296,5301,5306,5311,5316,5321,5326,5331,5336,5341,5345,5349,5354,5359,5364,5369,5374,5379,5383,5388,5393,5397,5401,5406,5410,5415,5420,5425,5429,5433,5437,5442,5447,5452],{"__ignoreMap":15},[118,5194,5195],{"class":120,"line":121},[118,5196,5197],{},"class Node {\n",[118,5199,5200],{"class":120,"line":25},[118,5201,5202],{},"    constructor(char, freq) {\n",[118,5204,5205],{"class":120,"line":170},[118,5206,5207],{},"        this.char = char;\n",[118,5209,5210],{"class":120,"line":176},[118,5211,5212],{},"        this.freq = freq;\n",[118,5214,5215],{"class":120,"line":195},[118,5216,5217],{},"        this.left = null;\n",[118,5219,5220],{"class":120,"line":201},[118,5221,5222],{},"        this.right = null;\n",[118,5224,5225],{"class":120,"line":207},[118,5226,621],{},[118,5228,5229],{"class":120,"line":216},[118,5230,757],{},[118,5232,5233],{"class":120,"line":222},[118,5234,173],{"emptyLinePlaceholder":30},[118,5236,5237],{"class":120,"line":228},[118,5238,5239],{},"function huffmanCoding(data) {\n",[118,5241,5242],{"class":120,"line":238},[118,5243,5244],{},"    if (!data) return { encoded: \"\", codes: {} };\n",[118,5246,5247],{"class":120,"line":243},[118,5248,173],{"emptyLinePlaceholder":30},[118,5250,5251],{"class":120,"line":252},[118,5252,5253],{},"    // Frekuensi karakter\n",[118,5255,5256],{"class":120,"line":263},[118,5257,5258],{},"    const freq = {};\n",[118,5260,5261],{"class":120,"line":279},[118,5262,5263],{},"    for (let char of data) {\n",[118,5265,5266],{"class":120,"line":289},[118,5267,5268],{},"        freq[char] = (freq[char] || 0) + 1;\n",[118,5270,5271],{"class":120,"line":298},[118,5272,621],{},[118,5274,5275],{"class":120,"line":303},[118,5276,173],{"emptyLinePlaceholder":30},[118,5278,5279],{"class":120,"line":316},[118,5280,5281],{},"    // Buat min-heap\n",[118,5283,5284],{"class":120,"line":321},[118,5285,5286],{},"    const heap = Object.entries(freq).map(([char, freq]) => new Node(char, freq));\n",[118,5288,5289],{"class":120,"line":666},[118,5290,5291],{},"    heap.sort((a, b) => a.freq - b.freq);\n",[118,5293,5294],{"class":120,"line":1036},[118,5295,173],{"emptyLinePlaceholder":30},[118,5297,5298],{"class":120,"line":1042},[118,5299,5300],{},"    // Bangun pohon\n",[118,5302,5303],{"class":120,"line":1242},[118,5304,5305],{},"    while (heap.length > 1) {\n",[118,5307,5308],{"class":120,"line":1248},[118,5309,5310],{},"        const left = heap.shift();\n",[118,5312,5313],{"class":120,"line":1254},[118,5314,5315],{},"        const right = heap.shift();\n",[118,5317,5318],{"class":120,"line":1259},[118,5319,5320],{},"        const parent = new Node(null, left.freq + right.freq);\n",[118,5322,5323],{"class":120,"line":1265},[118,5324,5325],{},"        parent.left = left;\n",[118,5327,5328],{"class":120,"line":1270},[118,5329,5330],{},"        parent.right = right;\n",[118,5332,5333],{"class":120,"line":1275},[118,5334,5335],{},"        heap.push(parent);\n",[118,5337,5338],{"class":120,"line":1280},[118,5339,5340],{},"        heap.sort((a, b) => a.freq - b.freq);\n",[118,5342,5343],{"class":120,"line":1286},[118,5344,621],{},[118,5346,5347],{"class":120,"line":1291},[118,5348,173],{"emptyLinePlaceholder":30},[118,5350,5351],{"class":120,"line":1297},[118,5352,5353],{},"    // Generate kode\n",[118,5355,5356],{"class":120,"line":1302},[118,5357,5358],{},"    const codes = {};\n",[118,5360,5361],{"class":120,"line":1308},[118,5362,5363],{},"    function generateCodes(node, code = \"\") {\n",[118,5365,5366],{"class":120,"line":1314},[118,5367,5368],{},"        if (!node) return;\n",[118,5370,5371],{"class":120,"line":1320},[118,5372,5373],{},"        if (node.char !== null) {\n",[118,5375,5376],{"class":120,"line":1326},[118,5377,5378],{},"            codes[node.char] = code || \"0\";\n",[118,5380,5381],{"class":120,"line":1332},[118,5382,1598],{},[118,5384,5385],{"class":120,"line":1338},[118,5386,5387],{},"        generateCodes(node.left, code + \"0\");\n",[118,5389,5390],{"class":120,"line":1344},[118,5391,5392],{},"        generateCodes(node.right, code + \"1\");\n",[118,5394,5395],{"class":120,"line":1349},[118,5396,621],{},[118,5398,5399],{"class":120,"line":1355},[118,5400,173],{"emptyLinePlaceholder":30},[118,5402,5403],{"class":120,"line":1360},[118,5404,5405],{},"    generateCodes(heap[0]);\n",[118,5407,5408],{"class":120,"line":1366},[118,5409,173],{"emptyLinePlaceholder":30},[118,5411,5412],{"class":120,"line":1372},[118,5413,5414],{},"    // Encode data\n",[118,5416,5417],{"class":120,"line":1378},[118,5418,5419],{},"    const encoded = data.split(\"\").map(char => codes[char]).join(\"\");\n",[118,5421,5422],{"class":120,"line":1384},[118,5423,5424],{},"    return { encoded, codes };\n",[118,5426,5427],{"class":120,"line":1390},[118,5428,757],{},[118,5430,5431],{"class":120,"line":1395},[118,5432,173],{"emptyLinePlaceholder":30},[118,5434,5435],{"class":120,"line":1401},[118,5436,1624],{},[118,5438,5439],{"class":120,"line":1406},[118,5440,5441],{},"const data = \"AABBCC\";\n",[118,5443,5444],{"class":120,"line":1411},[118,5445,5446],{},"const { encoded, codes } = huffmanCoding(data);\n",[118,5448,5449],{"class":120,"line":1416},[118,5450,5451],{},"console.log(\"Kode Huffman:\", codes);\n",[118,5453,5454],{"class":120,"line":1422},[118,5455,5456],{},"console.log(\"Data tersandi:\", encoded);\n",[53,5458,5459],{"id":1642},"âš™ï¸ Kompleksitas & Optimasi",[85,5461,5463],{"id":5462},"kompleksitas-waktu","â± Kompleksitas Waktu:",[1652,5465,5466],{},[1655,5467,5468,5470],{},[101,5469,1650],{}," untuk n karakter unik (karena operasi heap)",[85,5472,5474],{"id":5473},"kompleksitas-ruang","ğŸ§  Kompleksitas Ruang:",[1652,5476,5477],{},[1655,5478,5479,5481,5482],{},[101,5480,1664],{}," untuk menyimpan:\n",[1652,5483,5484,5487],{},[1655,5485,5486],{},"Pohon Huffman",[1655,5488,5489],{},"Tabel kode",[85,5491,5492],{"id":1672},"ğŸš€ Optimasi:",[1652,5494,5495,5502,5505,5511],{},[1655,5496,5497,5498,5501],{},"Gunakan ",[101,5499,5500],{},"heap efisien"," (binary heap)",[1655,5503,5504],{},"Cache frekuensi untuk input berulang",[1655,5506,5507,5510],{},[101,5508,5509],{},"Bit-level encoding"," untuk kompresi maksimal",[1655,5512,5497,5513,5516],{},[101,5514,5515],{},"bitmask/buffer"," untuk implementasi skala besar",[53,5518,5520],{"id":5519},"kelebihan-huffman-coding","âœ… Kelebihan Huffman Coding",[1652,5522,5523,5530,5537],{},[1655,5524,5525,5526,5529],{},"ğŸ’¡ ",[101,5527,5528],{},"Optimal"," untuk frekuensi karakter tak merata",[1655,5531,5532,5533,5536],{},"ğŸ”„ ",[101,5534,5535],{},"Prefiks kode"," â†’ tidak ambigu tanpa pemisah",[1655,5538,5539,5540,5543],{},"ğŸ”§ ",[101,5541,5542],{},"Dapat disesuaikan"," untuk berbagai format dan kasus",[53,5545,1711],{"id":1710},[1652,5547,5548,5554,5557],{},[1655,5549,5550,5551],{},"ğŸ“¦ Perlu menyimpan ",[101,5552,5553],{},"pohon kode",[1655,5555,5556],{},"ğŸ“Š Kurang efisien untuk data kecil/seragam",[1655,5558,5559],{},"ğŸ“š Implementasi lebih rumit dibanding RLE atau metode sederhana lainnya",[53,5561,1732],{"id":1731},[17,5563,5564,5567,5568,5571,5572,5575],{},[101,5565,5566],{},"Huffman Coding"," adalah algoritma inti dalam kompresi data. Dengan membangun ",[101,5569,5570],{},"pohon Huffman"," dan menghasilkan ",[101,5573,5574],{},"kode biner optimal",", ia memberikan cara efisien untuk mengurangi ukuran data tanpa kehilangan informasi.",[17,5577,5578],{},"Meskipun memiliki keterbatasan, keunggulan dalam efisiensi dan fleksibilitas menjadikannya pilihan utama dalam banyak sistem kompresi modern.",[1752,5580,5581],{},[17,5582,1695,5583],{},[1758,5584,5585],{},"Belajar Huffman Coding bukan hanya belajar kompresi â€” tapi juga belajar bagaimana greedy strategy digunakan untuk mencapai efisiensi optimal.",[308,5587,1763],{},{"title":15,"searchDepth":25,"depth":25,"links":5589},[5590,5591,5596,5597,5598],{"id":5186,"depth":25,"text":5187},{"id":1642,"depth":25,"text":5459,"children":5592},[5593,5594,5595],{"id":5462,"depth":170,"text":5463},{"id":5473,"depth":170,"text":5474},{"id":1672,"depth":170,"text":5492},{"id":5519,"depth":25,"text":5520},{"id":1710,"depth":25,"text":1711},{"id":1731,"depth":25,"text":1732},"Pelajari bagaimana Huffman Coding digunakan untuk kompresi data dengan efisien.",{"script":5601},[5602],{"type":1781,"key":1782,"data-nuxt-schema-org":30,"nodes":5603},[5604],{"_resolver":1785},"/articles/8.jpeg",{},{"props":5608},{},"/en/articles/huffman-coding",{"_resolver":1785},{"title":4654,"description":5599},{"loc":5609,"videos":5613,"images":5614,"lastmod":2579},[],[],"en/articles/huffman-coding",[],"THiUaFJ_PipOSz-_NFowF-tfMH64UA_LrAyRDq7RTcc",{"id":5619,"title":5620,"body":5621,"date":27,"description":6530,"extension":28,"head":6531,"image":6536,"meta":6537,"navigation":30,"ogImage":6538,"path":6540,"readingTime":27,"robots":27,"schemaOrg":6541,"seo":6542,"sitemap":6543,"stem":6546,"tags":6547,"__hash__":6548},"articles_en/en/articles/khans-algorithm.md","Memahami Algoritma Kahn",{"type":7,"value":5622,"toc":6523},[5623,5627,6054,6057,6464,6466,6469,6486,6489,6506,6508,6515,6520],[269,5624,5626],{"id":5625},"khans-algorithm","KHANS' Algorithm",[109,5628,5631],{"className":5629,"code":5630,"language":28,"meta":15,"style":15},"language-md shiki shiki-themes github-dark github-dark github-light","# Apa itu Algoritma Kahn?\n\n**Algoritma Kahn** adalah salah satu dari dua algoritma utama yang digunakan untuk melakukan **pengurutan topologis** (*topological sort*) pada sebuah **Grafik Asiklik Terarah** (*Directed Acyclic Graph - DAG*). Pengurutan topologis adalah susunan linier dari node-node sedemikian rupa sehingga untuk setiap sisi terarah (u â†’ v), node `u` selalu muncul sebelum node `v`.\n\n> âš ï¸ Pengurutan topologis hanya bisa dilakukan jika graf tersebut adalah DAG (tidak mengandung siklus).\n\n## Kegunaan Algoritma Kahn\n\nAlgoritma ini sangat berguna dalam berbagai skenario yang melibatkan **ketergantungan antar tugas**, seperti:\n\n- ğŸ“‹ **Perencanaan Tugas**: Menyusun urutan pekerjaan (misalnya, fondasi rumah harus selesai sebelum membangun dinding).\n- ğŸ“¦ **Manajemen Dependensi Paket**: Menentukan urutan instalasi paket perangkat lunak.\n- ğŸ“ **Penyelesaian Kursus**: Menentukan urutan mata kuliah berdasarkan prasyarat.\n- ğŸ› ï¸ **Kompilasi Kode**: Menentukan urutan file sumber yang harus dikompilasi.\n\n---\n\n## Konsep Kunci: In-degree\n\n**In-degree** (derajat masuk) dari sebuah node adalah jumlah sisi yang **masuk** ke node tersebut.\n\n**Contoh**:\nJika ada sisi `A â†’ B` dan `C â†’ B`, maka **in-degree B = 2**.\n\nNode dengan **in-degree 0** tidak memiliki prasyarat, sehingga bisa menjadi **titik awal** dalam urutan topologis.\n\n---\n\n## Cara Kerja Algoritma Kahn\n\n1. **Inisialisasi**:\n   - Hitung in-degree untuk setiap node.\n   - Masukkan semua node dengan in-degree 0 ke dalam queue.\n\n2. **Proses Iteratif**:\n   - Selama queue tidak kosong:\n     - Ambil (dequeue) node dari queue, tambahkan ke hasil.\n     - Kurangi in-degree semua tetangga-nya.\n     - Jika in-degree tetangga menjadi 0, tambahkan ke queue.\n\n3. **Verifikasi (Opsional tapi Penting)**:\n   - Jika jumlah node di hasil â‰  total node, maka graf memiliki **siklus**.\n\n---\n\n## Contoh Masalah: Urutan Mata Kuliah\n\n**Mata Kuliah dan Prasyarat**:\n\n- A: -\n- B: A\n- C: A\n- D: B, C\n- E: D\n\n**Grafik Terarah**:\n",[71,5632,5633,5639,5643,5686,5690,5695,5699,5704,5708,5719,5723,5736,5749,5762,5775,5779,5783,5787,5792,5796,5810,5814,5821,5843,5847,5864,5868,5872,5876,5881,5885,5894,5902,5909,5913,5922,5929,5937,5944,5951,5955,5964,5976,5980,5984,5988,5993,5997,6004,6008,6015,6022,6029,6036,6043,6047],{"__ignoreMap":15},[118,5634,5635],{"class":120,"line":121},[118,5636,5638],{"class":5637},"sXvaJ","# Apa itu Algoritma Kahn?\n",[118,5640,5641],{"class":120,"line":25},[118,5642,173],{"emptyLinePlaceholder":30},[118,5644,5645,5649,5652,5655,5657,5661,5664,5667,5669,5672,5675,5678,5681,5684],{"class":120,"line":170},[118,5646,5648],{"class":5647},"s9_AW","**Algoritma Kahn**",[118,5650,5651],{"class":124}," adalah salah satu dari dua algoritma utama yang digunakan untuk melakukan ",[118,5653,5654],{"class":5647},"**pengurutan topologis**",[118,5656,397],{"class":124},[118,5658,5660],{"class":5659},"sszsK","*topological sort*",[118,5662,5663],{"class":124},") pada sebuah ",[118,5665,5666],{"class":5647},"**Grafik Asiklik Terarah**",[118,5668,397],{"class":124},[118,5670,5671],{"class":5659},"*Directed Acyclic Graph - DAG*",[118,5673,5674],{"class":124},"). Pengurutan topologis adalah susunan linier dari node-node sedemikian rupa sehingga untuk setiap sisi terarah (u â†’ v), node ",[118,5676,5677],{"class":182},"`u`",[118,5679,5680],{"class":124}," selalu muncul sebelum node ",[118,5682,5683],{"class":182},"`v`",[118,5685,2039],{"class":124},[118,5687,5688],{"class":120,"line":176},[118,5689,173],{"emptyLinePlaceholder":30},[118,5691,5692],{"class":120,"line":195},[118,5693,5694],{"class":128},"> âš ï¸ Pengurutan topologis hanya bisa dilakukan jika graf tersebut adalah DAG (tidak mengandung siklus).\n",[118,5696,5697],{"class":120,"line":201},[118,5698,173],{"emptyLinePlaceholder":30},[118,5700,5701],{"class":120,"line":207},[118,5702,5703],{"class":5637},"## Kegunaan Algoritma Kahn\n",[118,5705,5706],{"class":120,"line":216},[118,5707,173],{"emptyLinePlaceholder":30},[118,5709,5710,5713,5716],{"class":120,"line":222},[118,5711,5712],{"class":124},"Algoritma ini sangat berguna dalam berbagai skenario yang melibatkan ",[118,5714,5715],{"class":5647},"**ketergantungan antar tugas**",[118,5717,5718],{"class":124},", seperti:\n",[118,5720,5721],{"class":120,"line":228},[118,5722,173],{"emptyLinePlaceholder":30},[118,5724,5725,5727,5730,5733],{"class":120,"line":238},[118,5726,2887],{"class":400},[118,5728,5729],{"class":124}," ğŸ“‹ ",[118,5731,5732],{"class":5647},"**Perencanaan Tugas**",[118,5734,5735],{"class":124},": Menyusun urutan pekerjaan (misalnya, fondasi rumah harus selesai sebelum membangun dinding).\n",[118,5737,5738,5740,5743,5746],{"class":120,"line":243},[118,5739,2887],{"class":400},[118,5741,5742],{"class":124}," ğŸ“¦ ",[118,5744,5745],{"class":5647},"**Manajemen Dependensi Paket**",[118,5747,5748],{"class":124},": Menentukan urutan instalasi paket perangkat lunak.\n",[118,5750,5751,5753,5756,5759],{"class":120,"line":252},[118,5752,2887],{"class":400},[118,5754,5755],{"class":124}," ğŸ“ ",[118,5757,5758],{"class":5647},"**Penyelesaian Kursus**",[118,5760,5761],{"class":124},": Menentukan urutan mata kuliah berdasarkan prasyarat.\n",[118,5763,5764,5766,5769,5772],{"class":120,"line":263},[118,5765,2887],{"class":400},[118,5767,5768],{"class":124}," ğŸ› ï¸ ",[118,5770,5771],{"class":5647},"**Kompilasi Kode**",[118,5773,5774],{"class":124},": Menentukan urutan file sumber yang harus dikompilasi.\n",[118,5776,5777],{"class":120,"line":279},[118,5778,173],{"emptyLinePlaceholder":30},[118,5780,5781],{"class":120,"line":289},[118,5782,1165],{"class":5637},[118,5784,5785],{"class":120,"line":298},[118,5786,173],{"emptyLinePlaceholder":30},[118,5788,5789],{"class":120,"line":303},[118,5790,5791],{"class":5637},"## Konsep Kunci: In-degree\n",[118,5793,5794],{"class":120,"line":316},[118,5795,173],{"emptyLinePlaceholder":30},[118,5797,5798,5801,5804,5807],{"class":120,"line":321},[118,5799,5800],{"class":5647},"**In-degree**",[118,5802,5803],{"class":124}," (derajat masuk) dari sebuah node adalah jumlah sisi yang ",[118,5805,5806],{"class":5647},"**masuk**",[118,5808,5809],{"class":124}," ke node tersebut.\n",[118,5811,5812],{"class":120,"line":666},[118,5813,173],{"emptyLinePlaceholder":30},[118,5815,5816,5819],{"class":120,"line":1036},[118,5817,5818],{"class":5647},"**Contoh**",[118,5820,2054],{"class":124},[118,5822,5823,5826,5829,5832,5835,5838,5841],{"class":120,"line":1042},[118,5824,5825],{"class":124},"Jika ada sisi ",[118,5827,5828],{"class":182},"`A â†’ B`",[118,5830,5831],{"class":124}," dan ",[118,5833,5834],{"class":182},"`C â†’ B`",[118,5836,5837],{"class":124},", maka ",[118,5839,5840],{"class":5647},"**in-degree B = 2**",[118,5842,2039],{"class":124},[118,5844,5845],{"class":120,"line":1242},[118,5846,173],{"emptyLinePlaceholder":30},[118,5848,5849,5852,5855,5858,5861],{"class":120,"line":1248},[118,5850,5851],{"class":124},"Node dengan ",[118,5853,5854],{"class":5647},"**in-degree 0**",[118,5856,5857],{"class":124}," tidak memiliki prasyarat, sehingga bisa menjadi ",[118,5859,5860],{"class":5647},"**titik awal**",[118,5862,5863],{"class":124}," dalam urutan topologis.\n",[118,5865,5866],{"class":120,"line":1254},[118,5867,173],{"emptyLinePlaceholder":30},[118,5869,5870],{"class":120,"line":1259},[118,5871,1165],{"class":5637},[118,5873,5874],{"class":120,"line":1265},[118,5875,173],{"emptyLinePlaceholder":30},[118,5877,5878],{"class":120,"line":1270},[118,5879,5880],{"class":5637},"## Cara Kerja Algoritma Kahn\n",[118,5882,5883],{"class":120,"line":1275},[118,5884,173],{"emptyLinePlaceholder":30},[118,5886,5887,5889,5892],{"class":120,"line":1280},[118,5888,2081],{"class":400},[118,5890,5891],{"class":5647}," **Inisialisasi**",[118,5893,2054],{"class":124},[118,5895,5896,5899],{"class":120,"line":1286},[118,5897,5898],{"class":400},"   -",[118,5900,5901],{"class":124}," Hitung in-degree untuk setiap node.\n",[118,5903,5904,5906],{"class":120,"line":1291},[118,5905,5898],{"class":400},[118,5907,5908],{"class":124}," Masukkan semua node dengan in-degree 0 ke dalam queue.\n",[118,5910,5911],{"class":120,"line":1297},[118,5912,173],{"emptyLinePlaceholder":30},[118,5914,5915,5917,5920],{"class":120,"line":1302},[118,5916,2109],{"class":400},[118,5918,5919],{"class":5647}," **Proses Iteratif**",[118,5921,2054],{"class":124},[118,5923,5924,5926],{"class":120,"line":1308},[118,5925,5898],{"class":400},[118,5927,5928],{"class":124}," Selama queue tidak kosong:\n",[118,5930,5931,5934],{"class":120,"line":1314},[118,5932,5933],{"class":400},"     -",[118,5935,5936],{"class":124}," Ambil (dequeue) node dari queue, tambahkan ke hasil.\n",[118,5938,5939,5941],{"class":120,"line":1320},[118,5940,5933],{"class":400},[118,5942,5943],{"class":124}," Kurangi in-degree semua tetangga-nya.\n",[118,5945,5946,5948],{"class":120,"line":1326},[118,5947,5933],{"class":400},[118,5949,5950],{"class":124}," Jika in-degree tetangga menjadi 0, tambahkan ke queue.\n",[118,5952,5953],{"class":120,"line":1332},[118,5954,173],{"emptyLinePlaceholder":30},[118,5956,5957,5959,5962],{"class":120,"line":1338},[118,5958,2139],{"class":400},[118,5960,5961],{"class":5647}," **Verifikasi (Opsional tapi Penting)**",[118,5963,2054],{"class":124},[118,5965,5966,5968,5971,5974],{"class":120,"line":1344},[118,5967,5898],{"class":400},[118,5969,5970],{"class":124}," Jika jumlah node di hasil â‰  total node, maka graf memiliki ",[118,5972,5973],{"class":5647},"**siklus**",[118,5975,2039],{"class":124},[118,5977,5978],{"class":120,"line":1349},[118,5979,173],{"emptyLinePlaceholder":30},[118,5981,5982],{"class":120,"line":1355},[118,5983,1165],{"class":5637},[118,5985,5986],{"class":120,"line":1360},[118,5987,173],{"emptyLinePlaceholder":30},[118,5989,5990],{"class":120,"line":1366},[118,5991,5992],{"class":5637},"## Contoh Masalah: Urutan Mata Kuliah\n",[118,5994,5995],{"class":120,"line":1372},[118,5996,173],{"emptyLinePlaceholder":30},[118,5998,5999,6002],{"class":120,"line":1378},[118,6000,6001],{"class":5647},"**Mata Kuliah dan Prasyarat**",[118,6003,2054],{"class":124},[118,6005,6006],{"class":120,"line":1384},[118,6007,173],{"emptyLinePlaceholder":30},[118,6009,6010,6012],{"class":120,"line":1390},[118,6011,2887],{"class":400},[118,6013,6014],{"class":124}," A: -\n",[118,6016,6017,6019],{"class":120,"line":1395},[118,6018,2887],{"class":400},[118,6020,6021],{"class":124}," B: A\n",[118,6023,6024,6026],{"class":120,"line":1401},[118,6025,2887],{"class":400},[118,6027,6028],{"class":124}," C: A\n",[118,6030,6031,6033],{"class":120,"line":1406},[118,6032,2887],{"class":400},[118,6034,6035],{"class":124}," D: B, C\n",[118,6037,6038,6040],{"class":120,"line":1411},[118,6039,2887],{"class":400},[118,6041,6042],{"class":124}," E: D\n",[118,6044,6045],{"class":120,"line":1416},[118,6046,173],{"emptyLinePlaceholder":30},[118,6048,6049,6052],{"class":120,"line":1422},[118,6050,6051],{"class":5647},"**Grafik Terarah**",[118,6053,2054],{"class":124},[17,6055,6056],{},"A â†’ B â†’ D â†’ E â†“ â†‘ â†’ C â”€â”€â”˜",[109,6058,6060],{"className":1994,"code":6059,"language":1996,"meta":15,"style":15},"\n**Urutan Eksekusi**:\n\n1. In-degree:\n   - A: 0, B: 1, C: 1, D: 2, E: 1\n2. Queue awal: `[A]`\n3. Urutan Topologis:\n   - A â†’ [B, C] â†’ D â†’ E\n4. Hasil akhir: `[A, B, C, D, E]` *(atau alternatif: `[A, C, B, D, E]`)*\n\n---\n\n## Implementasi Algoritma Kahn (C++)\n\n```cpp\n#include \u003Ciostream>\n#include \u003Cvector>\n#include \u003Cqueue>\n\nstd::vector\u003Cint> kahnTopologicalSort(int numNodes, const std::vector\u003Cstd::vector\u003Cint>>& adj, std::vector\u003Cint>& inDegree) {\n    std::queue\u003Cint> q;\n    std::vector\u003Cint> result;\n\n    for (int i = 0; i \u003C numNodes; ++i) {\n        if (inDegree[i] == 0) q.push(i);\n    }\n\n    int visitedNodes = 0;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        result.push_back(u);\n        visitedNodes++;\n\n        for (int v : adj[u]) {\n            if (--inDegree[v] == 0) q.push(v);\n        }\n    }\n\n    if (visitedNodes != numNodes) {\n        std::cout \u003C\u003C \"Grafik mengandung siklus!\\n\";\n        return {};\n    }\n\n    return result;\n}\n\nint main() {\n    int numNodes = 5;\n    std::vector\u003Cstd::vector\u003Cint>> adj(numNodes);\n    std::vector\u003Cint> inDegree(numNodes, 0);\n\n    adj[0] = {1, 2}; inDegree[1]++; inDegree[2]++;\n    adj[1] = {3}; inDegree[3]++;\n    adj[2] = {3}; inDegree[3]++;\n    adj[3] = {4}; inDegree[4]++;\n\n    auto order = kahnTopologicalSort(numNodes, adj, inDegree);\n    for (int n : order) std::cout \u003C\u003C n \u003C\u003C \" \";\n    std::cout \u003C\u003C \"\\n\";\n}\n",[71,6061,6062,6066,6077,6081,6095,6139,6153,6165,6190,6219,6223,6227,6231,6247,6251,6255,6259,6263,6267,6271,6276,6280,6285,6289,6294,6299,6303,6307,6312,6316,6321,6326,6331,6335,6339,6344,6348,6352,6356,6361,6370,6375,6379,6383,6387,6391,6395,6399,6404,6409,6414,6418,6423,6428,6433,6438,6442,6447,6452,6460],{"__ignoreMap":15},[118,6063,6064],{"class":120,"line":121},[118,6065,173],{"emptyLinePlaceholder":30},[118,6067,6068,6070,6073,6075],{"class":120,"line":25},[118,6069,2019],{"class":151},[118,6071,6072],{"class":124},"Urutan Eksekusi",[118,6074,2019],{"class":151},[118,6076,2054],{"class":124},[118,6078,6079],{"class":120,"line":170},[118,6080,173],{"emptyLinePlaceholder":30},[118,6082,6083,6085,6088,6090,6093],{"class":120,"line":176},[118,6084,2081],{"class":182},[118,6086,6087],{"class":124}," In",[118,6089,2887],{"class":151},[118,6091,6092],{"class":132},"degree",[118,6094,2054],{"class":124},[118,6096,6097,6099,6102,6104,6106,6108,6110,6112,6114,6116,6118,6120,6122,6124,6126,6128,6130,6132,6134,6136],{"class":120,"line":195},[118,6098,5898],{"class":151},[118,6100,6101],{"class":132}," A",[118,6103,2101],{"class":124},[118,6105,577],{"class":182},[118,6107,811],{"class":124},[118,6109,2120],{"class":132},[118,6111,2101],{"class":124},[118,6113,3731],{"class":182},[118,6115,811],{"class":124},[118,6117,2125],{"class":132},[118,6119,2101],{"class":124},[118,6121,3731],{"class":182},[118,6123,811],{"class":124},[118,6125,2148],{"class":132},[118,6127,2101],{"class":124},[118,6129,3795],{"class":182},[118,6131,811],{"class":124},[118,6133,2153],{"class":132},[118,6135,2101],{"class":124},[118,6137,6138],{"class":182},"1\n",[118,6140,6141,6143,6146,6149,6151],{"class":120,"line":201},[118,6142,2109],{"class":182},[118,6144,6145],{"class":124}," Queue ",[118,6147,6148],{"class":132},"awal",[118,6150,2101],{"class":124},[118,6152,2104],{"class":142},[118,6154,6155,6157,6160,6163],{"class":120,"line":207},[118,6156,2139],{"class":182},[118,6158,6159],{"class":124}," Urutan ",[118,6161,6162],{"class":132},"Topologis",[118,6164,2054],{"class":124},[118,6166,6167,6169,6171,6174,6176,6178,6180,6183,6185,6187],{"class":120,"line":216},[118,6168,5898],{"class":151},[118,6170,6101],{"class":182},[118,6172,6173],{"class":124}," â†’ [",[118,6175,2120],{"class":182},[118,6177,811],{"class":124},[118,6179,2125],{"class":182},[118,6181,6182],{"class":124},"] â†’ ",[118,6184,2148],{"class":182},[118,6186,2090],{"class":124},[118,6188,6189],{"class":182},"E\n",[118,6191,6192,6194,6197,6200,6202,6205,6208,6211,6214,6216],{"class":120,"line":222},[118,6193,2167],{"class":182},[118,6195,6196],{"class":124}," Hasil ",[118,6198,6199],{"class":132},"akhir",[118,6201,2101],{"class":124},[118,6203,6204],{"class":142},"`[A, B, C, D, E]`",[118,6206,6207],{"class":151}," *",[118,6209,6210],{"class":124},"(atau alternatif: ",[118,6212,6213],{"class":142},"`[A, C, B, D, E]`",[118,6215,3734],{"class":124},[118,6217,6218],{"class":151},"*\n",[118,6220,6221],{"class":120,"line":228},[118,6222,173],{"emptyLinePlaceholder":30},[118,6224,6225],{"class":120,"line":238},[118,6226,1165],{"class":151},[118,6228,6229],{"class":120,"line":243},[118,6230,173],{"emptyLinePlaceholder":30},[118,6232,6233,6236,6239,6241,6243,6245],{"class":120,"line":252},[118,6234,6235],{"class":124},"## Implementasi Algoritma ",[118,6237,6238],{"class":132},"Kahn",[118,6240,397],{"class":124},[118,6242,2125],{"class":182},[118,6244,650],{"class":151},[118,6246,3798],{"class":124},[118,6248,6249],{"class":120,"line":263},[118,6250,173],{"emptyLinePlaceholder":30},[118,6252,6253],{"class":120,"line":279},[118,6254,2256],{"class":142},[118,6256,6257],{"class":120,"line":289},[118,6258,2261],{"class":142},[118,6260,6261],{"class":120,"line":298},[118,6262,2266],{"class":142},[118,6264,6265],{"class":120,"line":303},[118,6266,2271],{"class":142},[118,6268,6269],{"class":120,"line":316},[118,6270,173],{"emptyLinePlaceholder":30},[118,6272,6273],{"class":120,"line":321},[118,6274,6275],{"class":142},"std::vector\u003Cint> kahnTopologicalSort(int numNodes, const std::vector\u003Cstd::vector\u003Cint>>& adj, std::vector\u003Cint>& inDegree) {\n",[118,6277,6278],{"class":120,"line":666},[118,6279,2299],{"class":142},[118,6281,6282],{"class":120,"line":1036},[118,6283,6284],{"class":142},"    std::vector\u003Cint> result;\n",[118,6286,6287],{"class":120,"line":1042},[118,6288,173],{"emptyLinePlaceholder":30},[118,6290,6291],{"class":120,"line":1242},[118,6292,6293],{"class":142},"    for (int i = 0; i \u003C numNodes; ++i) {\n",[118,6295,6296],{"class":120,"line":1248},[118,6297,6298],{"class":142},"        if (inDegree[i] == 0) q.push(i);\n",[118,6300,6301],{"class":120,"line":1254},[118,6302,621],{"class":142},[118,6304,6305],{"class":120,"line":1259},[118,6306,173],{"emptyLinePlaceholder":30},[118,6308,6309],{"class":120,"line":1265},[118,6310,6311],{"class":142},"    int visitedNodes = 0;\n",[118,6313,6314],{"class":120,"line":1270},[118,6315,2318],{"class":142},[118,6317,6318],{"class":120,"line":1275},[118,6319,6320],{"class":142},"        int u = q.front(); q.pop();\n",[118,6322,6323],{"class":120,"line":1280},[118,6324,6325],{"class":142},"        result.push_back(u);\n",[118,6327,6328],{"class":120,"line":1286},[118,6329,6330],{"class":142},"        visitedNodes++;\n",[118,6332,6333],{"class":120,"line":1291},[118,6334,173],{"emptyLinePlaceholder":30},[118,6336,6337],{"class":120,"line":1297},[118,6338,2342],{"class":142},[118,6340,6341],{"class":120,"line":1302},[118,6342,6343],{"class":142},"            if (--inDegree[v] == 0) q.push(v);\n",[118,6345,6346],{"class":120,"line":1308},[118,6347,1598],{"class":142},[118,6349,6350],{"class":120,"line":1314},[118,6351,621],{"class":142},[118,6353,6354],{"class":120,"line":1320},[118,6355,173],{"emptyLinePlaceholder":30},[118,6357,6358],{"class":120,"line":1326},[118,6359,6360],{"class":142},"    if (visitedNodes != numNodes) {\n",[118,6362,6363,6366,6368],{"class":120,"line":1332},[118,6364,6365],{"class":142},"        std::cout \u003C\u003C \"Grafik mengandung siklus!",[118,6367,2459],{"class":182},[118,6369,2462],{"class":142},[118,6371,6372],{"class":120,"line":1338},[118,6373,6374],{"class":142},"        return {};\n",[118,6376,6377],{"class":120,"line":1344},[118,6378,621],{"class":142},[118,6380,6381],{"class":120,"line":1349},[118,6382,173],{"emptyLinePlaceholder":30},[118,6384,6385],{"class":120,"line":1355},[118,6386,1611],{"class":142},[118,6388,6389],{"class":120,"line":1360},[118,6390,757],{"class":142},[118,6392,6393],{"class":120,"line":1366},[118,6394,173],{"emptyLinePlaceholder":30},[118,6396,6397],{"class":120,"line":1372},[118,6398,2383],{"class":142},[118,6400,6401],{"class":120,"line":1378},[118,6402,6403],{"class":142},"    int numNodes = 5;\n",[118,6405,6406],{"class":120,"line":1384},[118,6407,6408],{"class":142},"    std::vector\u003Cstd::vector\u003Cint>> adj(numNodes);\n",[118,6410,6411],{"class":120,"line":1390},[118,6412,6413],{"class":142},"    std::vector\u003Cint> inDegree(numNodes, 0);\n",[118,6415,6416],{"class":120,"line":1395},[118,6417,173],{"emptyLinePlaceholder":30},[118,6419,6420],{"class":120,"line":1401},[118,6421,6422],{"class":142},"    adj[0] = {1, 2}; inDegree[1]++; inDegree[2]++;\n",[118,6424,6425],{"class":120,"line":1406},[118,6426,6427],{"class":142},"    adj[1] = {3}; inDegree[3]++;\n",[118,6429,6430],{"class":120,"line":1411},[118,6431,6432],{"class":142},"    adj[2] = {3}; inDegree[3]++;\n",[118,6434,6435],{"class":120,"line":1416},[118,6436,6437],{"class":142},"    adj[3] = {4}; inDegree[4]++;\n",[118,6439,6440],{"class":120,"line":1422},[118,6441,173],{"emptyLinePlaceholder":30},[118,6443,6444],{"class":120,"line":1427},[118,6445,6446],{"class":142},"    auto order = kahnTopologicalSort(numNodes, adj, inDegree);\n",[118,6448,6449],{"class":120,"line":1433},[118,6450,6451],{"class":142},"    for (int n : order) std::cout \u003C\u003C n \u003C\u003C \" \";\n",[118,6453,6454,6456,6458],{"class":120,"line":1439},[118,6455,2456],{"class":142},[118,6457,2459],{"class":182},[118,6459,2462],{"class":142},[118,6461,6462],{"class":120,"line":1445},[118,6463,757],{"class":142},[53,6465,2479],{"id":2478},[85,6467,6468],{"id":1689},"âœ… Kelebihan:",[1652,6470,6471,6474,6477,6480],{},[1655,6472,6473],{},"Menjamin hasil urutan topologis (jika DAG).",[1655,6475,6476],{},"Dapat mendeteksi siklus.",[1655,6478,6479],{},"Intuitif & mudah dipahami.",[1655,6481,6482,6483,6485],{},"Kompleksitas waktu ",[101,6484,2530],{},", efisien untuk graf besar.",[85,6487,6488],{"id":1710},"âŒ Kekurangan:",[1652,6490,6491,6497,6503],{},[1655,6492,6493,6494,1750],{},"Hanya untuk ",[101,6495,6496],{},"grafik tanpa siklus",[1655,6498,6499,6500,1750],{},"Tidak menemukan ",[101,6501,6502],{},"jalur terpendek",[1655,6504,6505],{},"Bisa ada banyak urutan yang valid.",[53,6507,2541],{"id":1731},[17,6509,6510,6511,6514],{},"Algoritma Kahn adalah metode yang elegan dan efisien untuk menyusun urutan topologis pada DAG. Dengan memanfaatkan ",[101,6512,6513],{},"in-degree"," dan struktur antrian, ia cocok untuk berbagai kasus yang melibatkan dependensi dan penjadwalan.",[1752,6516,6517],{},[17,6518,6519],{},"Pemahaman konsep dasar seperti in-degree dan traversal node adalah kunci untuk menguasai algoritma ini secara menyeluruh.",[308,6521,6522],{},"html pre.shiki code .sXvaJ, html code.shiki .sXvaJ{--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;--shiki-default:#79B8FF;--shiki-default-font-weight:bold;--shiki-light:#005CC5;--shiki-light-font-weight:bold}html pre.shiki code .s9_AW, html code.shiki .s9_AW{--shiki-dark:#E1E4E8;--shiki-dark-font-weight:bold;--shiki-default:#E1E4E8;--shiki-default-font-weight:bold;--shiki-light:#24292E;--shiki-light-font-weight:bold}html pre.shiki code .suVJd, html code.shiki .suVJd{--shiki-dark:#E1E4E8;--shiki-default:#E1E4E8;--shiki-light:#24292E}html pre.shiki code .sszsK, html code.shiki .sszsK{--shiki-dark:#E1E4E8;--shiki-dark-font-style:italic;--shiki-default:#E1E4E8;--shiki-default-font-style:italic;--shiki-light:#24292E;--shiki-light-font-style:italic}html pre.shiki code .sAPL1, html code.shiki .sAPL1{--shiki-dark:#79B8FF;--shiki-default:#79B8FF;--shiki-light:#005CC5}html pre.shiki code .scWFE, html code.shiki .scWFE{--shiki-dark:#85E89D;--shiki-default:#85E89D;--shiki-light:#22863A}html pre.shiki code .s1uPE, html code.shiki .s1uPE{--shiki-dark:#FFAB70;--shiki-default:#FFAB70;--shiki-light:#E36209}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html pre.shiki code .sEiGg, html code.shiki .sEiGg{--shiki-dark:#F97583;--shiki-default:#F97583;--shiki-light:#D73A49}html pre.shiki code .s9E-l, html code.shiki .s9E-l{--shiki-dark:#B392F0;--shiki-default:#B392F0;--shiki-light:#6F42C1}html pre.shiki code .sYTnl, html code.shiki .sYTnl{--shiki-dark:#9ECBFF;--shiki-default:#9ECBFF;--shiki-light:#032F62}",{"title":15,"searchDepth":25,"depth":25,"links":6524},[6525,6529],{"id":2478,"depth":25,"text":2479,"children":6526},[6527,6528],{"id":1689,"depth":170,"text":6468},{"id":1710,"depth":170,"text":6488},{"id":1731,"depth":25,"text":2541},"Selami dunia pengurutan topologis dengan salah satu algoritma paling fundamental.",{"script":6532},[6533],{"type":1781,"key":1782,"data-nuxt-schema-org":30,"nodes":6534},[6535],{"_resolver":1785},"/articles/2.jpeg",{},{"props":6539},{},"/en/articles/khans-algorithm",{"_resolver":1785},{"title":5620,"description":6530},{"loc":6540,"videos":6544,"images":6545,"lastmod":2579},[],[],"en/articles/khans-algorithm",[],"bYH2V69MSed4d_M0RMeosROCrjYuTdlULwMOPRZ_7PU",{"id":6550,"title":6551,"body":6552,"date":7042,"description":7043,"extension":28,"head":7044,"image":7049,"meta":7050,"navigation":30,"ogImage":7051,"path":7053,"readingTime":7054,"robots":27,"schemaOrg":7055,"seo":7056,"sitemap":7057,"stem":7061,"tags":7062,"__hash__":7066},"articles_en/en/articles/launch-your-portfolio.md","Project Lab OOP2025",{"type":7,"value":6553,"toc":7036},[6554,6942,6946,6949,6969,6973,6976,6982,6988,6994,6998,7015,7019,7028,7033],[109,6555,6557],{"className":5629,"code":6556,"language":28,"meta":15,"style":15},"# ğŸ”§ InNOut â€” Aplikasi Manajemen Modern\n\nSebuah aplikasi untuk manajemen data yang dibuat dengan presisi dan filosofi kode bersih.\n\n![Language: Java](https://img.shields.io/badge/Language-Java_21-007396?style=flat-square)\n![Framework: JavaFX](https://img.shields.io/badge/Framework-JavaFX-E86F00?style=flat-square)\n![Build: Gradle](https://img.shields.io/badge/Build-Gradle-02303A?style=flat-square)\n![License: MIT](https://img.shields.io/badge/License-MIT-blue?style=flat-square)\n\n---\n\n## ğŸ§  Premis Proyek\n\n> *InNOut* dikembangkan untuk menjawab pertanyaan penting:  \n> **\"Bagaimana mengelola alur data kompleks dengan cara yang paling sederhana?\"**  \n>  \n> Aplikasi ini menjadi studi kasus kami dalam menerapkan prinsip _Clean Architecture_ dan Pemrograman Berorientasi Objek (OOP), dengan fokus pada efisiensi, keterbacaan kode, dan skalabilitas jangka panjang.\n\n---\n\n## ğŸš€ Fitur Utama\n\n| ğŸ”§ Fitur              | âœ¨ Deskripsi                                                                                       |\n|-----------------------|--------------------------------------------------------------------------------------------------|\n| ğŸ“Š **Dasbor Analitik**  | Menampilkan data secara visual dan ringkas untuk keputusan cepat.                               |\n| ğŸ”„ **Manajemen Data**  | Antarmuka CRUD (Create, Read, Update, Delete) yang ringkas dan akurat.                          |\n| ğŸ” **Pencarian Cepat** | Fitur pencarian cerdas yang menampilkan hasil hanya dalam milidetik.                            |\n| ğŸ’¾ **Penyimpanan Lokal**| Menggunakan file JSON untuk menyimpan data secara aman dan fleksibel.                           |\n\n---\n\n## ğŸ›  Cetak Biru Teknologi\n\n| Komponen           | Teknologi yang Digunakan |\n|--------------------|--------------------------|\n| Bahasa Pemrograman | Java 21                  |\n| Framework UI       | JavaFX                   |\n| Build Tool         | Gradle                   |\n| Data Handling      | Jackson (JSON Library)   |\n| Styling            | CSS                      |\n| Penyimpanan        | Berbasis File JSON       |\n| Pengujian          | JUnit                    |\n| Version Control    | Git                      |\n| Dokumentasi        | Markdown                 |\n\n---\n\n## âš™ Cara Menjalankan Aplikasi\n\nLangkah-langkah untuk menjalankan *InNOut* di lokal:\n\n```sh\n# 1. Clone repositori\ngit clone https://github.com/SYECHYUSUF/InNOut.git\n\n# 2. Masuk ke direktori\ncd InNOut\n\n# 3. Jalankan dengan Gradle\n# Windows:\n.\\gradlew run\n\n# macOS / Linux:\n./gradlew run\n",[71,6558,6559,6564,6568,6573,6577,6595,6609,6623,6637,6641,6645,6649,6654,6658,6669,6678,6683,6694,6698,6702,6706,6711,6715,6720,6725,6736,6747,6758,6769,6773,6777,6781,6786,6790,6795,6800,6805,6810,6815,6820,6825,6830,6835,6840,6845,6849,6853,6857,6862,6866,6876,6880,6885,6890,6895,6899,6904,6909,6913,6918,6923,6928,6932,6937],{"__ignoreMap":15},[118,6560,6561],{"class":120,"line":121},[118,6562,6563],{"class":5637},"# ğŸ”§ InNOut â€” Aplikasi Manajemen Modern\n",[118,6565,6566],{"class":120,"line":25},[118,6567,173],{"emptyLinePlaceholder":30},[118,6569,6570],{"class":120,"line":170},[118,6571,6572],{"class":124},"Sebuah aplikasi untuk manajemen data yang dibuat dengan presisi dan filosofi kode bersih.\n",[118,6574,6575],{"class":120,"line":176},[118,6576,173],{"emptyLinePlaceholder":30},[118,6578,6579,6582,6586,6589,6593],{"class":120,"line":195},[118,6580,6581],{"class":124},"![",[118,6583,6585],{"class":6584},"s8Wv-","Language: Java",[118,6587,6588],{"class":124},"](",[118,6590,6592],{"class":6591},"snYz-","https://img.shields.io/badge/Language-Java_21-007396?style=flat-square",[118,6594,3798],{"class":124},[118,6596,6597,6599,6602,6604,6607],{"class":120,"line":201},[118,6598,6581],{"class":124},[118,6600,6601],{"class":6584},"Framework: JavaFX",[118,6603,6588],{"class":124},[118,6605,6606],{"class":6591},"https://img.shields.io/badge/Framework-JavaFX-E86F00?style=flat-square",[118,6608,3798],{"class":124},[118,6610,6611,6613,6616,6618,6621],{"class":120,"line":207},[118,6612,6581],{"class":124},[118,6614,6615],{"class":6584},"Build: Gradle",[118,6617,6588],{"class":124},[118,6619,6620],{"class":6591},"https://img.shields.io/badge/Build-Gradle-02303A?style=flat-square",[118,6622,3798],{"class":124},[118,6624,6625,6627,6630,6632,6635],{"class":120,"line":216},[118,6626,6581],{"class":124},[118,6628,6629],{"class":6584},"License: MIT",[118,6631,6588],{"class":124},[118,6633,6634],{"class":6591},"https://img.shields.io/badge/License-MIT-blue?style=flat-square",[118,6636,3798],{"class":124},[118,6638,6639],{"class":120,"line":222},[118,6640,173],{"emptyLinePlaceholder":30},[118,6642,6643],{"class":120,"line":228},[118,6644,1165],{"class":5637},[118,6646,6647],{"class":120,"line":238},[118,6648,173],{"emptyLinePlaceholder":30},[118,6650,6651],{"class":120,"line":243},[118,6652,6653],{"class":5637},"## ğŸ§  Premis Proyek\n",[118,6655,6656],{"class":120,"line":252},[118,6657,173],{"emptyLinePlaceholder":30},[118,6659,6660,6663,6666],{"class":120,"line":263},[118,6661,6662],{"class":128},"> ",[118,6664,6665],{"class":5659},"*InNOut*",[118,6667,6668],{"class":128}," dikembangkan untuk menjawab pertanyaan penting:  \n",[118,6670,6671,6673,6676],{"class":120,"line":279},[118,6672,6662],{"class":128},[118,6674,6675],{"class":5647},"**\"Bagaimana mengelola alur data kompleks dengan cara yang paling sederhana?\"**",[118,6677,735],{"class":128},[118,6679,6680],{"class":120,"line":289},[118,6681,6682],{"class":128},">  \n",[118,6684,6685,6688,6691],{"class":120,"line":298},[118,6686,6687],{"class":128},"> Aplikasi ini menjadi studi kasus kami dalam menerapkan prinsip ",[118,6689,6690],{"class":5659},"_Clean Architecture_",[118,6692,6693],{"class":128}," dan Pemrograman Berorientasi Objek (OOP), dengan fokus pada efisiensi, keterbacaan kode, dan skalabilitas jangka panjang.\n",[118,6695,6696],{"class":120,"line":303},[118,6697,173],{"emptyLinePlaceholder":30},[118,6699,6700],{"class":120,"line":316},[118,6701,1165],{"class":5637},[118,6703,6704],{"class":120,"line":321},[118,6705,173],{"emptyLinePlaceholder":30},[118,6707,6708],{"class":120,"line":666},[118,6709,6710],{"class":5637},"## ğŸš€ Fitur Utama\n",[118,6712,6713],{"class":120,"line":1036},[118,6714,173],{"emptyLinePlaceholder":30},[118,6716,6717],{"class":120,"line":1042},[118,6718,6719],{"class":124},"| ğŸ”§ Fitur              | âœ¨ Deskripsi                                                                                       |\n",[118,6721,6722],{"class":120,"line":1242},[118,6723,6724],{"class":124},"|-----------------------|--------------------------------------------------------------------------------------------------|\n",[118,6726,6727,6730,6733],{"class":120,"line":1248},[118,6728,6729],{"class":124},"| ğŸ“Š ",[118,6731,6732],{"class":5647},"**Dasbor Analitik**",[118,6734,6735],{"class":124},"  | Menampilkan data secara visual dan ringkas untuk keputusan cepat.                               |\n",[118,6737,6738,6741,6744],{"class":120,"line":1254},[118,6739,6740],{"class":124},"| ğŸ”„ ",[118,6742,6743],{"class":5647},"**Manajemen Data**",[118,6745,6746],{"class":124},"  | Antarmuka CRUD (Create, Read, Update, Delete) yang ringkas dan akurat.                          |\n",[118,6748,6749,6752,6755],{"class":120,"line":1259},[118,6750,6751],{"class":124},"| ğŸ” ",[118,6753,6754],{"class":5647},"**Pencarian Cepat**",[118,6756,6757],{"class":124}," | Fitur pencarian cerdas yang menampilkan hasil hanya dalam milidetik.                            |\n",[118,6759,6760,6763,6766],{"class":120,"line":1265},[118,6761,6762],{"class":124},"| ğŸ’¾ ",[118,6764,6765],{"class":5647},"**Penyimpanan Lokal**",[118,6767,6768],{"class":124},"| Menggunakan file JSON untuk menyimpan data secara aman dan fleksibel.                           |\n",[118,6770,6771],{"class":120,"line":1270},[118,6772,173],{"emptyLinePlaceholder":30},[118,6774,6775],{"class":120,"line":1275},[118,6776,1165],{"class":5637},[118,6778,6779],{"class":120,"line":1280},[118,6780,173],{"emptyLinePlaceholder":30},[118,6782,6783],{"class":120,"line":1286},[118,6784,6785],{"class":5637},"## ğŸ›  Cetak Biru Teknologi\n",[118,6787,6788],{"class":120,"line":1291},[118,6789,173],{"emptyLinePlaceholder":30},[118,6791,6792],{"class":120,"line":1297},[118,6793,6794],{"class":124},"| Komponen           | Teknologi yang Digunakan |\n",[118,6796,6797],{"class":120,"line":1302},[118,6798,6799],{"class":124},"|--------------------|--------------------------|\n",[118,6801,6802],{"class":120,"line":1308},[118,6803,6804],{"class":124},"| Bahasa Pemrograman | Java 21                  |\n",[118,6806,6807],{"class":120,"line":1314},[118,6808,6809],{"class":124},"| Framework UI       | JavaFX                   |\n",[118,6811,6812],{"class":120,"line":1320},[118,6813,6814],{"class":124},"| Build Tool         | Gradle                   |\n",[118,6816,6817],{"class":120,"line":1326},[118,6818,6819],{"class":124},"| Data Handling      | Jackson (JSON Library)   |\n",[118,6821,6822],{"class":120,"line":1332},[118,6823,6824],{"class":124},"| Styling            | CSS                      |\n",[118,6826,6827],{"class":120,"line":1338},[118,6828,6829],{"class":124},"| Penyimpanan        | Berbasis File JSON       |\n",[118,6831,6832],{"class":120,"line":1344},[118,6833,6834],{"class":124},"| Pengujian          | JUnit                    |\n",[118,6836,6837],{"class":120,"line":1349},[118,6838,6839],{"class":124},"| Version Control    | Git                      |\n",[118,6841,6842],{"class":120,"line":1355},[118,6843,6844],{"class":124},"| Dokumentasi        | Markdown                 |\n",[118,6846,6847],{"class":120,"line":1360},[118,6848,173],{"emptyLinePlaceholder":30},[118,6850,6851],{"class":120,"line":1366},[118,6852,1165],{"class":5637},[118,6854,6855],{"class":120,"line":1372},[118,6856,173],{"emptyLinePlaceholder":30},[118,6858,6859],{"class":120,"line":1378},[118,6860,6861],{"class":5637},"## âš™ Cara Menjalankan Aplikasi\n",[118,6863,6864],{"class":120,"line":1384},[118,6865,173],{"emptyLinePlaceholder":30},[118,6867,6868,6871,6873],{"class":120,"line":1390},[118,6869,6870],{"class":124},"Langkah-langkah untuk menjalankan ",[118,6872,6665],{"class":5659},[118,6874,6875],{"class":124}," di lokal:\n",[118,6877,6878],{"class":120,"line":1395},[118,6879,173],{"emptyLinePlaceholder":30},[118,6881,6882],{"class":120,"line":1401},[118,6883,6884],{"class":124},"```sh\n",[118,6886,6887],{"class":120,"line":1406},[118,6888,6889],{"class":124},"# 1. Clone repositori\n",[118,6891,6892],{"class":120,"line":1411},[118,6893,6894],{"class":124},"git clone https://github.com/SYECHYUSUF/InNOut.git\n",[118,6896,6897],{"class":120,"line":1416},[118,6898,173],{"emptyLinePlaceholder":30},[118,6900,6901],{"class":120,"line":1422},[118,6902,6903],{"class":124},"# 2. Masuk ke direktori\n",[118,6905,6906],{"class":120,"line":1427},[118,6907,6908],{"class":124},"cd InNOut\n",[118,6910,6911],{"class":120,"line":1433},[118,6912,173],{"emptyLinePlaceholder":30},[118,6914,6915],{"class":120,"line":1439},[118,6916,6917],{"class":124},"# 3. Jalankan dengan Gradle\n",[118,6919,6920],{"class":120,"line":1445},[118,6921,6922],{"class":124},"# Windows:\n",[118,6924,6925],{"class":120,"line":1451},[118,6926,6927],{"class":124},".\\gradlew run\n",[118,6929,6930],{"class":120,"line":1457},[118,6931,173],{"emptyLinePlaceholder":30},[118,6933,6934],{"class":120,"line":1462},[118,6935,6936],{"class":124},"# macOS / Linux:\n",[118,6938,6939],{"class":120,"line":1468},[118,6940,6941],{"class":124},"./gradlew run\n",[53,6943,6945],{"id":6944},"prinsip-oop-yang-digunakan","ğŸ’¡ Prinsip OOP yang Digunakan",[17,6947,6948],{},"Aplikasi ini dibangun dengan fondasi kuat dari prinsip-prinsip Object-Oriented Programming:",[1652,6950,6951,6957,6963],{},[1655,6952,6953,6956],{},[101,6954,6955],{},"Encapsulation:"," Objek sebagai kotak hitam yang hanya bisa diakses lewat method publik.",[1655,6958,6959,6962],{},[101,6960,6961],{},"Inheritance:"," Penghindaran duplikasi lewat pewarisan antar kelas.",[1655,6964,6965,6968],{},[101,6966,6967],{},"Abstraction & Polymorphism:"," Kode fleksibel dan reusable dengan interface & kelas abstrak.",[53,6970,6972],{"id":6971},"tim-pengembang","ğŸ‘¥ Tim Pengembang",[17,6974,6975],{},"Nama Peran GitHub :",[17,6977,6978,6981],{},[101,6979,6980],{},"Chandra Andaya"," Lead Developer, OOP Architect @twelverakki",[17,6983,6984,6987],{},[101,6985,6986],{},"Raihan Ramadhan"," UI/UX Designer, Frontend Developer @rainnfu",[17,6989,6990,6993],{},[101,6991,6992],{},"Moch Syech Yusuf M"," (Ucup) QA & System Integration @SYECHYUSUF",[53,6995,6997],{"id":6996},"temui-kami","ğŸŒ Temui Kami",[1652,6999,7000,7003],{},[1655,7001,7002],{},"ğŸ’» GitHub Project: InNOut by SYECHYUSUF",[1655,7004,7005,7006,811,7009,811,7012],{},"ğŸ“¸ Instagram (Tim): ",[71,7007,7008],{},"@Chndr_andy",[71,7010,7011],{},"@rainnfu",[71,7013,7014],{},"@syechyusufm",[53,7016,7018],{"id":7017},"catatan-akhir","ğŸ“ Catatan Akhir",[1752,7020,7021],{},[17,7022,7023,7024,7027],{},"Proyek ini adalah bagian dari ",[101,7025,7026],{},"Tugas Akhir Lab Pemrograman Berorientasi Objek (OOP) 2025"," di Universitas Hasanuddin, Makassar â€” Prodi Sistem Informasi. Diharapkan bisa menjadi contoh penerapan desain sistem berbasis objek yang kuat, rapi, dan mudah dikembangkan.",[1752,7029,7030],{},[17,7031,7032],{},"âœ¨ Terima kasih telah membaca! Jangan lupa â­ project ini jika menurutmu bermanfaat.",[308,7034,7035],{},"html pre.shiki code .sXvaJ, html code.shiki .sXvaJ{--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;--shiki-default:#79B8FF;--shiki-default-font-weight:bold;--shiki-light:#005CC5;--shiki-light-font-weight:bold}html pre.shiki code .suVJd, html code.shiki .suVJd{--shiki-dark:#E1E4E8;--shiki-default:#E1E4E8;--shiki-light:#24292E}html pre.shiki code .s8Wv-, html code.shiki .s8Wv-{--shiki-dark:#DBEDFF;--shiki-dark-text-decoration:underline;--shiki-default:#DBEDFF;--shiki-default-text-decoration:underline;--shiki-light:#032F62;--shiki-light-text-decoration:underline}html pre.shiki code .snYz-, html code.shiki .snYz-{--shiki-dark:#E1E4E8;--shiki-dark-text-decoration:underline;--shiki-default:#E1E4E8;--shiki-default-text-decoration:underline;--shiki-light:#24292E;--shiki-light-text-decoration:underline}html pre.shiki code .scWFE, html code.shiki .scWFE{--shiki-dark:#85E89D;--shiki-default:#85E89D;--shiki-light:#22863A}html pre.shiki code .sszsK, html code.shiki .sszsK{--shiki-dark:#E1E4E8;--shiki-dark-font-style:italic;--shiki-default:#E1E4E8;--shiki-default-font-style:italic;--shiki-light:#24292E;--shiki-light-font-style:italic}html pre.shiki code .s9_AW, html code.shiki .s9_AW{--shiki-dark:#E1E4E8;--shiki-dark-font-weight:bold;--shiki-default:#E1E4E8;--shiki-default-font-weight:bold;--shiki-light:#24292E;--shiki-light-font-weight:bold}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}",{"title":15,"searchDepth":25,"depth":25,"links":7037},[7038,7039,7040,7041],{"id":6944,"depth":25,"text":6945},{"id":6971,"depth":25,"text":6972},{"id":6996,"depth":25,"text":6997},{"id":7017,"depth":25,"text":7018},"20/10/2023","â€œAplikasi Java berorientasi objek untuk mengelola aktivitas check-in dan check-out secara efisien.â€",{"script":7045},[7046],{"type":1781,"key":1782,"data-nuxt-schema-org":30,"nodes":7047},[7048],{"_resolver":1785},"/articles/foto21.jpg",{},{"props":7052},{},"/en/articles/launch-your-portfolio","5",{"_resolver":1785},{"title":6551,"description":7043},{"loc":7053,"videos":7058,"images":7059,"lastmod":7060},[],[],"2025-06-17T00:00:00.000Z","en/articles/launch-your-portfolio",[7063,7064,7065,1116],"Portfolio","Development","Design","1UJFqJLeFfVclaJ9hj90tmiyEUWoZNl_WIPAj9XBxLQ",{"id":7068,"title":7069,"body":7070,"date":27,"description":8043,"extension":28,"head":8044,"image":8049,"meta":8050,"navigation":30,"ogImage":8051,"path":8053,"readingTime":27,"robots":27,"schemaOrg":8054,"seo":8055,"sitemap":8056,"stem":8059,"tags":8060,"__hash__":8061},"articles_en/en/articles/n-queens-problem.md","Masalah N-Queen",{"type":7,"value":7071,"toc":8030},[7072,7076,7265,7268,7673,7676,7876,7880,7884,7895,7899,7914,7918,7922,7942,7946,7969,7973,8003,8005,8019,8027],[269,7073,7075],{"id":7074},"n-queens-problem","N QUEENS PROBLEM",[109,7077,7079],{"className":1129,"code":7078,"language":1131,"meta":15,"style":15},"# Apa itu Masalah N-Queen?\n\n**Masalah N-Queen** adalah sebuah teka-teki klasik dalam ilmu komputer yang menanyakan:\n\n> \"Bagaimana cara menempatkan **N ratu** pada papan catur **NÃ—N** sehingga **tidak ada dua ratu yang saling menyerang**?\"\n\nArtinya, tidak ada dua ratu yang berada dalam **baris**, **kolom**, atau **diagonal** yang sama.\n\n---\n\n## Sejarah Singkat\n\nMasalah ini pertama kali diperkenalkan oleh **Max Bezzel** pada tahun **1848** dan telah menjadi:\n- ğŸ”„ Contoh klasik untuk **algoritma backtracking**\n- ğŸ§  Pertanyaan umum dalam **wawancara teknis**\n- ğŸ“ Materi pengajaran **rekursi dan constraint solving**\n- ğŸ”¬ Topik riset dalam **AI dan optimisasi kombinatorial**\n\n---\n\n## Aturan & Kendala\n\n### ğŸ” Pergerakan Ratu Catur\nRatu dapat menyerang:\n- Secara **horizontal** (baris)\n- Secara **vertikal** (kolom)\n- Secara **diagonal** (â†˜ dan â†™)\n\n### âœ… Syarat Solusi:\n- Tepat **N ratu** ditempatkan di papan **NÃ—N**\n- Tidak ada dua ratu yang berada:\n  - Pada baris yang sama\n  - Pada kolom yang sama\n  - Pada diagonal yang sama\n\n---\n\n## Contoh Masalah: 4-Queen\n\nSalah satu solusi untuk **N=4**:\n\n",[71,7080,7081,7086,7090,7095,7099,7104,7108,7113,7117,7121,7125,7130,7134,7139,7144,7149,7154,7159,7163,7167,7171,7176,7180,7185,7190,7195,7200,7205,7209,7214,7219,7224,7229,7234,7239,7243,7247,7251,7256,7260],{"__ignoreMap":15},[118,7082,7083],{"class":120,"line":121},[118,7084,7085],{},"# Apa itu Masalah N-Queen?\n",[118,7087,7088],{"class":120,"line":25},[118,7089,173],{"emptyLinePlaceholder":30},[118,7091,7092],{"class":120,"line":170},[118,7093,7094],{},"**Masalah N-Queen** adalah sebuah teka-teki klasik dalam ilmu komputer yang menanyakan:\n",[118,7096,7097],{"class":120,"line":176},[118,7098,173],{"emptyLinePlaceholder":30},[118,7100,7101],{"class":120,"line":195},[118,7102,7103],{},"> \"Bagaimana cara menempatkan **N ratu** pada papan catur **NÃ—N** sehingga **tidak ada dua ratu yang saling menyerang**?\"\n",[118,7105,7106],{"class":120,"line":201},[118,7107,173],{"emptyLinePlaceholder":30},[118,7109,7110],{"class":120,"line":207},[118,7111,7112],{},"Artinya, tidak ada dua ratu yang berada dalam **baris**, **kolom**, atau **diagonal** yang sama.\n",[118,7114,7115],{"class":120,"line":216},[118,7116,173],{"emptyLinePlaceholder":30},[118,7118,7119],{"class":120,"line":222},[118,7120,1165],{},[118,7122,7123],{"class":120,"line":228},[118,7124,173],{"emptyLinePlaceholder":30},[118,7126,7127],{"class":120,"line":238},[118,7128,7129],{},"## Sejarah Singkat\n",[118,7131,7132],{"class":120,"line":243},[118,7133,173],{"emptyLinePlaceholder":30},[118,7135,7136],{"class":120,"line":252},[118,7137,7138],{},"Masalah ini pertama kali diperkenalkan oleh **Max Bezzel** pada tahun **1848** dan telah menjadi:\n",[118,7140,7141],{"class":120,"line":263},[118,7142,7143],{},"- ğŸ”„ Contoh klasik untuk **algoritma backtracking**\n",[118,7145,7146],{"class":120,"line":279},[118,7147,7148],{},"- ğŸ§  Pertanyaan umum dalam **wawancara teknis**\n",[118,7150,7151],{"class":120,"line":289},[118,7152,7153],{},"- ğŸ“ Materi pengajaran **rekursi dan constraint solving**\n",[118,7155,7156],{"class":120,"line":298},[118,7157,7158],{},"- ğŸ”¬ Topik riset dalam **AI dan optimisasi kombinatorial**\n",[118,7160,7161],{"class":120,"line":303},[118,7162,173],{"emptyLinePlaceholder":30},[118,7164,7165],{"class":120,"line":316},[118,7166,1165],{},[118,7168,7169],{"class":120,"line":321},[118,7170,173],{"emptyLinePlaceholder":30},[118,7172,7173],{"class":120,"line":666},[118,7174,7175],{},"## Aturan & Kendala\n",[118,7177,7178],{"class":120,"line":1036},[118,7179,173],{"emptyLinePlaceholder":30},[118,7181,7182],{"class":120,"line":1042},[118,7183,7184],{},"### ğŸ” Pergerakan Ratu Catur\n",[118,7186,7187],{"class":120,"line":1242},[118,7188,7189],{},"Ratu dapat menyerang:\n",[118,7191,7192],{"class":120,"line":1248},[118,7193,7194],{},"- Secara **horizontal** (baris)\n",[118,7196,7197],{"class":120,"line":1254},[118,7198,7199],{},"- Secara **vertikal** (kolom)\n",[118,7201,7202],{"class":120,"line":1259},[118,7203,7204],{},"- Secara **diagonal** (â†˜ dan â†™)\n",[118,7206,7207],{"class":120,"line":1265},[118,7208,173],{"emptyLinePlaceholder":30},[118,7210,7211],{"class":120,"line":1270},[118,7212,7213],{},"### âœ… Syarat Solusi:\n",[118,7215,7216],{"class":120,"line":1275},[118,7217,7218],{},"- Tepat **N ratu** ditempatkan di papan **NÃ—N**\n",[118,7220,7221],{"class":120,"line":1280},[118,7222,7223],{},"- Tidak ada dua ratu yang berada:\n",[118,7225,7226],{"class":120,"line":1286},[118,7227,7228],{},"  - Pada baris yang sama\n",[118,7230,7231],{"class":120,"line":1291},[118,7232,7233],{},"  - Pada kolom yang sama\n",[118,7235,7236],{"class":120,"line":1297},[118,7237,7238],{},"  - Pada diagonal yang sama\n",[118,7240,7241],{"class":120,"line":1302},[118,7242,173],{"emptyLinePlaceholder":30},[118,7244,7245],{"class":120,"line":1308},[118,7246,1165],{},[118,7248,7249],{"class":120,"line":1314},[118,7250,173],{"emptyLinePlaceholder":30},[118,7252,7253],{"class":120,"line":1320},[118,7254,7255],{},"## Contoh Masalah: 4-Queen\n",[118,7257,7258],{"class":120,"line":1326},[118,7259,173],{"emptyLinePlaceholder":30},[118,7261,7262],{"class":120,"line":1332},[118,7263,7264],{},"Salah satu solusi untuk **N=4**:\n",[17,7266,7267],{},". Q . . . . . Q Q . . . . . Q .",[109,7269,7271],{"className":1994,"code":7270,"language":1996,"meta":15,"style":15},"\nAda **2 solusi fundamental** untuk N=4 (tanpa rotasi dan refleksi).\n\n---\n\n## Pendekatan Penyelesaian: Backtracking\n\nLangkah-langkah:\n1. Tempatkan ratu **satu per satu** di **setiap kolom**.\n2. Coba semua baris di kolom saat ini.\n3. Untuk setiap posisi:\n   - âœ… Periksa apakah aman (tidak diserang ratu lain).\n   - Jika aman, lanjut ke kolom berikutnya.\n   - Jika tidak, **backtrack** (kembali ke langkah sebelumnya).\n\n### ğŸ’¡ Optimalisasi\nSaat memeriksa posisi `(row, col)`:\n- Hanya perlu memeriksa ratu yang **sudah ditempatkan di kolom-kolom kiri**.\n\n---\n\n## Implementasi Python\n\n```python\ndef solve_n_queens(n):\n    def is_safe(board, row, col):\n        for i in range(col):\n            if board[row][i] == 1:\n                return False\n        for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n            if board[i][j] == 1:\n                return False\n        for i, j in zip(range(row, n), range(col, -1, -1)):\n            if board[i][j] == 1:\n                return False\n        return True\n\n    def solve_util(board, col):\n        if col >= n:\n            solutions.append([row[:] for row in board])\n            return True\n        res = False\n        for i in range(n):\n            if is_safe(board, i, col):\n                board[i][col] = 1\n                res = solve_util(board, col + 1) or res\n                board[i][col] = 0\n        return res\n\n    solutions = []\n    board = [[0] * n for _ in range(n)]\n    solve_util(board, 0)\n    return solutions\n\n# Contoh\nn = 4\nsolutions = solve_n_queens(n)\nprint(f\"Jumlah solusi untuk {n}-Queen:\", len(solutions))\nfor sol in solutions:\n    for row in sol:\n        print(' '.join('Q' if cell else '.' for cell in row))\n    print()\n",[71,7272,7273,7277,7304,7308,7312,7316,7327,7331,7342,7368,7375,7387,7400,7407,7424,7428,7433,7443,7464,7468,7472,7476,7481,7485,7489,7494,7499,7504,7509,7514,7519,7524,7528,7533,7537,7541,7546,7550,7555,7560,7565,7570,7575,7580,7585,7590,7595,7600,7605,7609,7614,7619,7624,7629,7633,7638,7643,7648,7653,7658,7663,7668],{"__ignoreMap":15},[118,7274,7275],{"class":120,"line":121},[118,7276,173],{"emptyLinePlaceholder":30},[118,7278,7279,7282,7284,7286,7289,7291,7294,7297,7299,7301],{"class":120,"line":25},[118,7280,7281],{"class":124},"Ada ",[118,7283,2019],{"class":151},[118,7285,3795],{"class":182},[118,7287,7288],{"class":124}," solusi fundamental",[118,7290,2019],{"class":151},[118,7292,7293],{"class":124}," untuk ",[118,7295,7296],{"class":182},"N",[118,7298,139],{"class":151},[118,7300,3772],{"class":182},[118,7302,7303],{"class":124}," (tanpa rotasi dan refleksi).\n",[118,7305,7306],{"class":120,"line":170},[118,7307,173],{"emptyLinePlaceholder":30},[118,7309,7310],{"class":120,"line":176},[118,7311,1165],{"class":151},[118,7313,7314],{"class":120,"line":195},[118,7315,173],{"emptyLinePlaceholder":30},[118,7317,7318,7321,7324],{"class":120,"line":201},[118,7319,7320],{"class":124},"## Pendekatan ",[118,7322,7323],{"class":132},"Penyelesaian",[118,7325,7326],{"class":124},": Backtracking\n",[118,7328,7329],{"class":120,"line":207},[118,7330,173],{"emptyLinePlaceholder":30},[118,7332,7333,7335,7337,7340],{"class":120,"line":216},[118,7334,2884],{"class":124},[118,7336,2887],{"class":151},[118,7338,7339],{"class":132},"langkah",[118,7341,2054],{"class":124},[118,7343,7344,7346,7349,7351,7354,7356,7359,7361,7364,7366],{"class":120,"line":222},[118,7345,2081],{"class":182},[118,7347,7348],{"class":124}," Tempatkan ratu ",[118,7350,2019],{"class":151},[118,7352,7353],{"class":124},"satu per satu",[118,7355,2019],{"class":151},[118,7357,7358],{"class":124}," di ",[118,7360,2019],{"class":151},[118,7362,7363],{"class":124},"setiap kolom",[118,7365,2019],{"class":151},[118,7367,2039],{"class":124},[118,7369,7370,7372],{"class":120,"line":228},[118,7371,2109],{"class":182},[118,7373,7374],{"class":124}," Coba semua baris di kolom saat ini.\n",[118,7376,7377,7379,7382,7385],{"class":120,"line":238},[118,7378,2139],{"class":182},[118,7380,7381],{"class":124}," Untuk setiap ",[118,7383,7384],{"class":132},"posisi",[118,7386,2054],{"class":124},[118,7388,7389,7391,7394,7397],{"class":120,"line":243},[118,7390,5898],{"class":151},[118,7392,7393],{"class":124}," âœ… Periksa apakah ",[118,7395,7396],{"class":132},"aman",[118,7398,7399],{"class":124}," (tidak diserang ratu lain).\n",[118,7401,7402,7404],{"class":120,"line":252},[118,7403,5898],{"class":151},[118,7405,7406],{"class":124}," Jika aman, lanjut ke kolom berikutnya.\n",[118,7408,7409,7411,7414,7416,7419,7421],{"class":120,"line":263},[118,7410,5898],{"class":151},[118,7412,7413],{"class":124}," Jika tidak, ",[118,7415,2019],{"class":151},[118,7417,7418],{"class":124},"backtrack",[118,7420,2019],{"class":151},[118,7422,7423],{"class":124}," (kembali ke langkah sebelumnya).\n",[118,7425,7426],{"class":120,"line":279},[118,7427,173],{"emptyLinePlaceholder":30},[118,7429,7430],{"class":120,"line":289},[118,7431,7432],{"class":124},"### ğŸ’¡ Optimalisasi\n",[118,7434,7435,7438,7441],{"class":120,"line":298},[118,7436,7437],{"class":124},"Saat memeriksa posisi ",[118,7439,7440],{"class":142},"`(row, col)`",[118,7442,2054],{"class":124},[118,7444,7445,7447,7450,7452,7455,7457,7460,7462],{"class":120,"line":303},[118,7446,2887],{"class":151},[118,7448,7449],{"class":124}," Hanya perlu memeriksa ratu yang ",[118,7451,2019],{"class":151},[118,7453,7454],{"class":124},"sudah ditempatkan di kolom",[118,7456,2887],{"class":151},[118,7458,7459],{"class":124},"kolom kiri",[118,7461,2019],{"class":151},[118,7463,2039],{"class":124},[118,7465,7466],{"class":120,"line":316},[118,7467,173],{"emptyLinePlaceholder":30},[118,7469,7470],{"class":120,"line":321},[118,7471,1165],{"class":151},[118,7473,7474],{"class":120,"line":666},[118,7475,173],{"emptyLinePlaceholder":30},[118,7477,7478],{"class":120,"line":1036},[118,7479,7480],{"class":124},"## Implementasi Python\n",[118,7482,7483],{"class":120,"line":1042},[118,7484,173],{"emptyLinePlaceholder":30},[118,7486,7487],{"class":120,"line":1242},[118,7488,1430],{"class":142},[118,7490,7491],{"class":120,"line":1248},[118,7492,7493],{"class":142},"def solve_n_queens(n):\n",[118,7495,7496],{"class":120,"line":1254},[118,7497,7498],{"class":142},"    def is_safe(board, row, col):\n",[118,7500,7501],{"class":120,"line":1259},[118,7502,7503],{"class":142},"        for i in range(col):\n",[118,7505,7506],{"class":120,"line":1265},[118,7507,7508],{"class":142},"            if board[row][i] == 1:\n",[118,7510,7511],{"class":120,"line":1270},[118,7512,7513],{"class":142},"                return False\n",[118,7515,7516],{"class":120,"line":1275},[118,7517,7518],{"class":142},"        for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n",[118,7520,7521],{"class":120,"line":1280},[118,7522,7523],{"class":142},"            if board[i][j] == 1:\n",[118,7525,7526],{"class":120,"line":1286},[118,7527,7513],{"class":142},[118,7529,7530],{"class":120,"line":1291},[118,7531,7532],{"class":142},"        for i, j in zip(range(row, n), range(col, -1, -1)):\n",[118,7534,7535],{"class":120,"line":1297},[118,7536,7523],{"class":142},[118,7538,7539],{"class":120,"line":1302},[118,7540,7513],{"class":142},[118,7542,7543],{"class":120,"line":1308},[118,7544,7545],{"class":142},"        return True\n",[118,7547,7548],{"class":120,"line":1314},[118,7549,173],{"emptyLinePlaceholder":30},[118,7551,7552],{"class":120,"line":1320},[118,7553,7554],{"class":142},"    def solve_util(board, col):\n",[118,7556,7557],{"class":120,"line":1326},[118,7558,7559],{"class":142},"        if col >= n:\n",[118,7561,7562],{"class":120,"line":1332},[118,7563,7564],{"class":142},"            solutions.append([row[:] for row in board])\n",[118,7566,7567],{"class":120,"line":1338},[118,7568,7569],{"class":142},"            return True\n",[118,7571,7572],{"class":120,"line":1344},[118,7573,7574],{"class":142},"        res = False\n",[118,7576,7577],{"class":120,"line":1349},[118,7578,7579],{"class":142},"        for i in range(n):\n",[118,7581,7582],{"class":120,"line":1355},[118,7583,7584],{"class":142},"            if is_safe(board, i, col):\n",[118,7586,7587],{"class":120,"line":1360},[118,7588,7589],{"class":142},"                board[i][col] = 1\n",[118,7591,7592],{"class":120,"line":1366},[118,7593,7594],{"class":142},"                res = solve_util(board, col + 1) or res\n",[118,7596,7597],{"class":120,"line":1372},[118,7598,7599],{"class":142},"                board[i][col] = 0\n",[118,7601,7602],{"class":120,"line":1378},[118,7603,7604],{"class":142},"        return res\n",[118,7606,7607],{"class":120,"line":1384},[118,7608,173],{"emptyLinePlaceholder":30},[118,7610,7611],{"class":120,"line":1390},[118,7612,7613],{"class":142},"    solutions = []\n",[118,7615,7616],{"class":120,"line":1395},[118,7617,7618],{"class":142},"    board = [[0] * n for _ in range(n)]\n",[118,7620,7621],{"class":120,"line":1401},[118,7622,7623],{"class":142},"    solve_util(board, 0)\n",[118,7625,7626],{"class":120,"line":1406},[118,7627,7628],{"class":142},"    return solutions\n",[118,7630,7631],{"class":120,"line":1411},[118,7632,173],{"emptyLinePlaceholder":30},[118,7634,7635],{"class":120,"line":1416},[118,7636,7637],{"class":142},"# Contoh\n",[118,7639,7640],{"class":120,"line":1422},[118,7641,7642],{"class":142},"n = 4\n",[118,7644,7645],{"class":120,"line":1427},[118,7646,7647],{"class":142},"solutions = solve_n_queens(n)\n",[118,7649,7650],{"class":120,"line":1433},[118,7651,7652],{"class":142},"print(f\"Jumlah solusi untuk {n}-Queen:\", len(solutions))\n",[118,7654,7655],{"class":120,"line":1439},[118,7656,7657],{"class":142},"for sol in solutions:\n",[118,7659,7660],{"class":120,"line":1445},[118,7661,7662],{"class":142},"    for row in sol:\n",[118,7664,7665],{"class":120,"line":1451},[118,7666,7667],{"class":142},"        print(' '.join('Q' if cell else '.' for cell in row))\n",[118,7669,7670],{"class":120,"line":1457},[118,7671,7672],{"class":142},"    print()\n",[53,7674,7675],{"id":5186},"Implementasi JavaScript",[109,7677,7679],{"className":1536,"code":7678,"language":1538,"meta":15,"style":15},"function solveNQueens(n) {\n    const solutions = [];\n\n    function isSafe(board, row, col) {\n        for (let i = 0; i \u003C col; i++) {\n            if (board[row][i] === 1) return false;\n        }\n        for (let i = row, j = col; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] === 1) return false;\n        }\n        for (let i = row, j = col; i \u003C n && j >= 0; i++, j--) {\n            if (board[i][j] === 1) return false;\n        }\n        return true;\n    }\n\n    function solveUtil(board, col) {\n        if (col === n) {\n            solutions.push(board.map(row => [...row]));\n            return;\n        }\n        for (let i = 0; i \u003C n; i++) {\n            if (isSafe(board, i, col)) {\n                board[i][col] = 1;\n                solveUtil(board, col + 1);\n                board[i][col] = 0;\n            }\n        }\n    }\n\n    const board = Array(n).fill().map(() => Array(n).fill(0));\n    solveUtil(board, 0);\n    return solutions;\n}\n\n// Contoh\nconst solutions = solveNQueens(4);\nconsole.log(\"Jumlah solusi:\", solutions.length);\nsolutions.forEach((sol, idx) => {\n    console.log(`Solusi ${idx + 1}:`);\n    console.log(sol.map(row => row.map(c => c ? \"Q\" : \".\").join(\" \")).join(\"\\n\"));\n});\n",[71,7680,7681,7686,7691,7695,7700,7705,7710,7714,7719,7724,7728,7733,7737,7741,7746,7750,7754,7759,7764,7769,7774,7778,7783,7788,7793,7798,7803,7807,7811,7815,7819,7824,7829,7834,7838,7842,7847,7852,7857,7862,7867,7872],{"__ignoreMap":15},[118,7682,7683],{"class":120,"line":121},[118,7684,7685],{},"function solveNQueens(n) {\n",[118,7687,7688],{"class":120,"line":25},[118,7689,7690],{},"    const solutions = [];\n",[118,7692,7693],{"class":120,"line":170},[118,7694,173],{"emptyLinePlaceholder":30},[118,7696,7697],{"class":120,"line":176},[118,7698,7699],{},"    function isSafe(board, row, col) {\n",[118,7701,7702],{"class":120,"line":195},[118,7703,7704],{},"        for (let i = 0; i \u003C col; i++) {\n",[118,7706,7707],{"class":120,"line":201},[118,7708,7709],{},"            if (board[row][i] === 1) return false;\n",[118,7711,7712],{"class":120,"line":207},[118,7713,1598],{},[118,7715,7716],{"class":120,"line":216},[118,7717,7718],{},"        for (let i = row, j = col; i >= 0 && j >= 0; i--, j--) {\n",[118,7720,7721],{"class":120,"line":222},[118,7722,7723],{},"            if (board[i][j] === 1) return false;\n",[118,7725,7726],{"class":120,"line":228},[118,7727,1598],{},[118,7729,7730],{"class":120,"line":238},[118,7731,7732],{},"        for (let i = row, j = col; i \u003C n && j >= 0; i++, j--) {\n",[118,7734,7735],{"class":120,"line":243},[118,7736,7723],{},[118,7738,7739],{"class":120,"line":252},[118,7740,1598],{},[118,7742,7743],{"class":120,"line":263},[118,7744,7745],{},"        return true;\n",[118,7747,7748],{"class":120,"line":279},[118,7749,621],{},[118,7751,7752],{"class":120,"line":289},[118,7753,173],{"emptyLinePlaceholder":30},[118,7755,7756],{"class":120,"line":298},[118,7757,7758],{},"    function solveUtil(board, col) {\n",[118,7760,7761],{"class":120,"line":303},[118,7762,7763],{},"        if (col === n) {\n",[118,7765,7766],{"class":120,"line":316},[118,7767,7768],{},"            solutions.push(board.map(row => [...row]));\n",[118,7770,7771],{"class":120,"line":321},[118,7772,7773],{},"            return;\n",[118,7775,7776],{"class":120,"line":666},[118,7777,1598],{},[118,7779,7780],{"class":120,"line":1036},[118,7781,7782],{},"        for (let i = 0; i \u003C n; i++) {\n",[118,7784,7785],{"class":120,"line":1042},[118,7786,7787],{},"            if (isSafe(board, i, col)) {\n",[118,7789,7790],{"class":120,"line":1242},[118,7791,7792],{},"                board[i][col] = 1;\n",[118,7794,7795],{"class":120,"line":1248},[118,7796,7797],{},"                solveUtil(board, col + 1);\n",[118,7799,7800],{"class":120,"line":1254},[118,7801,7802],{},"                board[i][col] = 0;\n",[118,7804,7805],{"class":120,"line":1259},[118,7806,2362],{},[118,7808,7809],{"class":120,"line":1265},[118,7810,1598],{},[118,7812,7813],{"class":120,"line":1270},[118,7814,621],{},[118,7816,7817],{"class":120,"line":1275},[118,7818,173],{"emptyLinePlaceholder":30},[118,7820,7821],{"class":120,"line":1280},[118,7822,7823],{},"    const board = Array(n).fill().map(() => Array(n).fill(0));\n",[118,7825,7826],{"class":120,"line":1286},[118,7827,7828],{},"    solveUtil(board, 0);\n",[118,7830,7831],{"class":120,"line":1291},[118,7832,7833],{},"    return solutions;\n",[118,7835,7836],{"class":120,"line":1297},[118,7837,757],{},[118,7839,7840],{"class":120,"line":1302},[118,7841,173],{"emptyLinePlaceholder":30},[118,7843,7844],{"class":120,"line":1308},[118,7845,7846],{},"// Contoh\n",[118,7848,7849],{"class":120,"line":1314},[118,7850,7851],{},"const solutions = solveNQueens(4);\n",[118,7853,7854],{"class":120,"line":1320},[118,7855,7856],{},"console.log(\"Jumlah solusi:\", solutions.length);\n",[118,7858,7859],{"class":120,"line":1326},[118,7860,7861],{},"solutions.forEach((sol, idx) => {\n",[118,7863,7864],{"class":120,"line":1332},[118,7865,7866],{},"    console.log(`Solusi ${idx + 1}:`);\n",[118,7868,7869],{"class":120,"line":1338},[118,7870,7871],{},"    console.log(sol.map(row => row.map(c => c ? \"Q\" : \".\").join(\" \")).join(\"\\n\"));\n",[118,7873,7874],{"class":120,"line":1344},[118,7875,225],{},[53,7877,7879],{"id":7878},"kompleksitas-algoritma","Kompleksitas Algoritma",[85,7881,7883],{"id":7882},"waktu","â± Waktu:",[1652,7885,7886,7892],{},[1655,7887,7888,7891],{},[101,7889,7890],{},"O(N!)"," pada kasus terburuk (karena percobaan kombinasi posisi)",[1655,7893,7894],{},"Dapat dioptimalkan menggunakan bitmask dan pruning",[85,7896,7898],{"id":7897},"ruang","ğŸ§  Ruang:",[1652,7900,7901,7907],{},[1655,7902,7903,7906],{},[101,7904,7905],{},"O(NÂ²)"," untuk menyimpan papan",[1655,7908,7909,7910,7913],{},"Dapat dikurangi menjadi ",[101,7911,7912],{},"O(N)"," hanya dengan array posisi per kolom",[53,7915,7917],{"id":7916},"optimisasi-variasi","Optimisasi & Variasi",[85,7919,7921],{"id":7920},"optimisasi","ğŸ”§ Optimisasi:",[1652,7923,7924,7930,7936],{},[1655,7925,7926,7929],{},[101,7927,7928],{},"Bitmasking",": Representasi baris, kolom, dan diagonal dalam bentuk bit",[1655,7931,7932,7935],{},[101,7933,7934],{},"Symmetry Breaking",": Kurangi solusi duplikat dengan membatasi pilihan awal",[1655,7937,7938,7941],{},[101,7939,7940],{},"Heuristik MRV (Minimum Remaining Value)",": Prioritaskan baris dengan pilihan terbatas",[85,7943,7945],{"id":7944},"variasi","ğŸ” Variasi:",[1652,7947,7948,7957,7963],{},[1655,7949,7950,3591,7953,7956],{},[101,7951,7952],{},"N-Bishop",[101,7954,7955],{},"N-Rook",": Hanya pergerakan tertentu yang diperbolehkan",[1655,7958,7959,7962],{},[101,7960,7961],{},"Superqueen",": Gabungan ratu dan kuda",[1655,7964,7965,7968],{},[101,7966,7967],{},"3D N-Queen",": Penempatan ratu di papan kubus 3D",[53,7970,7972],{"id":7971},"aplikasi-dunia-nyata","Aplikasi Dunia Nyata",[1652,7974,7975,7982,7989,7996],{},[1655,7976,7977,7978,7981],{},"âœˆï¸ ",[101,7979,7980],{},"Penjadwalan bandara",": Menempatkan pesawat agar tidak terjadi konflik landasan",[1655,7983,7984,7985,7988],{},"ğŸ” ",[101,7986,7987],{},"Constraint satisfaction problems (CSP)",": Dalam AI dan optimasi",[1655,7990,7991,7992,7995],{},"ğŸ”© ",[101,7993,7994],{},"Pengujian VLSI",": Untuk merancang sirkuit terintegrasi",[1655,7997,7998,7999,8002],{},"ğŸ§® ",[101,8000,8001],{},"Pengajaran algoritma",": Materi dasar dalam pemrograman kompetitif dan rekursi",[53,8004,2541],{"id":1731},[17,8006,8007,8008,8011,8012,5831,8015,8018],{},"Masalah ",[101,8009,8010],{},"N-Queen"," adalah contoh klasik yang indah dari ",[101,8013,8014],{},"backtracking",[101,8016,8017],{},"constraint solving",". Ia sederhana untuk dipahami, namun cukup kompleks untuk dijadikan latihan pemrograman yang menantang. Banyak algoritma lanjutan lahir dari pendekatan dasar yang digunakan dalam menyelesaikan N-Queen.",[1752,8020,8021],{},[17,8022,1695,8023,8026],{},[101,8024,8025],{},"Tip",": Latih dengan N kecil (mis. N=4 atau 5) sebelum mencoba optimisasi untuk N besar (N > 10).",[308,8028,8029],{},"html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html pre.shiki code .suVJd, html code.shiki .suVJd{--shiki-dark:#E1E4E8;--shiki-default:#E1E4E8;--shiki-light:#24292E}html pre.shiki code .sEiGg, html code.shiki .sEiGg{--shiki-dark:#F97583;--shiki-default:#F97583;--shiki-light:#D73A49}html pre.shiki code .sAPL1, html code.shiki .sAPL1{--shiki-dark:#79B8FF;--shiki-default:#79B8FF;--shiki-light:#005CC5}html pre.shiki code .s9E-l, html code.shiki .s9E-l{--shiki-dark:#B392F0;--shiki-default:#B392F0;--shiki-light:#6F42C1}html pre.shiki code .sYTnl, html code.shiki .sYTnl{--shiki-dark:#9ECBFF;--shiki-default:#9ECBFF;--shiki-light:#032F62}",{"title":15,"searchDepth":25,"depth":25,"links":8031},[8032,8033,8037,8041,8042],{"id":5186,"depth":25,"text":7675},{"id":7878,"depth":25,"text":7879,"children":8034},[8035,8036],{"id":7882,"depth":170,"text":7883},{"id":7897,"depth":170,"text":7898},{"id":7916,"depth":25,"text":7917,"children":8038},[8039,8040],{"id":7920,"depth":170,"text":7921},{"id":7944,"depth":170,"text":7945},{"id":7971,"depth":25,"text":7972},{"id":1731,"depth":25,"text":2541},"Teka-teki backtracking klasik: Menempatkan N ratu pada papan catur NÃ—N tanpa saling menyerang",{"script":8045},[8046],{"type":1781,"key":1782,"data-nuxt-schema-org":30,"nodes":8047},[8048],{"_resolver":1785},"/articles/7.jpeg",{},{"props":8052},{},"/en/articles/n-queens-problem",{"_resolver":1785},{"title":7069,"description":8043},{"loc":8053,"videos":8057,"images":8058,"lastmod":2579},[],[],"en/articles/n-queens-problem",[],"29ZSQLIhVKDAMrF-5cXIuxFZo2q_lJjVg1ZfcCUbXes",{"id":8063,"title":8064,"body":8065,"date":8095,"description":8096,"extension":28,"head":27,"image":8097,"meta":8098,"navigation":30,"ogImage":27,"path":8099,"readingTime":3747,"robots":27,"schemaOrg":27,"seo":8100,"sitemap":8101,"stem":8102,"tags":8103,"__hash__":8105},"articles_en/en/articles/not-an-impostor.md","You are not an impostor",{"type":7,"value":8066,"toc":8093},[8067,8072,8075,8078,8081,8084,8087,8090],[17,8068,8069],{},[45,8070],{"alt":47,"src":8071},"/articles/trap-of-perfection.jpg",[17,8073,8074],{},"In the theater of content creation, there are many who, backstage, whisper a phrase tinged with doubt: \"I'm not legitimate, others are so much better\". This melody of insecurity, often played over and over in the minds of emerging creators, is the first act of a much larger work: the conquest of one's own legitimacy.",[17,8076,8077],{},"Imagine yourself standing at the edge of the stage, dazzled by the spotlight of self-judgment. Every creator goes through this. But instead of sinking into the shadows of self-deprecation, take a moment to listen to the whispers of the audience: the other creators. What you hear is not a cacophony of criticism, but a chorus of experiences and lessons.",[17,8079,8080],{},"This is where the magic happens. Instead of seeing the stage as a place for competition, turn it into a space for learning. Let other people's successes inspire you, their mistakes teach you. This is not imitation, but a creative harmony where you can find your own rhythm, your own melody.",[17,8082,8083],{},"Your authenticity is your most precious instrument. Play it with confidence. Every note of your experience, your perspective, resonates in a unique way with your audience. Authenticity is a creator's true opus, far more captivating than the exhausting quest for perfection.",[17,8085,8086],{},"Remember, every creation is a rehearsal for the next. There's no grand finale where everything has to be perfect. It's a continuous concert, where each performance is better than the last.",[17,8088,8089],{},"And in this showroom, you're not alone. Backstage, you'll find plenty of mentors, peers and admirers. They're there to encourage you, to guide you, to applaud your successes and support you in your doubts. This community is your chorus of support, turning fearful solos into courageous duets.",[17,8091,8092],{},"In the end, every curtain raised, every light turned on, is a step closer to accepting your own talent. The feeling of imposture dissipates not when you compare yourself to others, but when you recognize the unique beauty of your own performance. In this room, success is measured not just by the applause at the end, but by the courage to get up on stage and say: \"Here's my story, listen to it\".",{"title":15,"searchDepth":25,"depth":25,"links":8094},[],"11/01/2024","In the theater of content creation, many backstage whisper a phrase tinged with doubt: 'I m not legitimate, others are so much better.' This melody of insecurity, often played over and over in the minds of emerging creators, is the first act of a much larger work: the conquest of one's own legitimacy.","https://canvas.hrcd.fr/articles/trap-of-perfection.jpg",{},"/en/articles/not-an-impostor",{"title":8064,"description":8096},{"loc":8099},"en/articles/not-an-impostor",[8104,1116],"Creation","5-o6CZaw6yEBqe_c0vkm3L44gGA1N7_5vIQ_MxByH_w",{"id":8107,"title":8108,"body":8109,"date":27,"description":8866,"extension":28,"head":8867,"image":8872,"meta":8873,"navigation":30,"ogImage":8874,"path":8876,"readingTime":27,"robots":27,"schemaOrg":8877,"seo":8878,"sitemap":8879,"stem":8882,"tags":8883,"__hash__":8884},"articles_en/en/articles/rat-in-maze.md","Memahami Algoritma Rat in Maze",{"type":7,"value":8110,"toc":8859},[8111,8115,8179,8182,8793,8795,8797,8818,8820,8835,8837,8851,8856],[269,8112,8114],{"id":8113},"rat-in-maze","RAT IN MAZE",[109,8116,8118],{"className":1129,"code":8117,"language":1131,"meta":15,"style":15},"# Apa itu Algoritma Rat in a Maze?\n\n**Rat in a Maze** adalah salah satu masalah klasik dalam pemrograman dan algoritma pencarian jalur. Tujuan dari algoritma ini adalah untuk menemukan **semua jalur** yang memungkinkan dari **titik awal (biasanya kiri atas)** ke **tujuan akhir (biasanya kanan bawah)** dalam sebuah labirin dua dimensi yang diwakili oleh **matriks**.\n\nSetiap sel dalam matriks bisa:\n- `1` â†’ jalan (bisa dilewati)\n- `0` â†’ dinding (tidak bisa dilewati)\n\n> ğŸ­ **Tikus** memulai dari `(0, 0)` dan ingin mencapai `(N-1, N-1)` hanya dengan bergerak ke **atas (U), bawah (D), kiri (L), atau kanan (R)** dan tidak boleh melewati sel yang sudah dilewati.\n\n---\n\n## Contoh Matriks (Maze)\n\n",[71,8119,8120,8125,8129,8134,8138,8143,8148,8153,8157,8162,8166,8170,8174],{"__ignoreMap":15},[118,8121,8122],{"class":120,"line":121},[118,8123,8124],{},"# Apa itu Algoritma Rat in a Maze?\n",[118,8126,8127],{"class":120,"line":25},[118,8128,173],{"emptyLinePlaceholder":30},[118,8130,8131],{"class":120,"line":170},[118,8132,8133],{},"**Rat in a Maze** adalah salah satu masalah klasik dalam pemrograman dan algoritma pencarian jalur. Tujuan dari algoritma ini adalah untuk menemukan **semua jalur** yang memungkinkan dari **titik awal (biasanya kiri atas)** ke **tujuan akhir (biasanya kanan bawah)** dalam sebuah labirin dua dimensi yang diwakili oleh **matriks**.\n",[118,8135,8136],{"class":120,"line":176},[118,8137,173],{"emptyLinePlaceholder":30},[118,8139,8140],{"class":120,"line":195},[118,8141,8142],{},"Setiap sel dalam matriks bisa:\n",[118,8144,8145],{"class":120,"line":201},[118,8146,8147],{},"- `1` â†’ jalan (bisa dilewati)\n",[118,8149,8150],{"class":120,"line":207},[118,8151,8152],{},"- `0` â†’ dinding (tidak bisa dilewati)\n",[118,8154,8155],{"class":120,"line":216},[118,8156,173],{"emptyLinePlaceholder":30},[118,8158,8159],{"class":120,"line":222},[118,8160,8161],{},"> ğŸ­ **Tikus** memulai dari `(0, 0)` dan ingin mencapai `(N-1, N-1)` hanya dengan bergerak ke **atas (U), bawah (D), kiri (L), atau kanan (R)** dan tidak boleh melewati sel yang sudah dilewati.\n",[118,8163,8164],{"class":120,"line":228},[118,8165,173],{"emptyLinePlaceholder":30},[118,8167,8168],{"class":120,"line":238},[118,8169,1165],{},[118,8171,8172],{"class":120,"line":243},[118,8173,173],{"emptyLinePlaceholder":30},[118,8175,8176],{"class":120,"line":252},[118,8177,8178],{},"## Contoh Matriks (Maze)\n",[17,8180,8181],{},"maze = [ [1, 0, 0, 0], [1, 1, 0, 1], [0, 1, 0, 0], [1, 1, 1, 1] ]",[109,8183,8185],{"className":1994,"code":8184,"language":1996,"meta":15,"style":15},"\n**Tujuan**: Temukan semua jalur dari `(0, 0)` ke `(3, 3)`. Dalam contoh ini, salah satu solusi bisa berupa jalur `DDRDRR`.\n\n---\n\n## Strategi Penyelesaian\n\n- Gunakan algoritma **Backtracking** untuk menjelajahi semua kemungkinan jalur.\n- Hanya lanjutkan ke sel jika:\n  - Berada dalam batas matriks.\n  - Nilainya `1` (jalan).\n  - Belum dikunjungi.\n- Simpan **jalur saat ini** sebagai string (misalnya \"DDR\").\n\n---\n\n## Langkah-langkah Algoritma\n\n1. Buat matriks `visited[][]` untuk menandai sel yang telah dikunjungi.\n2. Buat fungsi `solveMaze(x, y, path)`:\n   - Jika mencapai tujuan `(N-1, N-1)`, simpan `path`.\n   - Lanjutkan ke arah: Down (D), Left (L), Right (R), Up (U).\n   - Setelah mencoba satu arah, *backtrack* (reset visited).\n\n---\n\n## Implementasi (C++)\n\n```cpp\n#include \u003Ciostream>\n#include \u003Cvector>\n#include \u003Cstring>\n#include \u003Calgorithm>\n\nvoid solve(int x, int y, std::vector\u003Cstd::vector\u003Cint>>& maze, int n,\n           std::vector\u003Cstd::vector\u003Cbool>>& visited, std::string path,\n           std::vector\u003Cstd::string>& result) {\n    // Jika tujuan tercapai\n    if (x == n - 1 && y == n - 1) {\n        result.push_back(path);\n        return;\n    }\n\n    // Arah: D, L, R, U\n    int dx[] = {1, 0, 0, -1};\n    int dy[] = {0, -1, 1, 0};\n    char dir[] = {'D', 'L', 'R', 'U'};\n\n    for (int i = 0; i \u003C 4; ++i) {\n        int newX = x + dx[i], newY = y + dy[i];\n\n        if (newX >= 0 && newY >= 0 && newX \u003C n && newY \u003C n &&\n            maze[newX][newY] == 1 && !visited[newX][newY]) {\n            visited[newX][newY] = true;\n            solve(newX, newY, maze, n, visited, path + dir[i], result);\n            visited[newX][newY] = false; // Backtrack\n        }\n    }\n}\n\nstd::vector\u003Cstd::string> findPaths(std::vector\u003Cstd::vector\u003Cint>>& maze, int n) {\n    std::vector\u003Cstd::string> result;\n    std::vector\u003Cstd::vector\u003Cbool>> visited(n, std::vector\u003Cbool>(n, false));\n\n    if (maze[0][0] == 1) {\n        visited[0][0] = true;\n        solve(0, 0, maze, n, visited, \"\", result);\n    }\n\n    std::sort(result.begin(), result.end()); // opsional: urutkan hasil\n    return result;\n}\n\nint main() {\n    std::vector\u003Cstd::vector\u003Cint>> maze = {\n        {1, 0, 0, 0},\n        {1, 1, 0, 1},\n        {0, 1, 0, 0},\n        {1, 1, 1, 1}\n    };\n\n    int n = maze.size();\n    std::vector\u003Cstd::string> paths = findPaths(maze, n);\n\n    std::cout \u003C\u003C \"Semua jalur yang mungkin:\\n\";\n    for (const std::string& path : paths) {\n        std::cout \u003C\u003C path \u003C\u003C \"\\n\";\n    }\n\n    return 0;\n}\n",[71,8186,8187,8191,8219,8223,8227,8231,8236,8240,8257,8269,8277,8290,8297,8325,8329,8333,8337,8347,8351,8364,8376,8394,8446,8463,8467,8471,8475,8491,8495,8499,8503,8507,8512,8517,8521,8526,8531,8536,8541,8546,8551,8556,8560,8564,8569,8574,8579,8584,8588,8593,8598,8602,8607,8612,8617,8622,8627,8631,8635,8639,8643,8648,8653,8658,8662,8667,8672,8677,8681,8685,8690,8694,8698,8702,8706,8711,8716,8721,8726,8731,8736,8740,8745,8750,8754,8763,8768,8777,8781,8785,8789],{"__ignoreMap":15},[118,8188,8189],{"class":120,"line":121},[118,8190,173],{"emptyLinePlaceholder":30},[118,8192,8193,8195,8197,8199,8202,8205,8208,8211,8214,8217],{"class":120,"line":25},[118,8194,2019],{"class":151},[118,8196,2022],{"class":124},[118,8198,2019],{"class":151},[118,8200,8201],{"class":124},": Temukan semua jalur dari ",[118,8203,8204],{"class":142},"`(0, 0)`",[118,8206,8207],{"class":124}," ke ",[118,8209,8210],{"class":142},"`(3, 3)`",[118,8212,8213],{"class":124},". Dalam contoh ini, salah satu solusi bisa berupa jalur ",[118,8215,8216],{"class":142},"`DDRDRR`",[118,8218,2039],{"class":124},[118,8220,8221],{"class":120,"line":170},[118,8222,173],{"emptyLinePlaceholder":30},[118,8224,8225],{"class":120,"line":176},[118,8226,1165],{"class":151},[118,8228,8229],{"class":120,"line":195},[118,8230,173],{"emptyLinePlaceholder":30},[118,8232,8233],{"class":120,"line":201},[118,8234,8235],{"class":124},"## Strategi Penyelesaian\n",[118,8237,8238],{"class":120,"line":207},[118,8239,173],{"emptyLinePlaceholder":30},[118,8241,8242,8244,8247,8249,8252,8254],{"class":120,"line":216},[118,8243,2887],{"class":151},[118,8245,8246],{"class":124}," Gunakan algoritma ",[118,8248,2019],{"class":151},[118,8250,8251],{"class":124},"Backtracking",[118,8253,2019],{"class":151},[118,8255,8256],{"class":124}," untuk menjelajahi semua kemungkinan jalur.\n",[118,8258,8259,8261,8264,8267],{"class":120,"line":222},[118,8260,2887],{"class":151},[118,8262,8263],{"class":124}," Hanya lanjutkan ke sel ",[118,8265,8266],{"class":132},"jika",[118,8268,2054],{"class":124},[118,8270,8271,8274],{"class":120,"line":228},[118,8272,8273],{"class":151},"  -",[118,8275,8276],{"class":124}," Berada dalam batas matriks.\n",[118,8278,8279,8281,8284,8287],{"class":120,"line":238},[118,8280,8273],{"class":151},[118,8282,8283],{"class":124}," Nilainya ",[118,8285,8286],{"class":142},"`1`",[118,8288,8289],{"class":124}," (jalan).\n",[118,8291,8292,8294],{"class":120,"line":243},[118,8293,8273],{"class":151},[118,8295,8296],{"class":124}," Belum dikunjungi.\n",[118,8298,8299,8301,8304,8306,8309,8311,8313,8316,8319,8322],{"class":120,"line":252},[118,8300,2887],{"class":151},[118,8302,8303],{"class":124}," Simpan ",[118,8305,2019],{"class":151},[118,8307,8308],{"class":124},"jalur saat ini",[118,8310,2019],{"class":151},[118,8312,3655],{"class":124},[118,8314,8315],{"class":132},"string",[118,8317,8318],{"class":124}," (misalnya ",[118,8320,8321],{"class":142},"\"DDR\"",[118,8323,8324],{"class":124},").\n",[118,8326,8327],{"class":120,"line":263},[118,8328,173],{"emptyLinePlaceholder":30},[118,8330,8331],{"class":120,"line":279},[118,8332,1165],{"class":151},[118,8334,8335],{"class":120,"line":289},[118,8336,173],{"emptyLinePlaceholder":30},[118,8338,8339,8342,8344],{"class":120,"line":298},[118,8340,8341],{"class":124},"## Langkah",[118,8343,2887],{"class":151},[118,8345,8346],{"class":124},"langkah Algoritma\n",[118,8348,8349],{"class":120,"line":303},[118,8350,173],{"emptyLinePlaceholder":30},[118,8352,8353,8355,8358,8361],{"class":120,"line":316},[118,8354,2081],{"class":182},[118,8356,8357],{"class":124}," Buat matriks ",[118,8359,8360],{"class":142},"`visited[][]`",[118,8362,8363],{"class":124}," untuk menandai sel yang telah dikunjungi.\n",[118,8365,8366,8368,8371,8374],{"class":120,"line":321},[118,8367,2109],{"class":182},[118,8369,8370],{"class":124}," Buat fungsi ",[118,8372,8373],{"class":142},"`solveMaze(x, y, path)`",[118,8375,2054],{"class":124},[118,8377,8378,8380,8383,8386,8389,8392],{"class":120,"line":666},[118,8379,5898],{"class":151},[118,8381,8382],{"class":124}," Jika mencapai tujuan ",[118,8384,8385],{"class":142},"`(N-1, N-1)`",[118,8387,8388],{"class":124},", simpan ",[118,8390,8391],{"class":142},"`path`",[118,8393,2039],{"class":124},[118,8395,8396,8398,8401,8404,8406,8409,8411,8413,8416,8419,8421,8424,8426,8429,8431,8434,8436,8439,8441,8444],{"class":120,"line":1036},[118,8397,5898],{"class":151},[118,8399,8400],{"class":124}," Lanjutkan ke ",[118,8402,8403],{"class":132},"arah",[118,8405,2101],{"class":124},[118,8407,8408],{"class":132},"Down",[118,8410,397],{"class":124},[118,8412,2148],{"class":182},[118,8414,8415],{"class":124},"), ",[118,8417,8418],{"class":132},"Left",[118,8420,397],{"class":124},[118,8422,8423],{"class":182},"L",[118,8425,8415],{"class":124},[118,8427,8428],{"class":132},"Right",[118,8430,397],{"class":124},[118,8432,8433],{"class":182},"R",[118,8435,8415],{"class":124},[118,8437,8438],{"class":132},"Up",[118,8440,397],{"class":124},[118,8442,8443],{"class":182},"U",[118,8445,8324],{"class":124},[118,8447,8448,8450,8453,8456,8458,8460],{"class":120,"line":1042},[118,8449,5898],{"class":151},[118,8451,8452],{"class":124}," Setelah mencoba satu arah, ",[118,8454,8455],{"class":151},"*",[118,8457,7418],{"class":124},[118,8459,8455],{"class":151},[118,8461,8462],{"class":124}," (reset visited).\n",[118,8464,8465],{"class":120,"line":1242},[118,8466,173],{"emptyLinePlaceholder":30},[118,8468,8469],{"class":120,"line":1248},[118,8470,1165],{"class":151},[118,8472,8473],{"class":120,"line":1254},[118,8474,173],{"emptyLinePlaceholder":30},[118,8476,8477,8480,8483,8485,8487,8489],{"class":120,"line":1259},[118,8478,8479],{"class":124},"## ",[118,8481,8482],{"class":132},"Implementasi",[118,8484,397],{"class":124},[118,8486,2125],{"class":182},[118,8488,650],{"class":151},[118,8490,3798],{"class":124},[118,8492,8493],{"class":120,"line":1265},[118,8494,173],{"emptyLinePlaceholder":30},[118,8496,8497],{"class":120,"line":1270},[118,8498,2256],{"class":142},[118,8500,8501],{"class":120,"line":1275},[118,8502,2261],{"class":142},[118,8504,8505],{"class":120,"line":1280},[118,8506,2266],{"class":142},[118,8508,8509],{"class":120,"line":1286},[118,8510,8511],{"class":142},"#include \u003Cstring>\n",[118,8513,8514],{"class":120,"line":1291},[118,8515,8516],{"class":142},"#include \u003Calgorithm>\n",[118,8518,8519],{"class":120,"line":1297},[118,8520,173],{"emptyLinePlaceholder":30},[118,8522,8523],{"class":120,"line":1302},[118,8524,8525],{"class":142},"void solve(int x, int y, std::vector\u003Cstd::vector\u003Cint>>& maze, int n,\n",[118,8527,8528],{"class":120,"line":1308},[118,8529,8530],{"class":142},"           std::vector\u003Cstd::vector\u003Cbool>>& visited, std::string path,\n",[118,8532,8533],{"class":120,"line":1314},[118,8534,8535],{"class":142},"           std::vector\u003Cstd::string>& result) {\n",[118,8537,8538],{"class":120,"line":1320},[118,8539,8540],{"class":142},"    // Jika tujuan tercapai\n",[118,8542,8543],{"class":120,"line":1326},[118,8544,8545],{"class":142},"    if (x == n - 1 && y == n - 1) {\n",[118,8547,8548],{"class":120,"line":1332},[118,8549,8550],{"class":142},"        result.push_back(path);\n",[118,8552,8553],{"class":120,"line":1338},[118,8554,8555],{"class":142},"        return;\n",[118,8557,8558],{"class":120,"line":1344},[118,8559,621],{"class":142},[118,8561,8562],{"class":120,"line":1349},[118,8563,173],{"emptyLinePlaceholder":30},[118,8565,8566],{"class":120,"line":1355},[118,8567,8568],{"class":142},"    // Arah: D, L, R, U\n",[118,8570,8571],{"class":120,"line":1360},[118,8572,8573],{"class":142},"    int dx[] = {1, 0, 0, -1};\n",[118,8575,8576],{"class":120,"line":1366},[118,8577,8578],{"class":142},"    int dy[] = {0, -1, 1, 0};\n",[118,8580,8581],{"class":120,"line":1372},[118,8582,8583],{"class":142},"    char dir[] = {'D', 'L', 'R', 'U'};\n",[118,8585,8586],{"class":120,"line":1378},[118,8587,173],{"emptyLinePlaceholder":30},[118,8589,8590],{"class":120,"line":1384},[118,8591,8592],{"class":142},"    for (int i = 0; i \u003C 4; ++i) {\n",[118,8594,8595],{"class":120,"line":1390},[118,8596,8597],{"class":142},"        int newX = x + dx[i], newY = y + dy[i];\n",[118,8599,8600],{"class":120,"line":1395},[118,8601,173],{"emptyLinePlaceholder":30},[118,8603,8604],{"class":120,"line":1401},[118,8605,8606],{"class":142},"        if (newX >= 0 && newY >= 0 && newX \u003C n && newY \u003C n &&\n",[118,8608,8609],{"class":120,"line":1406},[118,8610,8611],{"class":142},"            maze[newX][newY] == 1 && !visited[newX][newY]) {\n",[118,8613,8614],{"class":120,"line":1411},[118,8615,8616],{"class":142},"            visited[newX][newY] = true;\n",[118,8618,8619],{"class":120,"line":1416},[118,8620,8621],{"class":142},"            solve(newX, newY, maze, n, visited, path + dir[i], result);\n",[118,8623,8624],{"class":120,"line":1422},[118,8625,8626],{"class":142},"            visited[newX][newY] = false; // Backtrack\n",[118,8628,8629],{"class":120,"line":1427},[118,8630,1598],{"class":142},[118,8632,8633],{"class":120,"line":1433},[118,8634,621],{"class":142},[118,8636,8637],{"class":120,"line":1439},[118,8638,757],{"class":142},[118,8640,8641],{"class":120,"line":1445},[118,8642,173],{"emptyLinePlaceholder":30},[118,8644,8645],{"class":120,"line":1451},[118,8646,8647],{"class":142},"std::vector\u003Cstd::string> findPaths(std::vector\u003Cstd::vector\u003Cint>>& maze, int n) {\n",[118,8649,8650],{"class":120,"line":1457},[118,8651,8652],{"class":142},"    std::vector\u003Cstd::string> result;\n",[118,8654,8655],{"class":120,"line":1462},[118,8656,8657],{"class":142},"    std::vector\u003Cstd::vector\u003Cbool>> visited(n, std::vector\u003Cbool>(n, false));\n",[118,8659,8660],{"class":120,"line":1468},[118,8661,173],{"emptyLinePlaceholder":30},[118,8663,8664],{"class":120,"line":1474},[118,8665,8666],{"class":142},"    if (maze[0][0] == 1) {\n",[118,8668,8669],{"class":120,"line":1480},[118,8670,8671],{"class":142},"        visited[0][0] = true;\n",[118,8673,8674],{"class":120,"line":1486},[118,8675,8676],{"class":142},"        solve(0, 0, maze, n, visited, \"\", result);\n",[118,8678,8679],{"class":120,"line":1491},[118,8680,621],{"class":142},[118,8682,8683],{"class":120,"line":1497},[118,8684,173],{"emptyLinePlaceholder":30},[118,8686,8687],{"class":120,"line":1502},[118,8688,8689],{"class":142},"    std::sort(result.begin(), result.end()); // opsional: urutkan hasil\n",[118,8691,8692],{"class":120,"line":1508},[118,8693,1611],{"class":142},[118,8695,8696],{"class":120,"line":1514},[118,8697,757],{"class":142},[118,8699,8700],{"class":120,"line":1520},[118,8701,173],{"emptyLinePlaceholder":30},[118,8703,8704],{"class":120,"line":1526},[118,8705,2383],{"class":142},[118,8707,8708],{"class":120,"line":3289},[118,8709,8710],{"class":142},"    std::vector\u003Cstd::vector\u003Cint>> maze = {\n",[118,8712,8713],{"class":120,"line":3298},[118,8714,8715],{"class":142},"        {1, 0, 0, 0},\n",[118,8717,8718],{"class":120,"line":3303},[118,8719,8720],{"class":142},"        {1, 1, 0, 1},\n",[118,8722,8723],{"class":120,"line":3309},[118,8724,8725],{"class":142},"        {0, 1, 0, 0},\n",[118,8727,8728],{"class":120,"line":3315},[118,8729,8730],{"class":142},"        {1, 1, 1, 1}\n",[118,8732,8733],{"class":120,"line":3324},[118,8734,8735],{"class":142},"    };\n",[118,8737,8738],{"class":120,"line":3329},[118,8739,173],{"emptyLinePlaceholder":30},[118,8741,8742],{"class":120,"line":3334},[118,8743,8744],{"class":142},"    int n = maze.size();\n",[118,8746,8747],{"class":120,"line":5052},[118,8748,8749],{"class":142},"    std::vector\u003Cstd::string> paths = findPaths(maze, n);\n",[118,8751,8752],{"class":120,"line":5058},[118,8753,173],{"emptyLinePlaceholder":30},[118,8755,8756,8759,8761],{"class":120,"line":5063},[118,8757,8758],{"class":142},"    std::cout \u003C\u003C \"Semua jalur yang mungkin:",[118,8760,2459],{"class":182},[118,8762,2462],{"class":142},[118,8764,8765],{"class":120,"line":5069},[118,8766,8767],{"class":142},"    for (const std::string& path : paths) {\n",[118,8769,8770,8773,8775],{"class":120,"line":5075},[118,8771,8772],{"class":142},"        std::cout \u003C\u003C path \u003C\u003C \"",[118,8774,2459],{"class":182},[118,8776,2462],{"class":142},[118,8778,8779],{"class":120,"line":5081},[118,8780,621],{"class":142},[118,8782,8783],{"class":120,"line":5087},[118,8784,173],{"emptyLinePlaceholder":30},[118,8786,8787],{"class":120,"line":5093},[118,8788,2471],{"class":142},[118,8790,8791],{"class":120,"line":5099},[118,8792,757],{"class":142},[53,8794,2479],{"id":2478},[85,8796,6468],{"id":1689},[1652,8798,8799,8806,8809],{},[1655,8800,8801,8802,8805],{},"Menemukan ",[101,8803,8804],{},"semua solusi"," yang mungkin dari start ke goal.",[1655,8807,8808],{},"Cocok untuk belajar backtracking dan logika rekursi.",[1655,8810,8811,8812,8814,8815,1750],{},"Bisa dimodifikasi untuk menemukan ",[101,8813,6502],{}," (dengan BFS) atau ",[101,8816,8817],{},"jumlah total jalur",[85,8819,6488],{"id":1710},[1652,8821,8822,8829,8832],{},[1655,8823,8824,8825,8828],{},"Tidak efisien untuk maze besar: ",[101,8826,8827],{},"O(4^NÂ²)"," kemungkinan.",[1655,8830,8831],{},"Tidak otomatis memilih jalur terpendek.",[1655,8833,8834],{},"Bisa memakan banyak memori (rekursi dalam).",[53,8836,2541],{"id":1731},[17,8838,8839,8840,8843,8844,8847,8848,8850],{},"Algoritma ",[101,8841,8842],{},"Rat in a Maze"," adalah latihan penting dalam pemrograman rekursif dan backtracking. Ia memperkenalkan cara berpikir ",[101,8845,8846],{},"eksplorasi semua kemungkinan"," dengan penelusuran sistematis dan ",[1758,8849,7418],{}," untuk kembali ke titik sebelumnya saat buntu.",[1752,8852,8853],{},[17,8854,8855],{},"ğŸ§  Sangat cocok untuk mengembangkan pemahaman tentang DFS, backtracking, dan pengambilan keputusan bertahap dalam pemrograman.",[308,8857,8858],{},"html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html pre.shiki code .sEiGg, html code.shiki .sEiGg{--shiki-dark:#F97583;--shiki-default:#F97583;--shiki-light:#D73A49}html pre.shiki code .suVJd, html code.shiki .suVJd{--shiki-dark:#E1E4E8;--shiki-default:#E1E4E8;--shiki-light:#24292E}html pre.shiki code .sYTnl, html code.shiki .sYTnl{--shiki-dark:#9ECBFF;--shiki-default:#9ECBFF;--shiki-light:#032F62}html pre.shiki code .s9E-l, html code.shiki .s9E-l{--shiki-dark:#B392F0;--shiki-default:#B392F0;--shiki-light:#6F42C1}html pre.shiki code .sAPL1, html code.shiki .sAPL1{--shiki-dark:#79B8FF;--shiki-default:#79B8FF;--shiki-light:#005CC5}",{"title":15,"searchDepth":25,"depth":25,"links":8860},[8861,8865],{"id":2478,"depth":25,"text":2479,"children":8862},[8863,8864],{"id":1689,"depth":170,"text":6468},{"id":1710,"depth":170,"text":6488},{"id":1731,"depth":25,"text":2541},"Pelajari bagaimana menemukan jalur keluar untuk tikus dalam labirin menggunakan backtracking.",{"script":8868},[8869],{"type":1781,"key":1782,"data-nuxt-schema-org":30,"nodes":8870},[8871],{"_resolver":1785},"/articles/5.jpeg",{},{"props":8875},{},"/en/articles/rat-in-maze",{"_resolver":1785},{"title":8108,"description":8866},{"loc":8876,"videos":8880,"images":8881,"lastmod":2579},[],[],"en/articles/rat-in-maze",[],"I3MTz4mFXW1XUP_Ddzqrr3Tzsuw7N5ZAsZXhzgroz7U",{"id":8886,"title":8887,"body":8888,"date":27,"description":9336,"extension":28,"head":9337,"image":9342,"meta":9343,"navigation":30,"ogImage":9344,"path":9346,"readingTime":27,"robots":27,"schemaOrg":9347,"seo":9348,"sitemap":9349,"stem":9352,"tags":9353,"__hash__":9354},"articles_en/en/articles/subset-sum-problem.md","Masalah Subset Sum",{"type":7,"value":8889,"toc":9328},[8890,8894,9274,9278,9281,9283,9285,9300,9302,9314,9316,9326],[269,8891,8893],{"id":8892},"subset-sum-problem","SUBSET SUM PROBLEM",[109,8895,8897],{"className":1129,"code":8896,"language":1131,"meta":15,"style":15},"# Masalah Subset Sum: Apakah Ada Subset yang Jumlahnya Sama dengan Target?\n\nMasalah **Subset Sum** adalah salah satu masalah klasik dalam **ilmu komputer dan teori algoritma**, khususnya dalam kategori **NP-Complete Problem**. Tujuan dari masalah ini adalah untuk menentukan apakah terdapat **subset dari suatu himpunan bilangan bulat** yang **jumlah elemennya sama dengan nilai target tertentu**.\n\n---\n\n## Contoh Masalah\n\n**Input**:\n- Himpunan: `{3, 34, 4, 12, 5, 2}`\n- Target: `9`\n\n**Pertanyaan**:\nApakah ada subset dari elemen-elemen di atas yang jika dijumlahkan menghasilkan `9`?\n\n**Jawaban**:\nâœ… Ya, subset `{4, 5}` menghasilkan jumlah `9`.\n\n---\n\n## Aplikasi Nyata\n\nMasalah ini muncul dalam berbagai konteks praktis:\n\n- ğŸ’³ **Pemilihan kombinasi item** agar sesuai dengan kapasitas maksimum (misalnya dalam masalah knapsack).\n- ğŸ’µ **Pengalokasian sumber daya** untuk mencapai target anggaran.\n- ğŸ§© **Permainan dan puzzle logika**.\n- ğŸ” **Kriptografi**, terutama dalam konstruk algoritma knapsack cryptosystem.\n\n---\n\n## Pendekatan Penyelesaian\n\n### 1. **Rekursi Brute-Force**\nCoba semua kemungkinan subset. Kompleksitas waktu: `O(2^n)`.\n\n### 2. **Memoization / Top-down Dynamic Programming**\nGunakan cache untuk menyimpan hasil submasalah. Kompleksitas waktu: `O(n * target)`.\n\n### 3. **Tabulasi / Bottom-up DP**\nGunakan tabel boolean `dp[i][j]` yang menyatakan apakah mungkin mendapatkan jumlah `j` dari elemen `0...i`.\n\n---\n\n## Implementasi C++: Dynamic Programming\n\n```cpp\n#include \u003Ciostream>\n#include \u003Cvector>\n\nbool isSubsetSum(const std::vector\u003Cint>& nums, int target) {\n    int n = nums.size();\n    std::vector\u003Cstd::vector\u003Cbool>> dp(n + 1, std::vector\u003Cbool>(target + 1, false));\n\n    // Inisialisasi: target 0 bisa dicapai tanpa memilih elemen\n    for (int i = 0; i \u003C= n; i++) dp[i][0] = true;\n\n    // Mengisi tabel DP\n    for (int i = 1; i \u003C= n; i++) {\n        for (int sum = 1; sum \u003C= target; sum++) {\n            if (nums[i - 1] \u003C= sum) {\n                dp[i][sum] = dp[i - 1][sum] || dp[i - 1][sum - nums[i - 1]];\n            } else {\n                dp[i][sum] = dp[i - 1][sum];\n            }\n        }\n    }\n\n    return dp[n][target];\n}\n\nint main() {\n    std::vector\u003Cint> set = {3, 34, 4, 12, 5, 2};\n    int target = 9;\n\n    if (isSubsetSum(set, target)) {\n        std::cout \u003C\u003C \"Ada subset dengan jumlah sama dengan target.\\n\";\n    } else {\n        std::cout \u003C\u003C \"Tidak ada subset yang cocok.\\n\";\n    }\n\n    return 0;\n}\n",[71,8898,8899,8904,8908,8913,8917,8921,8925,8930,8934,8939,8944,8949,8953,8958,8963,8967,8972,8977,8981,8985,8989,8994,8998,9003,9007,9012,9017,9022,9027,9031,9035,9039,9044,9048,9053,9058,9062,9067,9072,9076,9081,9086,9090,9094,9098,9103,9107,9111,9115,9119,9123,9128,9133,9138,9142,9147,9152,9156,9161,9166,9171,9176,9181,9186,9191,9195,9199,9203,9207,9212,9216,9220,9224,9229,9234,9238,9243,9248,9253,9258,9262,9266,9270],{"__ignoreMap":15},[118,8900,8901],{"class":120,"line":121},[118,8902,8903],{},"# Masalah Subset Sum: Apakah Ada Subset yang Jumlahnya Sama dengan Target?\n",[118,8905,8906],{"class":120,"line":25},[118,8907,173],{"emptyLinePlaceholder":30},[118,8909,8910],{"class":120,"line":170},[118,8911,8912],{},"Masalah **Subset Sum** adalah salah satu masalah klasik dalam **ilmu komputer dan teori algoritma**, khususnya dalam kategori **NP-Complete Problem**. Tujuan dari masalah ini adalah untuk menentukan apakah terdapat **subset dari suatu himpunan bilangan bulat** yang **jumlah elemennya sama dengan nilai target tertentu**.\n",[118,8914,8915],{"class":120,"line":176},[118,8916,173],{"emptyLinePlaceholder":30},[118,8918,8919],{"class":120,"line":195},[118,8920,1165],{},[118,8922,8923],{"class":120,"line":201},[118,8924,173],{"emptyLinePlaceholder":30},[118,8926,8927],{"class":120,"line":207},[118,8928,8929],{},"## Contoh Masalah\n",[118,8931,8932],{"class":120,"line":216},[118,8933,173],{"emptyLinePlaceholder":30},[118,8935,8936],{"class":120,"line":222},[118,8937,8938],{},"**Input**:\n",[118,8940,8941],{"class":120,"line":228},[118,8942,8943],{},"- Himpunan: `{3, 34, 4, 12, 5, 2}`\n",[118,8945,8946],{"class":120,"line":238},[118,8947,8948],{},"- Target: `9`\n",[118,8950,8951],{"class":120,"line":243},[118,8952,173],{"emptyLinePlaceholder":30},[118,8954,8955],{"class":120,"line":252},[118,8956,8957],{},"**Pertanyaan**:\n",[118,8959,8960],{"class":120,"line":263},[118,8961,8962],{},"Apakah ada subset dari elemen-elemen di atas yang jika dijumlahkan menghasilkan `9`?\n",[118,8964,8965],{"class":120,"line":279},[118,8966,173],{"emptyLinePlaceholder":30},[118,8968,8969],{"class":120,"line":289},[118,8970,8971],{},"**Jawaban**:\n",[118,8973,8974],{"class":120,"line":298},[118,8975,8976],{},"âœ… Ya, subset `{4, 5}` menghasilkan jumlah `9`.\n",[118,8978,8979],{"class":120,"line":303},[118,8980,173],{"emptyLinePlaceholder":30},[118,8982,8983],{"class":120,"line":316},[118,8984,1165],{},[118,8986,8987],{"class":120,"line":321},[118,8988,173],{"emptyLinePlaceholder":30},[118,8990,8991],{"class":120,"line":666},[118,8992,8993],{},"## Aplikasi Nyata\n",[118,8995,8996],{"class":120,"line":1036},[118,8997,173],{"emptyLinePlaceholder":30},[118,8999,9000],{"class":120,"line":1042},[118,9001,9002],{},"Masalah ini muncul dalam berbagai konteks praktis:\n",[118,9004,9005],{"class":120,"line":1242},[118,9006,173],{"emptyLinePlaceholder":30},[118,9008,9009],{"class":120,"line":1248},[118,9010,9011],{},"- ğŸ’³ **Pemilihan kombinasi item** agar sesuai dengan kapasitas maksimum (misalnya dalam masalah knapsack).\n",[118,9013,9014],{"class":120,"line":1254},[118,9015,9016],{},"- ğŸ’µ **Pengalokasian sumber daya** untuk mencapai target anggaran.\n",[118,9018,9019],{"class":120,"line":1259},[118,9020,9021],{},"- ğŸ§© **Permainan dan puzzle logika**.\n",[118,9023,9024],{"class":120,"line":1265},[118,9025,9026],{},"- ğŸ” **Kriptografi**, terutama dalam konstruk algoritma knapsack cryptosystem.\n",[118,9028,9029],{"class":120,"line":1270},[118,9030,173],{"emptyLinePlaceholder":30},[118,9032,9033],{"class":120,"line":1275},[118,9034,1165],{},[118,9036,9037],{"class":120,"line":1280},[118,9038,173],{"emptyLinePlaceholder":30},[118,9040,9041],{"class":120,"line":1286},[118,9042,9043],{},"## Pendekatan Penyelesaian\n",[118,9045,9046],{"class":120,"line":1291},[118,9047,173],{"emptyLinePlaceholder":30},[118,9049,9050],{"class":120,"line":1297},[118,9051,9052],{},"### 1. **Rekursi Brute-Force**\n",[118,9054,9055],{"class":120,"line":1302},[118,9056,9057],{},"Coba semua kemungkinan subset. Kompleksitas waktu: `O(2^n)`.\n",[118,9059,9060],{"class":120,"line":1308},[118,9061,173],{"emptyLinePlaceholder":30},[118,9063,9064],{"class":120,"line":1314},[118,9065,9066],{},"### 2. **Memoization / Top-down Dynamic Programming**\n",[118,9068,9069],{"class":120,"line":1320},[118,9070,9071],{},"Gunakan cache untuk menyimpan hasil submasalah. Kompleksitas waktu: `O(n * target)`.\n",[118,9073,9074],{"class":120,"line":1326},[118,9075,173],{"emptyLinePlaceholder":30},[118,9077,9078],{"class":120,"line":1332},[118,9079,9080],{},"### 3. **Tabulasi / Bottom-up DP**\n",[118,9082,9083],{"class":120,"line":1338},[118,9084,9085],{},"Gunakan tabel boolean `dp[i][j]` yang menyatakan apakah mungkin mendapatkan jumlah `j` dari elemen `0...i`.\n",[118,9087,9088],{"class":120,"line":1344},[118,9089,173],{"emptyLinePlaceholder":30},[118,9091,9092],{"class":120,"line":1349},[118,9093,1165],{},[118,9095,9096],{"class":120,"line":1355},[118,9097,173],{"emptyLinePlaceholder":30},[118,9099,9100],{"class":120,"line":1360},[118,9101,9102],{},"## Implementasi C++: Dynamic Programming\n",[118,9104,9105],{"class":120,"line":1366},[118,9106,173],{"emptyLinePlaceholder":30},[118,9108,9109],{"class":120,"line":1372},[118,9110,2256],{},[118,9112,9113],{"class":120,"line":1378},[118,9114,2261],{},[118,9116,9117],{"class":120,"line":1384},[118,9118,2266],{},[118,9120,9121],{"class":120,"line":1390},[118,9122,173],{"emptyLinePlaceholder":30},[118,9124,9125],{"class":120,"line":1395},[118,9126,9127],{},"bool isSubsetSum(const std::vector\u003Cint>& nums, int target) {\n",[118,9129,9130],{"class":120,"line":1401},[118,9131,9132],{},"    int n = nums.size();\n",[118,9134,9135],{"class":120,"line":1406},[118,9136,9137],{},"    std::vector\u003Cstd::vector\u003Cbool>> dp(n + 1, std::vector\u003Cbool>(target + 1, false));\n",[118,9139,9140],{"class":120,"line":1411},[118,9141,173],{"emptyLinePlaceholder":30},[118,9143,9144],{"class":120,"line":1416},[118,9145,9146],{},"    // Inisialisasi: target 0 bisa dicapai tanpa memilih elemen\n",[118,9148,9149],{"class":120,"line":1422},[118,9150,9151],{},"    for (int i = 0; i \u003C= n; i++) dp[i][0] = true;\n",[118,9153,9154],{"class":120,"line":1427},[118,9155,173],{"emptyLinePlaceholder":30},[118,9157,9158],{"class":120,"line":1433},[118,9159,9160],{},"    // Mengisi tabel DP\n",[118,9162,9163],{"class":120,"line":1439},[118,9164,9165],{},"    for (int i = 1; i \u003C= n; i++) {\n",[118,9167,9168],{"class":120,"line":1445},[118,9169,9170],{},"        for (int sum = 1; sum \u003C= target; sum++) {\n",[118,9172,9173],{"class":120,"line":1451},[118,9174,9175],{},"            if (nums[i - 1] \u003C= sum) {\n",[118,9177,9178],{"class":120,"line":1457},[118,9179,9180],{},"                dp[i][sum] = dp[i - 1][sum] || dp[i - 1][sum - nums[i - 1]];\n",[118,9182,9183],{"class":120,"line":1462},[118,9184,9185],{},"            } else {\n",[118,9187,9188],{"class":120,"line":1468},[118,9189,9190],{},"                dp[i][sum] = dp[i - 1][sum];\n",[118,9192,9193],{"class":120,"line":1474},[118,9194,2362],{},[118,9196,9197],{"class":120,"line":1480},[118,9198,1598],{},[118,9200,9201],{"class":120,"line":1486},[118,9202,621],{},[118,9204,9205],{"class":120,"line":1491},[118,9206,173],{"emptyLinePlaceholder":30},[118,9208,9209],{"class":120,"line":1497},[118,9210,9211],{},"    return dp[n][target];\n",[118,9213,9214],{"class":120,"line":1502},[118,9215,757],{},[118,9217,9218],{"class":120,"line":1508},[118,9219,173],{"emptyLinePlaceholder":30},[118,9221,9222],{"class":120,"line":1514},[118,9223,2383],{},[118,9225,9226],{"class":120,"line":1520},[118,9227,9228],{},"    std::vector\u003Cint> set = {3, 34, 4, 12, 5, 2};\n",[118,9230,9231],{"class":120,"line":1526},[118,9232,9233],{},"    int target = 9;\n",[118,9235,9236],{"class":120,"line":3289},[118,9237,173],{"emptyLinePlaceholder":30},[118,9239,9240],{"class":120,"line":3298},[118,9241,9242],{},"    if (isSubsetSum(set, target)) {\n",[118,9244,9245],{"class":120,"line":3303},[118,9246,9247],{},"        std::cout \u003C\u003C \"Ada subset dengan jumlah sama dengan target.\\n\";\n",[118,9249,9250],{"class":120,"line":3309},[118,9251,9252],{},"    } else {\n",[118,9254,9255],{"class":120,"line":3315},[118,9256,9257],{},"        std::cout \u003C\u003C \"Tidak ada subset yang cocok.\\n\";\n",[118,9259,9260],{"class":120,"line":3324},[118,9261,621],{},[118,9263,9264],{"class":120,"line":3329},[118,9265,173],{"emptyLinePlaceholder":30},[118,9267,9268],{"class":120,"line":3334},[118,9269,2471],{},[118,9271,9272],{"class":120,"line":5052},[118,9273,757],{},[53,9275,9277],{"id":9276},"visualisasi-tabel-dp-contoh","Visualisasi Tabel DP (Contoh)",[17,9279,9280],{},"Elemen â†’ 0 3 34 4 12 5 2 Target 0 T T T T T T T Target 1 F F F F F F T Target 2 F F F F F F T Target 3 F T T T T T T ...",[53,9282,2479],{"id":2478},[85,9284,6468],{"id":1689},[1652,9286,9287,9290,9293],{},[1655,9288,9289],{},"Memberi solusi pasti untuk masalah subset.",[1655,9291,9292],{},"Dapat dimodifikasi untuk menghitung jumlah kombinasi, mencetak subset, dsb.",[1655,9294,9295,9296,9299],{},"Cocok untuk ",[101,9297,9298],{},"pendekatan dinamis"," dan pembelajaran dasar DP.",[85,9301,6488],{"id":1710},[1652,9303,9304,9311],{},[1655,9305,9306,9307,9310],{},"Waktu eksekusi bisa ",[101,9308,9309],{},"eksponensial"," untuk input besar jika menggunakan brute-force.",[1655,9312,9313],{},"Memori besar jika target besar (meskipun bisa dioptimalkan ke 1D array).",[53,9315,2541],{"id":1731},[17,9317,8007,9318,9321,9322,9325],{},[101,9319,9320],{},"Subset Sum"," adalah dasar dari banyak algoritma optimasi dan kombinatorial. Ini juga menjadi contoh klasik dari ",[101,9323,9324],{},"Dynamic Programming",", yang mengajarkan kita cara menyelesaikan masalah besar dengan memecahnya menjadi submasalah kecil.",[308,9327,1763],{},{"title":15,"searchDepth":25,"depth":25,"links":9329},[9330,9331,9335],{"id":9276,"depth":25,"text":9277},{"id":2478,"depth":25,"text":2479,"children":9332},[9333,9334],{"id":1689,"depth":170,"text":6468},{"id":1710,"depth":170,"text":6488},{"id":1731,"depth":25,"text":2541},"Masalah klasik dalam ilmu komputer: Menentukan apakah ada subset dari himpunan bilangan yang jumlahnya sama dengan nilai target tertentu",{"script":9338},[9339],{"type":1781,"key":1782,"data-nuxt-schema-org":30,"nodes":9340},[9341],{"_resolver":1785},"/articles/6.jpeg",{},{"props":9345},{},"/en/articles/subset-sum-problem",{"_resolver":1785},{"title":8887,"description":9336},{"loc":9346,"videos":9350,"images":9351,"lastmod":2579},[],[],"en/articles/subset-sum-problem",[],"pzTZZY5tTA-jObgmCvguLdjvxoYWB2Z-FZxO7TMTPx4",1750351328818]